
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model CartItem
 * 
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model PurchaseHistory
 * 
 */
export type PurchaseHistory = $Result.DefaultSelection<Prisma.$PurchaseHistoryPayload>
/**
 * Model CustomerGroups
 * 
 */
export type CustomerGroups = $Result.DefaultSelection<Prisma.$CustomerGroupsPayload>
/**
 * Model CustomerGroupMember
 * 
 */
export type CustomerGroupMember = $Result.DefaultSelection<Prisma.$CustomerGroupMemberPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model ExpenseCategory
 * 
 */
export type ExpenseCategory = $Result.DefaultSelection<Prisma.$ExpenseCategoryPayload>
/**
 * Model FeatureFlag
 * 
 */
export type FeatureFlag = $Result.DefaultSelection<Prisma.$FeatureFlagPayload>
/**
 * Model BankDetails
 * 
 */
export type BankDetails = $Result.DefaultSelection<Prisma.$BankDetailsPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model POS
 * 
 */
export type POS = $Result.DefaultSelection<Prisma.$POSPayload>
/**
 * Model PointOfSale
 * 
 */
export type PointOfSale = $Result.DefaultSelection<Prisma.$PointOfSalePayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model ProductCollection
 * 
 */
export type ProductCollection = $Result.DefaultSelection<Prisma.$ProductCollectionPayload>
/**
 * Model ProductVariation
 * 
 */
export type ProductVariation = $Result.DefaultSelection<Prisma.$ProductVariationPayload>
/**
 * Model ProductVariant
 * 
 */
export type ProductVariant = $Result.DefaultSelection<Prisma.$ProductVariantPayload>
/**
 * Model ProductVariantValue
 * 
 */
export type ProductVariantValue = $Result.DefaultSelection<Prisma.$ProductVariantValuePayload>
/**
 * Model ProductVariationOption
 * 
 */
export type ProductVariationOption = $Result.DefaultSelection<Prisma.$ProductVariationOptionPayload>
/**
 * Model FeaturedBrands
 * 
 */
export type FeaturedBrands = $Result.DefaultSelection<Prisma.$FeaturedBrandsPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>
/**
 * Model Settlement
 * 
 */
export type Settlement = $Result.DefaultSelection<Prisma.$SettlementPayload>
/**
 * Model Shipping
 * 
 */
export type Shipping = $Result.DefaultSelection<Prisma.$ShippingPayload>
/**
 * Model ShippingMethod
 * 
 */
export type ShippingMethod = $Result.DefaultSelection<Prisma.$ShippingMethodPayload>
/**
 * Model ShippingZone
 * 
 */
export type ShippingZone = $Result.DefaultSelection<Prisma.$ShippingZonePayload>
/**
 * Model ShippingAudit
 * 
 */
export type ShippingAudit = $Result.DefaultSelection<Prisma.$ShippingAuditPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Warehouse
 * 
 */
export type Warehouse = $Result.DefaultSelection<Prisma.$WarehousePayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CustomerType: {
  New: 'New',
  Old: 'Old',
  Vip: 'Vip'
};

export type CustomerType = (typeof CustomerType)[keyof typeof CustomerType]


export const OrderStatus: {
  pending: 'pending',
  awaiting_review: 'awaiting_review',
  completed: 'completed',
  shipped: 'shipped',
  shipping: 'shipping',
  cancelled: 'cancelled'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentStatus: {
  PAID: 'PAID',
  PARTLY_PAID: 'PARTLY_PAID',
  UNPAID: 'UNPAID',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  BANK_TRANSFER: 'BANK_TRANSFER',
  TERMINAL: 'TERMINAL'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const ProductStatus: {
  Unpublished: 'Unpublished',
  Published: 'Published'
};

export type ProductStatus = (typeof ProductStatus)[keyof typeof ProductStatus]


export const ShippingStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  LABEL_CREATED: 'LABEL_CREATED',
  IN_TRANSIT: 'IN_TRANSIT',
  OUT_FOR_DELIVERY: 'OUT_FOR_DELIVERY',
  DELIVERED: 'DELIVERED',
  RETURNED: 'RETURNED',
  FAILED: 'FAILED'
};

export type ShippingStatus = (typeof ShippingStatus)[keyof typeof ShippingStatus]

}

export type CustomerType = $Enums.CustomerType

export const CustomerType: typeof $Enums.CustomerType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type ProductStatus = $Enums.ProductStatus

export const ProductStatus: typeof $Enums.ProductStatus

export type ShippingStatus = $Enums.ShippingStatus

export const ShippingStatus: typeof $Enums.ShippingStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Carts
 * const carts = await prisma.cart.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Carts
   * const carts = await prisma.cart.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItem.findMany()
    * ```
    */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseHistory`: Exposes CRUD operations for the **PurchaseHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseHistories
    * const purchaseHistories = await prisma.purchaseHistory.findMany()
    * ```
    */
  get purchaseHistory(): Prisma.PurchaseHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerGroups`: Exposes CRUD operations for the **CustomerGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerGroups
    * const customerGroups = await prisma.customerGroups.findMany()
    * ```
    */
  get customerGroups(): Prisma.CustomerGroupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerGroupMember`: Exposes CRUD operations for the **CustomerGroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerGroupMembers
    * const customerGroupMembers = await prisma.customerGroupMember.findMany()
    * ```
    */
  get customerGroupMember(): Prisma.CustomerGroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseCategory`: Exposes CRUD operations for the **ExpenseCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseCategories
    * const expenseCategories = await prisma.expenseCategory.findMany()
    * ```
    */
  get expenseCategory(): Prisma.ExpenseCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featureFlag`: Exposes CRUD operations for the **FeatureFlag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeatureFlags
    * const featureFlags = await prisma.featureFlag.findMany()
    * ```
    */
  get featureFlag(): Prisma.FeatureFlagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankDetails`: Exposes CRUD operations for the **BankDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankDetails
    * const bankDetails = await prisma.bankDetails.findMany()
    * ```
    */
  get bankDetails(): Prisma.BankDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pOS`: Exposes CRUD operations for the **POS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POS
    * const pOS = await prisma.pOS.findMany()
    * ```
    */
  get pOS(): Prisma.POSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pointOfSale`: Exposes CRUD operations for the **PointOfSale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointOfSales
    * const pointOfSales = await prisma.pointOfSale.findMany()
    * ```
    */
  get pointOfSale(): Prisma.PointOfSaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCollection`: Exposes CRUD operations for the **ProductCollection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCollections
    * const productCollections = await prisma.productCollection.findMany()
    * ```
    */
  get productCollection(): Prisma.ProductCollectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productVariation`: Exposes CRUD operations for the **ProductVariation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariations
    * const productVariations = await prisma.productVariation.findMany()
    * ```
    */
  get productVariation(): Prisma.ProductVariationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productVariant`: Exposes CRUD operations for the **ProductVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariants
    * const productVariants = await prisma.productVariant.findMany()
    * ```
    */
  get productVariant(): Prisma.ProductVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productVariantValue`: Exposes CRUD operations for the **ProductVariantValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariantValues
    * const productVariantValues = await prisma.productVariantValue.findMany()
    * ```
    */
  get productVariantValue(): Prisma.ProductVariantValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productVariationOption`: Exposes CRUD operations for the **ProductVariationOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariationOptions
    * const productVariationOptions = await prisma.productVariationOption.findMany()
    * ```
    */
  get productVariationOption(): Prisma.ProductVariationOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featuredBrands`: Exposes CRUD operations for the **FeaturedBrands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeaturedBrands
    * const featuredBrands = await prisma.featuredBrands.findMany()
    * ```
    */
  get featuredBrands(): Prisma.FeaturedBrandsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settlement`: Exposes CRUD operations for the **Settlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settlements
    * const settlements = await prisma.settlement.findMany()
    * ```
    */
  get settlement(): Prisma.SettlementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shipping`: Exposes CRUD operations for the **Shipping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shippings
    * const shippings = await prisma.shipping.findMany()
    * ```
    */
  get shipping(): Prisma.ShippingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shippingMethod`: Exposes CRUD operations for the **ShippingMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShippingMethods
    * const shippingMethods = await prisma.shippingMethod.findMany()
    * ```
    */
  get shippingMethod(): Prisma.ShippingMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shippingZone`: Exposes CRUD operations for the **ShippingZone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShippingZones
    * const shippingZones = await prisma.shippingZone.findMany()
    * ```
    */
  get shippingZone(): Prisma.ShippingZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shippingAudit`: Exposes CRUD operations for the **ShippingAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShippingAudits
    * const shippingAudits = await prisma.shippingAudit.findMany()
    * ```
    */
  get shippingAudit(): Prisma.ShippingAuditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Cart: 'Cart',
    CartItem: 'CartItem',
    Customer: 'Customer',
    PurchaseHistory: 'PurchaseHistory',
    CustomerGroups: 'CustomerGroups',
    CustomerGroupMember: 'CustomerGroupMember',
    Expense: 'Expense',
    ExpenseCategory: 'ExpenseCategory',
    FeatureFlag: 'FeatureFlag',
    BankDetails: 'BankDetails',
    Wallet: 'Wallet',
    Invoice: 'Invoice',
    Location: 'Location',
    Order: 'Order',
    OrderItem: 'OrderItem',
    POS: 'POS',
    PointOfSale: 'PointOfSale',
    Product: 'Product',
    ProductCategory: 'ProductCategory',
    ProductCollection: 'ProductCollection',
    ProductVariation: 'ProductVariation',
    ProductVariant: 'ProductVariant',
    ProductVariantValue: 'ProductVariantValue',
    ProductVariationOption: 'ProductVariationOption',
    FeaturedBrands: 'FeaturedBrands',
    Supplier: 'Supplier',
    Purchase: 'Purchase',
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Organization: 'Organization',
    Member: 'Member',
    Invitation: 'Invitation',
    Settlement: 'Settlement',
    Shipping: 'Shipping',
    ShippingMethod: 'ShippingMethod',
    ShippingZone: 'ShippingZone',
    ShippingAudit: 'ShippingAudit',
    Subscription: 'Subscription',
    Plan: 'Plan',
    Transaction: 'Transaction',
    Warehouse: 'Warehouse',
    Inventory: 'Inventory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "cart" | "cartItem" | "customer" | "purchaseHistory" | "customerGroups" | "customerGroupMember" | "expense" | "expenseCategory" | "featureFlag" | "bankDetails" | "wallet" | "invoice" | "location" | "order" | "orderItem" | "pOS" | "pointOfSale" | "product" | "productCategory" | "productCollection" | "productVariation" | "productVariant" | "productVariantValue" | "productVariationOption" | "featuredBrands" | "supplier" | "purchase" | "user" | "session" | "account" | "verification" | "organization" | "member" | "invitation" | "settlement" | "shipping" | "shippingMethod" | "shippingZone" | "shippingAudit" | "subscription" | "plan" | "transaction" | "warehouse" | "inventory"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>
        fields: Prisma.CartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItem>
          }
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      PurchaseHistory: {
        payload: Prisma.$PurchaseHistoryPayload<ExtArgs>
        fields: Prisma.PurchaseHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          findFirst: {
            args: Prisma.PurchaseHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          findMany: {
            args: Prisma.PurchaseHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>[]
          }
          create: {
            args: Prisma.PurchaseHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          createMany: {
            args: Prisma.PurchaseHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>[]
          }
          delete: {
            args: Prisma.PurchaseHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          update: {
            args: Prisma.PurchaseHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          aggregate: {
            args: Prisma.PurchaseHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseHistory>
          }
          groupBy: {
            args: Prisma.PurchaseHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseHistoryCountAggregateOutputType> | number
          }
        }
      }
      CustomerGroups: {
        payload: Prisma.$CustomerGroupsPayload<ExtArgs>
        fields: Prisma.CustomerGroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerGroupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerGroupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupsPayload>
          }
          findFirst: {
            args: Prisma.CustomerGroupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerGroupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupsPayload>
          }
          findMany: {
            args: Prisma.CustomerGroupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupsPayload>[]
          }
          create: {
            args: Prisma.CustomerGroupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupsPayload>
          }
          createMany: {
            args: Prisma.CustomerGroupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerGroupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupsPayload>[]
          }
          delete: {
            args: Prisma.CustomerGroupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupsPayload>
          }
          update: {
            args: Prisma.CustomerGroupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupsPayload>
          }
          deleteMany: {
            args: Prisma.CustomerGroupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerGroupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerGroupsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupsPayload>[]
          }
          upsert: {
            args: Prisma.CustomerGroupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupsPayload>
          }
          aggregate: {
            args: Prisma.CustomerGroupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerGroups>
          }
          groupBy: {
            args: Prisma.CustomerGroupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerGroupsCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupsCountAggregateOutputType> | number
          }
        }
      }
      CustomerGroupMember: {
        payload: Prisma.$CustomerGroupMemberPayload<ExtArgs>
        fields: Prisma.CustomerGroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerGroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerGroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupMemberPayload>
          }
          findFirst: {
            args: Prisma.CustomerGroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerGroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupMemberPayload>
          }
          findMany: {
            args: Prisma.CustomerGroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupMemberPayload>[]
          }
          create: {
            args: Prisma.CustomerGroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupMemberPayload>
          }
          createMany: {
            args: Prisma.CustomerGroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerGroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupMemberPayload>[]
          }
          delete: {
            args: Prisma.CustomerGroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupMemberPayload>
          }
          update: {
            args: Prisma.CustomerGroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.CustomerGroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerGroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerGroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.CustomerGroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupMemberPayload>
          }
          aggregate: {
            args: Prisma.CustomerGroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerGroupMember>
          }
          groupBy: {
            args: Prisma.CustomerGroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerGroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupMemberCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      ExpenseCategory: {
        payload: Prisma.$ExpenseCategoryPayload<ExtArgs>
        fields: Prisma.ExpenseCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findFirst: {
            args: Prisma.ExpenseCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findMany: {
            args: Prisma.ExpenseCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          create: {
            args: Prisma.ExpenseCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          createMany: {
            args: Prisma.ExpenseCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          delete: {
            args: Prisma.ExpenseCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          update: {
            args: Prisma.ExpenseCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ExpenseCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          aggregate: {
            args: Prisma.ExpenseCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseCategory>
          }
          groupBy: {
            args: Prisma.ExpenseCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryCountAggregateOutputType> | number
          }
        }
      }
      FeatureFlag: {
        payload: Prisma.$FeatureFlagPayload<ExtArgs>
        fields: Prisma.FeatureFlagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureFlagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureFlagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          findFirst: {
            args: Prisma.FeatureFlagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureFlagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          findMany: {
            args: Prisma.FeatureFlagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>[]
          }
          create: {
            args: Prisma.FeatureFlagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          createMany: {
            args: Prisma.FeatureFlagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureFlagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>[]
          }
          delete: {
            args: Prisma.FeatureFlagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          update: {
            args: Prisma.FeatureFlagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          deleteMany: {
            args: Prisma.FeatureFlagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureFlagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureFlagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>[]
          }
          upsert: {
            args: Prisma.FeatureFlagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeatureFlagPayload>
          }
          aggregate: {
            args: Prisma.FeatureFlagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatureFlag>
          }
          groupBy: {
            args: Prisma.FeatureFlagGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureFlagGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureFlagCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureFlagCountAggregateOutputType> | number
          }
        }
      }
      BankDetails: {
        payload: Prisma.$BankDetailsPayload<ExtArgs>
        fields: Prisma.BankDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>
          }
          findFirst: {
            args: Prisma.BankDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>
          }
          findMany: {
            args: Prisma.BankDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>[]
          }
          create: {
            args: Prisma.BankDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>
          }
          createMany: {
            args: Prisma.BankDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>[]
          }
          delete: {
            args: Prisma.BankDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>
          }
          update: {
            args: Prisma.BankDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>
          }
          deleteMany: {
            args: Prisma.BankDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>[]
          }
          upsert: {
            args: Prisma.BankDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailsPayload>
          }
          aggregate: {
            args: Prisma.BankDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankDetails>
          }
          groupBy: {
            args: Prisma.BankDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<BankDetailsCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      POS: {
        payload: Prisma.$POSPayload<ExtArgs>
        fields: Prisma.POSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSPayload>
          }
          findFirst: {
            args: Prisma.POSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSPayload>
          }
          findMany: {
            args: Prisma.POSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSPayload>[]
          }
          create: {
            args: Prisma.POSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSPayload>
          }
          createMany: {
            args: Prisma.POSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.POSCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSPayload>[]
          }
          delete: {
            args: Prisma.POSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSPayload>
          }
          update: {
            args: Prisma.POSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSPayload>
          }
          deleteMany: {
            args: Prisma.POSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.POSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.POSUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSPayload>[]
          }
          upsert: {
            args: Prisma.POSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSPayload>
          }
          aggregate: {
            args: Prisma.POSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePOS>
          }
          groupBy: {
            args: Prisma.POSGroupByArgs<ExtArgs>
            result: $Utils.Optional<POSGroupByOutputType>[]
          }
          count: {
            args: Prisma.POSCountArgs<ExtArgs>
            result: $Utils.Optional<POSCountAggregateOutputType> | number
          }
        }
      }
      PointOfSale: {
        payload: Prisma.$PointOfSalePayload<ExtArgs>
        fields: Prisma.PointOfSaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointOfSaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointOfSalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointOfSaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointOfSalePayload>
          }
          findFirst: {
            args: Prisma.PointOfSaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointOfSalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointOfSaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointOfSalePayload>
          }
          findMany: {
            args: Prisma.PointOfSaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointOfSalePayload>[]
          }
          create: {
            args: Prisma.PointOfSaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointOfSalePayload>
          }
          createMany: {
            args: Prisma.PointOfSaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PointOfSaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointOfSalePayload>[]
          }
          delete: {
            args: Prisma.PointOfSaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointOfSalePayload>
          }
          update: {
            args: Prisma.PointOfSaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointOfSalePayload>
          }
          deleteMany: {
            args: Prisma.PointOfSaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointOfSaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PointOfSaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointOfSalePayload>[]
          }
          upsert: {
            args: Prisma.PointOfSaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointOfSalePayload>
          }
          aggregate: {
            args: Prisma.PointOfSaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointOfSale>
          }
          groupBy: {
            args: Prisma.PointOfSaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointOfSaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointOfSaleCountArgs<ExtArgs>
            result: $Utils.Optional<PointOfSaleCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      ProductCollection: {
        payload: Prisma.$ProductCollectionPayload<ExtArgs>
        fields: Prisma.ProductCollectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCollectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCollectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCollectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCollectionPayload>
          }
          findFirst: {
            args: Prisma.ProductCollectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCollectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCollectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCollectionPayload>
          }
          findMany: {
            args: Prisma.ProductCollectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCollectionPayload>[]
          }
          create: {
            args: Prisma.ProductCollectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCollectionPayload>
          }
          createMany: {
            args: Prisma.ProductCollectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCollectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCollectionPayload>[]
          }
          delete: {
            args: Prisma.ProductCollectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCollectionPayload>
          }
          update: {
            args: Prisma.ProductCollectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCollectionPayload>
          }
          deleteMany: {
            args: Prisma.ProductCollectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCollectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCollectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCollectionPayload>[]
          }
          upsert: {
            args: Prisma.ProductCollectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCollectionPayload>
          }
          aggregate: {
            args: Prisma.ProductCollectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCollection>
          }
          groupBy: {
            args: Prisma.ProductCollectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCollectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCollectionCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCollectionCountAggregateOutputType> | number
          }
        }
      }
      ProductVariation: {
        payload: Prisma.$ProductVariationPayload<ExtArgs>
        fields: Prisma.ProductVariationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>
          }
          findFirst: {
            args: Prisma.ProductVariationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>
          }
          findMany: {
            args: Prisma.ProductVariationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>[]
          }
          create: {
            args: Prisma.ProductVariationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>
          }
          createMany: {
            args: Prisma.ProductVariationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductVariationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>[]
          }
          delete: {
            args: Prisma.ProductVariationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>
          }
          update: {
            args: Prisma.ProductVariationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>
          }
          deleteMany: {
            args: Prisma.ProductVariationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductVariationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>[]
          }
          upsert: {
            args: Prisma.ProductVariationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationPayload>
          }
          aggregate: {
            args: Prisma.ProductVariationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariation>
          }
          groupBy: {
            args: Prisma.ProductVariationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVariationCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariationCountAggregateOutputType> | number
          }
        }
      }
      ProductVariant: {
        payload: Prisma.$ProductVariantPayload<ExtArgs>
        fields: Prisma.ProductVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findFirst: {
            args: Prisma.ProductVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findMany: {
            args: Prisma.ProductVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          create: {
            args: Prisma.ProductVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          createMany: {
            args: Prisma.ProductVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductVariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          delete: {
            args: Prisma.ProductVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          update: {
            args: Prisma.ProductVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          deleteMany: {
            args: Prisma.ProductVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductVariantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          upsert: {
            args: Prisma.ProductVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          aggregate: {
            args: Prisma.ProductVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariant>
          }
          groupBy: {
            args: Prisma.ProductVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVariantCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantCountAggregateOutputType> | number
          }
        }
      }
      ProductVariantValue: {
        payload: Prisma.$ProductVariantValuePayload<ExtArgs>
        fields: Prisma.ProductVariantValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariantValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariantValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantValuePayload>
          }
          findFirst: {
            args: Prisma.ProductVariantValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariantValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantValuePayload>
          }
          findMany: {
            args: Prisma.ProductVariantValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantValuePayload>[]
          }
          create: {
            args: Prisma.ProductVariantValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantValuePayload>
          }
          createMany: {
            args: Prisma.ProductVariantValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductVariantValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantValuePayload>[]
          }
          delete: {
            args: Prisma.ProductVariantValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantValuePayload>
          }
          update: {
            args: Prisma.ProductVariantValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantValuePayload>
          }
          deleteMany: {
            args: Prisma.ProductVariantValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariantValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductVariantValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantValuePayload>[]
          }
          upsert: {
            args: Prisma.ProductVariantValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantValuePayload>
          }
          aggregate: {
            args: Prisma.ProductVariantValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariantValue>
          }
          groupBy: {
            args: Prisma.ProductVariantValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVariantValueCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantValueCountAggregateOutputType> | number
          }
        }
      }
      ProductVariationOption: {
        payload: Prisma.$ProductVariationOptionPayload<ExtArgs>
        fields: Prisma.ProductVariationOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariationOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariationOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationOptionPayload>
          }
          findFirst: {
            args: Prisma.ProductVariationOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariationOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationOptionPayload>
          }
          findMany: {
            args: Prisma.ProductVariationOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationOptionPayload>[]
          }
          create: {
            args: Prisma.ProductVariationOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationOptionPayload>
          }
          createMany: {
            args: Prisma.ProductVariationOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductVariationOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationOptionPayload>[]
          }
          delete: {
            args: Prisma.ProductVariationOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationOptionPayload>
          }
          update: {
            args: Prisma.ProductVariationOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationOptionPayload>
          }
          deleteMany: {
            args: Prisma.ProductVariationOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariationOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductVariationOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationOptionPayload>[]
          }
          upsert: {
            args: Prisma.ProductVariationOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariationOptionPayload>
          }
          aggregate: {
            args: Prisma.ProductVariationOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariationOption>
          }
          groupBy: {
            args: Prisma.ProductVariationOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariationOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVariationOptionCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariationOptionCountAggregateOutputType> | number
          }
        }
      }
      FeaturedBrands: {
        payload: Prisma.$FeaturedBrandsPayload<ExtArgs>
        fields: Prisma.FeaturedBrandsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeaturedBrandsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBrandsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeaturedBrandsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBrandsPayload>
          }
          findFirst: {
            args: Prisma.FeaturedBrandsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBrandsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeaturedBrandsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBrandsPayload>
          }
          findMany: {
            args: Prisma.FeaturedBrandsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBrandsPayload>[]
          }
          create: {
            args: Prisma.FeaturedBrandsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBrandsPayload>
          }
          createMany: {
            args: Prisma.FeaturedBrandsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeaturedBrandsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBrandsPayload>[]
          }
          delete: {
            args: Prisma.FeaturedBrandsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBrandsPayload>
          }
          update: {
            args: Prisma.FeaturedBrandsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBrandsPayload>
          }
          deleteMany: {
            args: Prisma.FeaturedBrandsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeaturedBrandsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeaturedBrandsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBrandsPayload>[]
          }
          upsert: {
            args: Prisma.FeaturedBrandsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBrandsPayload>
          }
          aggregate: {
            args: Prisma.FeaturedBrandsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeaturedBrands>
          }
          groupBy: {
            args: Prisma.FeaturedBrandsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeaturedBrandsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeaturedBrandsCountArgs<ExtArgs>
            result: $Utils.Optional<FeaturedBrandsCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      Settlement: {
        payload: Prisma.$SettlementPayload<ExtArgs>
        fields: Prisma.SettlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          findFirst: {
            args: Prisma.SettlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          findMany: {
            args: Prisma.SettlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>[]
          }
          create: {
            args: Prisma.SettlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          createMany: {
            args: Prisma.SettlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettlementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>[]
          }
          delete: {
            args: Prisma.SettlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          update: {
            args: Prisma.SettlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          deleteMany: {
            args: Prisma.SettlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettlementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>[]
          }
          upsert: {
            args: Prisma.SettlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          aggregate: {
            args: Prisma.SettlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettlement>
          }
          groupBy: {
            args: Prisma.SettlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettlementCountArgs<ExtArgs>
            result: $Utils.Optional<SettlementCountAggregateOutputType> | number
          }
        }
      }
      Shipping: {
        payload: Prisma.$ShippingPayload<ExtArgs>
        fields: Prisma.ShippingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShippingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShippingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>
          }
          findFirst: {
            args: Prisma.ShippingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShippingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>
          }
          findMany: {
            args: Prisma.ShippingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>[]
          }
          create: {
            args: Prisma.ShippingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>
          }
          createMany: {
            args: Prisma.ShippingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShippingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>[]
          }
          delete: {
            args: Prisma.ShippingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>
          }
          update: {
            args: Prisma.ShippingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>
          }
          deleteMany: {
            args: Prisma.ShippingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShippingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShippingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>[]
          }
          upsert: {
            args: Prisma.ShippingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingPayload>
          }
          aggregate: {
            args: Prisma.ShippingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShipping>
          }
          groupBy: {
            args: Prisma.ShippingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShippingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShippingCountArgs<ExtArgs>
            result: $Utils.Optional<ShippingCountAggregateOutputType> | number
          }
        }
      }
      ShippingMethod: {
        payload: Prisma.$ShippingMethodPayload<ExtArgs>
        fields: Prisma.ShippingMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShippingMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShippingMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
          }
          findFirst: {
            args: Prisma.ShippingMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShippingMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
          }
          findMany: {
            args: Prisma.ShippingMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>[]
          }
          create: {
            args: Prisma.ShippingMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
          }
          createMany: {
            args: Prisma.ShippingMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShippingMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>[]
          }
          delete: {
            args: Prisma.ShippingMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
          }
          update: {
            args: Prisma.ShippingMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
          }
          deleteMany: {
            args: Prisma.ShippingMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShippingMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShippingMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>[]
          }
          upsert: {
            args: Prisma.ShippingMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
          }
          aggregate: {
            args: Prisma.ShippingMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShippingMethod>
          }
          groupBy: {
            args: Prisma.ShippingMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShippingMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShippingMethodCountArgs<ExtArgs>
            result: $Utils.Optional<ShippingMethodCountAggregateOutputType> | number
          }
        }
      }
      ShippingZone: {
        payload: Prisma.$ShippingZonePayload<ExtArgs>
        fields: Prisma.ShippingZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShippingZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShippingZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingZonePayload>
          }
          findFirst: {
            args: Prisma.ShippingZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShippingZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingZonePayload>
          }
          findMany: {
            args: Prisma.ShippingZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingZonePayload>[]
          }
          create: {
            args: Prisma.ShippingZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingZonePayload>
          }
          createMany: {
            args: Prisma.ShippingZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShippingZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingZonePayload>[]
          }
          delete: {
            args: Prisma.ShippingZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingZonePayload>
          }
          update: {
            args: Prisma.ShippingZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingZonePayload>
          }
          deleteMany: {
            args: Prisma.ShippingZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShippingZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShippingZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingZonePayload>[]
          }
          upsert: {
            args: Prisma.ShippingZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingZonePayload>
          }
          aggregate: {
            args: Prisma.ShippingZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShippingZone>
          }
          groupBy: {
            args: Prisma.ShippingZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShippingZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShippingZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ShippingZoneCountAggregateOutputType> | number
          }
        }
      }
      ShippingAudit: {
        payload: Prisma.$ShippingAuditPayload<ExtArgs>
        fields: Prisma.ShippingAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShippingAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShippingAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingAuditPayload>
          }
          findFirst: {
            args: Prisma.ShippingAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShippingAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingAuditPayload>
          }
          findMany: {
            args: Prisma.ShippingAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingAuditPayload>[]
          }
          create: {
            args: Prisma.ShippingAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingAuditPayload>
          }
          createMany: {
            args: Prisma.ShippingAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShippingAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingAuditPayload>[]
          }
          delete: {
            args: Prisma.ShippingAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingAuditPayload>
          }
          update: {
            args: Prisma.ShippingAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingAuditPayload>
          }
          deleteMany: {
            args: Prisma.ShippingAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShippingAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShippingAuditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingAuditPayload>[]
          }
          upsert: {
            args: Prisma.ShippingAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingAuditPayload>
          }
          aggregate: {
            args: Prisma.ShippingAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShippingAudit>
          }
          groupBy: {
            args: Prisma.ShippingAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShippingAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShippingAuditCountArgs<ExtArgs>
            result: $Utils.Optional<ShippingAuditCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Warehouse: {
        payload: Prisma.$WarehousePayload<ExtArgs>
        fields: Prisma.WarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findFirst: {
            args: Prisma.WarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findMany: {
            args: Prisma.WarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          create: {
            args: Prisma.WarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          createMany: {
            args: Prisma.WarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          delete: {
            args: Prisma.WarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          update: {
            args: Prisma.WarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.WarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    cart?: CartOmit
    cartItem?: CartItemOmit
    customer?: CustomerOmit
    purchaseHistory?: PurchaseHistoryOmit
    customerGroups?: CustomerGroupsOmit
    customerGroupMember?: CustomerGroupMemberOmit
    expense?: ExpenseOmit
    expenseCategory?: ExpenseCategoryOmit
    featureFlag?: FeatureFlagOmit
    bankDetails?: BankDetailsOmit
    wallet?: WalletOmit
    invoice?: InvoiceOmit
    location?: LocationOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    pOS?: POSOmit
    pointOfSale?: PointOfSaleOmit
    product?: ProductOmit
    productCategory?: ProductCategoryOmit
    productCollection?: ProductCollectionOmit
    productVariation?: ProductVariationOmit
    productVariant?: ProductVariantOmit
    productVariantValue?: ProductVariantValueOmit
    productVariationOption?: ProductVariationOptionOmit
    featuredBrands?: FeaturedBrandsOmit
    supplier?: SupplierOmit
    purchase?: PurchaseOmit
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    organization?: OrganizationOmit
    member?: MemberOmit
    invitation?: InvitationOmit
    settlement?: SettlementOmit
    shipping?: ShippingOmit
    shippingMethod?: ShippingMethodOmit
    shippingZone?: ShippingZoneOmit
    shippingAudit?: ShippingAuditOmit
    subscription?: SubscriptionOmit
    plan?: PlanOmit
    transaction?: TransactionOmit
    warehouse?: WarehouseOmit
    inventory?: InventoryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    cartItems: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItems?: boolean | CartCountOutputTypeCountCartItemsArgs
  }

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
    carts: number
    purchaseHistory: number
    pos: number
    customerGroupMember: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    carts?: boolean | CustomerCountOutputTypeCountCartsArgs
    purchaseHistory?: boolean | CustomerCountOutputTypeCountPurchaseHistoryArgs
    pos?: boolean | CustomerCountOutputTypeCountPosArgs
    customerGroupMember?: boolean | CustomerCountOutputTypeCountCustomerGroupMemberArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPurchaseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseHistoryWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerGroupMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerGroupMemberWhereInput
  }


  /**
   * Count Type CustomerGroupsCountOutputType
   */

  export type CustomerGroupsCountOutputType = {
    customerGroupMember: number
  }

  export type CustomerGroupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerGroupMember?: boolean | CustomerGroupsCountOutputTypeCountCustomerGroupMemberArgs
  }

  // Custom InputTypes
  /**
   * CustomerGroupsCountOutputType without action
   */
  export type CustomerGroupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupsCountOutputType
     */
    select?: CustomerGroupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerGroupsCountOutputType without action
   */
  export type CustomerGroupsCountOutputTypeCountCustomerGroupMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerGroupMemberWhereInput
  }


  /**
   * Count Type ExpenseCountOutputType
   */

  export type ExpenseCountOutputType = {
    expenseCategory: number
  }

  export type ExpenseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenseCategory?: boolean | ExpenseCountOutputTypeCountExpenseCategoryArgs
  }

  // Custom InputTypes
  /**
   * ExpenseCountOutputType without action
   */
  export type ExpenseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCountOutputType
     */
    select?: ExpenseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseCountOutputType without action
   */
  export type ExpenseCountOutputTypeCountExpenseCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    user: number
    order: number
    product: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LocationCountOutputTypeCountUserArgs
    order?: boolean | LocationCountOutputTypeCountOrderArgs
    product?: boolean | LocationCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    orderItems: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | OrderCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    featuredBrands: number
    cartItems: number
    productVariation: number
    productCategory: number
    inventoryItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    featuredBrands?: boolean | ProductCountOutputTypeCountFeaturedBrandsArgs
    cartItems?: boolean | ProductCountOutputTypeCountCartItemsArgs
    productVariation?: boolean | ProductCountOutputTypeCountProductVariationArgs
    productCategory?: boolean | ProductCountOutputTypeCountProductCategoryArgs
    inventoryItems?: boolean | ProductCountOutputTypeCountInventoryItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountFeaturedBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedBrandsWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductVariationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariationWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    product: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductCategoryCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCollectionCountOutputType
   */

  export type ProductCollectionCountOutputType = {
    products: number
  }

  export type ProductCollectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductCollectionCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCollectionCountOutputType without action
   */
  export type ProductCollectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollectionCountOutputType
     */
    select?: ProductCollectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCollectionCountOutputType without action
   */
  export type ProductCollectionCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductVariationCountOutputType
   */

  export type ProductVariationCountOutputType = {
    options: number
  }

  export type ProductVariationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | ProductVariationCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * ProductVariationCountOutputType without action
   */
  export type ProductVariationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationCountOutputType
     */
    select?: ProductVariationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductVariationCountOutputType without action
   */
  export type ProductVariationCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariationOptionWhereInput
  }


  /**
   * Count Type ProductVariantCountOutputType
   */

  export type ProductVariantCountOutputType = {
    values: number
  }

  export type ProductVariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | ProductVariantCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantCountOutputType
     */
    select?: ProductVariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantValueWhereInput
  }


  /**
   * Count Type ProductVariantValueCountOutputType
   */

  export type ProductVariantValueCountOutputType = {
    options: number
  }

  export type ProductVariantValueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | ProductVariantValueCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * ProductVariantValueCountOutputType without action
   */
  export type ProductVariantValueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValueCountOutputType
     */
    select?: ProductVariantValueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductVariantValueCountOutputType without action
   */
  export type ProductVariantValueCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariationOptionWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    purchase: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | SupplierCountOutputTypeCountPurchaseArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }


  /**
   * Count Type PurchaseCountOutputType
   */

  export type PurchaseCountOutputType = {
    products: number
  }

  export type PurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | PurchaseCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseCountOutputType
     */
    select?: PurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    members: number
    invitations: number
    sessions: number
    accounts: number
    POS: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | UserCountOutputTypeCountMembersArgs
    invitations?: boolean | UserCountOutputTypeCountInvitationsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    POS?: boolean | UserCountOutputTypeCountPOSArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPOSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    members: number
    invitations: number
    location: number
    order: number
    customer: number
    customerGroups: number
    expense: number
    invoice: number
    product: number
    supplier: number
    purchase: number
    settlements: number
    transaction: number
    warehouse: number
    ShippingMethod: number
    ShippingZone: number
    productCategory: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | OrganizationCountOutputTypeCountMembersArgs
    invitations?: boolean | OrganizationCountOutputTypeCountInvitationsArgs
    location?: boolean | OrganizationCountOutputTypeCountLocationArgs
    order?: boolean | OrganizationCountOutputTypeCountOrderArgs
    customer?: boolean | OrganizationCountOutputTypeCountCustomerArgs
    customerGroups?: boolean | OrganizationCountOutputTypeCountCustomerGroupsArgs
    expense?: boolean | OrganizationCountOutputTypeCountExpenseArgs
    invoice?: boolean | OrganizationCountOutputTypeCountInvoiceArgs
    product?: boolean | OrganizationCountOutputTypeCountProductArgs
    supplier?: boolean | OrganizationCountOutputTypeCountSupplierArgs
    purchase?: boolean | OrganizationCountOutputTypeCountPurchaseArgs
    settlements?: boolean | OrganizationCountOutputTypeCountSettlementsArgs
    transaction?: boolean | OrganizationCountOutputTypeCountTransactionArgs
    warehouse?: boolean | OrganizationCountOutputTypeCountWarehouseArgs
    ShippingMethod?: boolean | OrganizationCountOutputTypeCountShippingMethodArgs
    ShippingZone?: boolean | OrganizationCountOutputTypeCountShippingZoneArgs
    productCategory?: boolean | OrganizationCountOutputTypeCountProductCategoryArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountCustomerGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerGroupsWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSettlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettlementWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountShippingMethodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingMethodWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountShippingZoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingZoneWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountProductCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }


  /**
   * Count Type ShippingCountOutputType
   */

  export type ShippingCountOutputType = {
    auditLogs: number
  }

  export type ShippingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | ShippingCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * ShippingCountOutputType without action
   */
  export type ShippingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingCountOutputType
     */
    select?: ShippingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShippingCountOutputType without action
   */
  export type ShippingCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingAuditWhereInput
  }


  /**
   * Count Type ShippingMethodCountOutputType
   */

  export type ShippingMethodCountOutputType = {
    shippingZones: number
    Shipping: number
  }

  export type ShippingMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shippingZones?: boolean | ShippingMethodCountOutputTypeCountShippingZonesArgs
    Shipping?: boolean | ShippingMethodCountOutputTypeCountShippingArgs
  }

  // Custom InputTypes
  /**
   * ShippingMethodCountOutputType without action
   */
  export type ShippingMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethodCountOutputType
     */
    select?: ShippingMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShippingMethodCountOutputType without action
   */
  export type ShippingMethodCountOutputTypeCountShippingZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingZoneWhereInput
  }

  /**
   * ShippingMethodCountOutputType without action
   */
  export type ShippingMethodCountOutputTypeCountShippingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingWhereInput
  }


  /**
   * Count Type ShippingZoneCountOutputType
   */

  export type ShippingZoneCountOutputType = {
    shippingMethods: number
  }

  export type ShippingZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shippingMethods?: boolean | ShippingZoneCountOutputTypeCountShippingMethodsArgs
  }

  // Custom InputTypes
  /**
   * ShippingZoneCountOutputType without action
   */
  export type ShippingZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZoneCountOutputType
     */
    select?: ShippingZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShippingZoneCountOutputType without action
   */
  export type ShippingZoneCountOutputTypeCountShippingMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingMethodWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    inventory: number
    inventoryItems: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | WarehouseCountOutputTypeCountInventoryArgs
    inventoryItems?: boolean | WarehouseCountOutputTypeCountInventoryItemsArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type CartSumAggregateOutputType = {
    totalAmount: number | null
  }

  export type CartMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    customerId: string | null
    orderId: string | null
    totalAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    customerId: string | null
    orderId: string | null
    totalAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    storeId: number
    customerId: number
    orderId: number
    totalAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartAvgAggregateInputType = {
    totalAmount?: true
  }

  export type CartSumAggregateInputType = {
    totalAmount?: true
  }

  export type CartMinAggregateInputType = {
    id?: true
    storeId?: true
    customerId?: true
    orderId?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    storeId?: true
    customerId?: true
    orderId?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    storeId?: true
    customerId?: true
    orderId?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _avg?: CartAvgAggregateInputType
    _sum?: CartSumAggregateInputType
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: string
    storeId: string
    customerId: string
    orderId: string
    totalAmount: number
    createdAt: Date
    updatedAt: Date
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    customerId?: boolean
    orderId?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cartItems?: boolean | Cart$cartItemsArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    customerId?: boolean
    orderId?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    customerId?: boolean
    orderId?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectScalar = {
    id?: boolean
    storeId?: boolean
    customerId?: boolean
    orderId?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeId" | "customerId" | "orderId" | "totalAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["cart"]>
  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItems?: boolean | Cart$cartItemsArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      cartItems: Prisma.$CartItemPayload<ExtArgs>[]
      order: Prisma.$OrderPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      customerId: string
      orderId: string
      totalAmount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartCreateManyAndReturnArgs>(args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {CartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartUpdateManyAndReturnArgs>(args: SelectSubset<T, CartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cartItems<T extends Cart$cartItemsArgs<ExtArgs> = {}>(args?: Subset<T, Cart$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", 'String'>
    readonly storeId: FieldRef<"Cart", 'String'>
    readonly customerId: FieldRef<"Cart", 'String'>
    readonly orderId: FieldRef<"Cart", 'String'>
    readonly totalAmount: FieldRef<"Cart", 'Float'>
    readonly createdAt: FieldRef<"Cart", 'DateTime'>
    readonly updatedAt: FieldRef<"Cart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart createManyAndReturn
   */
  export type CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
  }

  /**
   * Cart updateManyAndReturn
   */
  export type CartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to delete.
     */
    limit?: number
  }

  /**
   * Cart.cartItems
   */
  export type Cart$cartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  export type CartItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type CartItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type CartItemMinAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemMaxAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemCountAggregateOutputType = {
    id: number
    cartId: number
    productId: number
    quantity: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type CartItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type CartItemMinAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemMaxAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemCountAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemMaxAggregateInputType
  }

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>
  }




  export type CartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithAggregationInput | CartItemOrderByWithAggregationInput[]
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum
    having?: CartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemCountAggregateInputType | true
    _avg?: CartItemAvgAggregateInputType
    _sum?: CartItemSumAggregateInputType
    _min?: CartItemMinAggregateInputType
    _max?: CartItemMaxAggregateInputType
  }

  export type CartItemGroupByOutputType = {
    id: string
    cartId: string
    productId: string
    quantity: number
    price: number
    createdAt: Date
    updatedAt: Date
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>
        }
      >
    >


  export type CartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectScalar = {
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cartId" | "productId" | "quantity" | "price" | "createdAt" | "updatedAt", ExtArgs["result"]["cartItem"]>
  export type CartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItem"
    objects: {
      cart: Prisma.$CartPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cartId: string
      productId: string
      quantity: number
      price: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cartItem"]>
    composites: {}
  }

  type CartItemGetPayload<S extends boolean | null | undefined | CartItemDefaultArgs> = $Result.GetResult<Prisma.$CartItemPayload, S>

  type CartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemCountAggregateInputType | true
    }

  export interface CartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItem'], meta: { name: 'CartItem' } }
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemFindManyArgs>(args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     * 
     */
    create<T extends CartItemCreateArgs>(args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemCreateManyArgs>(args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CartItems and returns the data saved in the database.
     * @param {CartItemCreateManyAndReturnArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CartItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     * 
     */
    delete<T extends CartItemDeleteArgs>(args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemUpdateArgs>(args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemDeleteManyArgs>(args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemUpdateManyArgs>(args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems and returns the data updated in the database.
     * @param {CartItemUpdateManyAndReturnArgs} args - Arguments to update many CartItems.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CartItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemAggregateArgs>(args: Subset<T, CartItemAggregateArgs>): Prisma.PrismaPromise<GetCartItemAggregateType<T>>

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs['orderBy'] }
        : { orderBy?: CartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItem model
   */
  readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItem model
   */
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", 'String'>
    readonly cartId: FieldRef<"CartItem", 'String'>
    readonly productId: FieldRef<"CartItem", 'String'>
    readonly quantity: FieldRef<"CartItem", 'Int'>
    readonly price: FieldRef<"CartItem", 'Float'>
    readonly createdAt: FieldRef<"CartItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CartItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
  }

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItem createManyAndReturn
   */
  export type CartItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
  }

  /**
   * CartItem updateManyAndReturn
   */
  export type CartItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
  }

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number
  }

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phoneNumber: string | null
    avatar: string | null
    isGuest: boolean | null
    customerType: $Enums.CustomerType | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phoneNumber: string | null
    avatar: string | null
    isGuest: boolean | null
    customerType: $Enums.CustomerType | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phoneNumber: number
    avatar: number
    isGuest: number
    customerType: number
    storeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phoneNumber?: true
    avatar?: true
    isGuest?: true
    customerType?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phoneNumber?: true
    avatar?: true
    isGuest?: true
    customerType?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phoneNumber?: true
    avatar?: true
    isGuest?: true
    customerType?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    email: string | null
    phoneNumber: string | null
    avatar: string | null
    isGuest: boolean
    customerType: $Enums.CustomerType
    storeId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    avatar?: boolean
    isGuest?: boolean
    customerType?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    carts?: boolean | Customer$cartsArgs<ExtArgs>
    purchaseHistory?: boolean | Customer$purchaseHistoryArgs<ExtArgs>
    pos?: boolean | Customer$posArgs<ExtArgs>
    customerGroupMember?: boolean | Customer$customerGroupMemberArgs<ExtArgs>
    store?: boolean | Customer$storeArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    avatar?: boolean
    isGuest?: boolean
    customerType?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | Customer$storeArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    avatar?: boolean
    isGuest?: boolean
    customerType?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | Customer$storeArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    avatar?: boolean
    isGuest?: boolean
    customerType?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phoneNumber" | "avatar" | "isGuest" | "customerType" | "storeId" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    carts?: boolean | Customer$cartsArgs<ExtArgs>
    purchaseHistory?: boolean | Customer$purchaseHistoryArgs<ExtArgs>
    pos?: boolean | Customer$posArgs<ExtArgs>
    customerGroupMember?: boolean | Customer$customerGroupMemberArgs<ExtArgs>
    store?: boolean | Customer$storeArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | Customer$storeArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | Customer$storeArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      carts: Prisma.$CartPayload<ExtArgs>[]
      purchaseHistory: Prisma.$PurchaseHistoryPayload<ExtArgs>[]
      pos: Prisma.$POSPayload<ExtArgs>[]
      customerGroupMember: Prisma.$CustomerGroupMemberPayload<ExtArgs>[]
      store: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      phoneNumber: string | null
      avatar: string | null
      isGuest: boolean
      customerType: $Enums.CustomerType
      storeId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    carts<T extends Customer$cartsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$cartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseHistory<T extends Customer$purchaseHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Customer$purchaseHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pos<T extends Customer$posArgs<ExtArgs> = {}>(args?: Subset<T, Customer$posArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerGroupMember<T extends Customer$customerGroupMemberArgs<ExtArgs> = {}>(args?: Subset<T, Customer$customerGroupMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    store<T extends Customer$storeArgs<ExtArgs> = {}>(args?: Subset<T, Customer$storeArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phoneNumber: FieldRef<"Customer", 'String'>
    readonly avatar: FieldRef<"Customer", 'String'>
    readonly isGuest: FieldRef<"Customer", 'Boolean'>
    readonly customerType: FieldRef<"Customer", 'CustomerType'>
    readonly storeId: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.carts
   */
  export type Customer$cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    cursor?: CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Customer.purchaseHistory
   */
  export type Customer$purchaseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    where?: PurchaseHistoryWhereInput
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    cursor?: PurchaseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * Customer.pos
   */
  export type Customer$posArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
    where?: POSWhereInput
    orderBy?: POSOrderByWithRelationInput | POSOrderByWithRelationInput[]
    cursor?: POSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSScalarFieldEnum | POSScalarFieldEnum[]
  }

  /**
   * Customer.customerGroupMember
   */
  export type Customer$customerGroupMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberInclude<ExtArgs> | null
    where?: CustomerGroupMemberWhereInput
    orderBy?: CustomerGroupMemberOrderByWithRelationInput | CustomerGroupMemberOrderByWithRelationInput[]
    cursor?: CustomerGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerGroupMemberScalarFieldEnum | CustomerGroupMemberScalarFieldEnum[]
  }

  /**
   * Customer.store
   */
  export type Customer$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseHistory
   */

  export type AggregatePurchaseHistory = {
    _count: PurchaseHistoryCountAggregateOutputType | null
    _avg: PurchaseHistoryAvgAggregateOutputType | null
    _sum: PurchaseHistorySumAggregateOutputType | null
    _min: PurchaseHistoryMinAggregateOutputType | null
    _max: PurchaseHistoryMaxAggregateOutputType | null
  }

  export type PurchaseHistoryAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type PurchaseHistorySumAggregateOutputType = {
    totalAmount: number | null
  }

  export type PurchaseHistoryMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    totalAmount: number | null
    date: Date | null
    customerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseHistoryMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    totalAmount: number | null
    date: Date | null
    customerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseHistoryCountAggregateOutputType = {
    id: number
    orderId: number
    totalAmount: number
    date: number
    customerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseHistoryAvgAggregateInputType = {
    totalAmount?: true
  }

  export type PurchaseHistorySumAggregateInputType = {
    totalAmount?: true
  }

  export type PurchaseHistoryMinAggregateInputType = {
    id?: true
    orderId?: true
    totalAmount?: true
    date?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseHistoryMaxAggregateInputType = {
    id?: true
    orderId?: true
    totalAmount?: true
    date?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseHistoryCountAggregateInputType = {
    id?: true
    orderId?: true
    totalAmount?: true
    date?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseHistory to aggregate.
     */
    where?: PurchaseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseHistories to fetch.
     */
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseHistories
    **/
    _count?: true | PurchaseHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseHistoryMaxAggregateInputType
  }

  export type GetPurchaseHistoryAggregateType<T extends PurchaseHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseHistory[P]>
      : GetScalarType<T[P], AggregatePurchaseHistory[P]>
  }




  export type PurchaseHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseHistoryWhereInput
    orderBy?: PurchaseHistoryOrderByWithAggregationInput | PurchaseHistoryOrderByWithAggregationInput[]
    by: PurchaseHistoryScalarFieldEnum[] | PurchaseHistoryScalarFieldEnum
    having?: PurchaseHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseHistoryCountAggregateInputType | true
    _avg?: PurchaseHistoryAvgAggregateInputType
    _sum?: PurchaseHistorySumAggregateInputType
    _min?: PurchaseHistoryMinAggregateInputType
    _max?: PurchaseHistoryMaxAggregateInputType
  }

  export type PurchaseHistoryGroupByOutputType = {
    id: string
    orderId: string
    totalAmount: number
    date: Date
    customerId: string
    createdAt: Date
    updatedAt: Date
    _count: PurchaseHistoryCountAggregateOutputType | null
    _avg: PurchaseHistoryAvgAggregateOutputType | null
    _sum: PurchaseHistorySumAggregateOutputType | null
    _min: PurchaseHistoryMinAggregateOutputType | null
    _max: PurchaseHistoryMaxAggregateOutputType | null
  }

  type GetPurchaseHistoryGroupByPayload<T extends PurchaseHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    totalAmount?: boolean
    date?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseHistory"]>

  export type PurchaseHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    totalAmount?: boolean
    date?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseHistory"]>

  export type PurchaseHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    totalAmount?: boolean
    date?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseHistory"]>

  export type PurchaseHistorySelectScalar = {
    id?: boolean
    orderId?: boolean
    totalAmount?: boolean
    date?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "totalAmount" | "date" | "customerId" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseHistory"]>
  export type PurchaseHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type PurchaseHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type PurchaseHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $PurchaseHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseHistory"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      totalAmount: number
      date: Date
      customerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseHistory"]>
    composites: {}
  }

  type PurchaseHistoryGetPayload<S extends boolean | null | undefined | PurchaseHistoryDefaultArgs> = $Result.GetResult<Prisma.$PurchaseHistoryPayload, S>

  type PurchaseHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseHistoryCountAggregateInputType | true
    }

  export interface PurchaseHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseHistory'], meta: { name: 'PurchaseHistory' } }
    /**
     * Find zero or one PurchaseHistory that matches the filter.
     * @param {PurchaseHistoryFindUniqueArgs} args - Arguments to find a PurchaseHistory
     * @example
     * // Get one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseHistoryFindUniqueArgs>(args: SelectSubset<T, PurchaseHistoryFindUniqueArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseHistoryFindUniqueOrThrowArgs} args - Arguments to find a PurchaseHistory
     * @example
     * // Get one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryFindFirstArgs} args - Arguments to find a PurchaseHistory
     * @example
     * // Get one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseHistoryFindFirstArgs>(args?: SelectSubset<T, PurchaseHistoryFindFirstArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryFindFirstOrThrowArgs} args - Arguments to find a PurchaseHistory
     * @example
     * // Get one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseHistories
     * const purchaseHistories = await prisma.purchaseHistory.findMany()
     * 
     * // Get first 10 PurchaseHistories
     * const purchaseHistories = await prisma.purchaseHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseHistoryWithIdOnly = await prisma.purchaseHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseHistoryFindManyArgs>(args?: SelectSubset<T, PurchaseHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseHistory.
     * @param {PurchaseHistoryCreateArgs} args - Arguments to create a PurchaseHistory.
     * @example
     * // Create one PurchaseHistory
     * const PurchaseHistory = await prisma.purchaseHistory.create({
     *   data: {
     *     // ... data to create a PurchaseHistory
     *   }
     * })
     * 
     */
    create<T extends PurchaseHistoryCreateArgs>(args: SelectSubset<T, PurchaseHistoryCreateArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseHistories.
     * @param {PurchaseHistoryCreateManyArgs} args - Arguments to create many PurchaseHistories.
     * @example
     * // Create many PurchaseHistories
     * const purchaseHistory = await prisma.purchaseHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseHistoryCreateManyArgs>(args?: SelectSubset<T, PurchaseHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseHistories and returns the data saved in the database.
     * @param {PurchaseHistoryCreateManyAndReturnArgs} args - Arguments to create many PurchaseHistories.
     * @example
     * // Create many PurchaseHistories
     * const purchaseHistory = await prisma.purchaseHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseHistories and only return the `id`
     * const purchaseHistoryWithIdOnly = await prisma.purchaseHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseHistory.
     * @param {PurchaseHistoryDeleteArgs} args - Arguments to delete one PurchaseHistory.
     * @example
     * // Delete one PurchaseHistory
     * const PurchaseHistory = await prisma.purchaseHistory.delete({
     *   where: {
     *     // ... filter to delete one PurchaseHistory
     *   }
     * })
     * 
     */
    delete<T extends PurchaseHistoryDeleteArgs>(args: SelectSubset<T, PurchaseHistoryDeleteArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseHistory.
     * @param {PurchaseHistoryUpdateArgs} args - Arguments to update one PurchaseHistory.
     * @example
     * // Update one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseHistoryUpdateArgs>(args: SelectSubset<T, PurchaseHistoryUpdateArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseHistories.
     * @param {PurchaseHistoryDeleteManyArgs} args - Arguments to filter PurchaseHistories to delete.
     * @example
     * // Delete a few PurchaseHistories
     * const { count } = await prisma.purchaseHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseHistoryDeleteManyArgs>(args?: SelectSubset<T, PurchaseHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseHistories
     * const purchaseHistory = await prisma.purchaseHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseHistoryUpdateManyArgs>(args: SelectSubset<T, PurchaseHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseHistories and returns the data updated in the database.
     * @param {PurchaseHistoryUpdateManyAndReturnArgs} args - Arguments to update many PurchaseHistories.
     * @example
     * // Update many PurchaseHistories
     * const purchaseHistory = await prisma.purchaseHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseHistories and only return the `id`
     * const purchaseHistoryWithIdOnly = await prisma.purchaseHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseHistory.
     * @param {PurchaseHistoryUpsertArgs} args - Arguments to update or create a PurchaseHistory.
     * @example
     * // Update or create a PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.upsert({
     *   create: {
     *     // ... data to create a PurchaseHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseHistory we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseHistoryUpsertArgs>(args: SelectSubset<T, PurchaseHistoryUpsertArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryCountArgs} args - Arguments to filter PurchaseHistories to count.
     * @example
     * // Count the number of PurchaseHistories
     * const count = await prisma.purchaseHistory.count({
     *   where: {
     *     // ... the filter for the PurchaseHistories we want to count
     *   }
     * })
    **/
    count<T extends PurchaseHistoryCountArgs>(
      args?: Subset<T, PurchaseHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseHistoryAggregateArgs>(args: Subset<T, PurchaseHistoryAggregateArgs>): Prisma.PrismaPromise<GetPurchaseHistoryAggregateType<T>>

    /**
     * Group by PurchaseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseHistory model
   */
  readonly fields: PurchaseHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseHistory model
   */
  interface PurchaseHistoryFieldRefs {
    readonly id: FieldRef<"PurchaseHistory", 'String'>
    readonly orderId: FieldRef<"PurchaseHistory", 'String'>
    readonly totalAmount: FieldRef<"PurchaseHistory", 'Float'>
    readonly date: FieldRef<"PurchaseHistory", 'DateTime'>
    readonly customerId: FieldRef<"PurchaseHistory", 'String'>
    readonly createdAt: FieldRef<"PurchaseHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseHistory findUnique
   */
  export type PurchaseHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistory to fetch.
     */
    where: PurchaseHistoryWhereUniqueInput
  }

  /**
   * PurchaseHistory findUniqueOrThrow
   */
  export type PurchaseHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistory to fetch.
     */
    where: PurchaseHistoryWhereUniqueInput
  }

  /**
   * PurchaseHistory findFirst
   */
  export type PurchaseHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistory to fetch.
     */
    where?: PurchaseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseHistories to fetch.
     */
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseHistories.
     */
    cursor?: PurchaseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseHistories.
     */
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * PurchaseHistory findFirstOrThrow
   */
  export type PurchaseHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistory to fetch.
     */
    where?: PurchaseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseHistories to fetch.
     */
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseHistories.
     */
    cursor?: PurchaseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseHistories.
     */
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * PurchaseHistory findMany
   */
  export type PurchaseHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistories to fetch.
     */
    where?: PurchaseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseHistories to fetch.
     */
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseHistories.
     */
    cursor?: PurchaseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseHistories.
     */
    skip?: number
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * PurchaseHistory create
   */
  export type PurchaseHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseHistory.
     */
    data: XOR<PurchaseHistoryCreateInput, PurchaseHistoryUncheckedCreateInput>
  }

  /**
   * PurchaseHistory createMany
   */
  export type PurchaseHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseHistories.
     */
    data: PurchaseHistoryCreateManyInput | PurchaseHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseHistory createManyAndReturn
   */
  export type PurchaseHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseHistories.
     */
    data: PurchaseHistoryCreateManyInput | PurchaseHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseHistory update
   */
  export type PurchaseHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseHistory.
     */
    data: XOR<PurchaseHistoryUpdateInput, PurchaseHistoryUncheckedUpdateInput>
    /**
     * Choose, which PurchaseHistory to update.
     */
    where: PurchaseHistoryWhereUniqueInput
  }

  /**
   * PurchaseHistory updateMany
   */
  export type PurchaseHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseHistories.
     */
    data: XOR<PurchaseHistoryUpdateManyMutationInput, PurchaseHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseHistories to update
     */
    where?: PurchaseHistoryWhereInput
    /**
     * Limit how many PurchaseHistories to update.
     */
    limit?: number
  }

  /**
   * PurchaseHistory updateManyAndReturn
   */
  export type PurchaseHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseHistories.
     */
    data: XOR<PurchaseHistoryUpdateManyMutationInput, PurchaseHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseHistories to update
     */
    where?: PurchaseHistoryWhereInput
    /**
     * Limit how many PurchaseHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseHistory upsert
   */
  export type PurchaseHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseHistory to update in case it exists.
     */
    where: PurchaseHistoryWhereUniqueInput
    /**
     * In case the PurchaseHistory found by the `where` argument doesn't exist, create a new PurchaseHistory with this data.
     */
    create: XOR<PurchaseHistoryCreateInput, PurchaseHistoryUncheckedCreateInput>
    /**
     * In case the PurchaseHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseHistoryUpdateInput, PurchaseHistoryUncheckedUpdateInput>
  }

  /**
   * PurchaseHistory delete
   */
  export type PurchaseHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter which PurchaseHistory to delete.
     */
    where: PurchaseHistoryWhereUniqueInput
  }

  /**
   * PurchaseHistory deleteMany
   */
  export type PurchaseHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseHistories to delete
     */
    where?: PurchaseHistoryWhereInput
    /**
     * Limit how many PurchaseHistories to delete.
     */
    limit?: number
  }

  /**
   * PurchaseHistory without action
   */
  export type PurchaseHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseHistory
     */
    omit?: PurchaseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
  }


  /**
   * Model CustomerGroups
   */

  export type AggregateCustomerGroups = {
    _count: CustomerGroupsCountAggregateOutputType | null
    _min: CustomerGroupsMinAggregateOutputType | null
    _max: CustomerGroupsMaxAggregateOutputType | null
  }

  export type CustomerGroupsMinAggregateOutputType = {
    id: string | null
    name: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerGroupsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerGroupsCountAggregateOutputType = {
    id: number
    name: number
    storeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerGroupsMinAggregateInputType = {
    id?: true
    name?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerGroupsMaxAggregateInputType = {
    id?: true
    name?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerGroupsCountAggregateInputType = {
    id?: true
    name?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerGroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerGroups to aggregate.
     */
    where?: CustomerGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupsOrderByWithRelationInput | CustomerGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerGroups
    **/
    _count?: true | CustomerGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerGroupsMaxAggregateInputType
  }

  export type GetCustomerGroupsAggregateType<T extends CustomerGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerGroups[P]>
      : GetScalarType<T[P], AggregateCustomerGroups[P]>
  }




  export type CustomerGroupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerGroupsWhereInput
    orderBy?: CustomerGroupsOrderByWithAggregationInput | CustomerGroupsOrderByWithAggregationInput[]
    by: CustomerGroupsScalarFieldEnum[] | CustomerGroupsScalarFieldEnum
    having?: CustomerGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerGroupsCountAggregateInputType | true
    _min?: CustomerGroupsMinAggregateInputType
    _max?: CustomerGroupsMaxAggregateInputType
  }

  export type CustomerGroupsGroupByOutputType = {
    id: string
    name: string
    storeId: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerGroupsCountAggregateOutputType | null
    _min: CustomerGroupsMinAggregateOutputType | null
    _max: CustomerGroupsMaxAggregateOutputType | null
  }

  type GetCustomerGroupsGroupByPayload<T extends CustomerGroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupsGroupByOutputType[P]>
        }
      >
    >


  export type CustomerGroupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    customerGroupMember?: boolean | CustomerGroups$customerGroupMemberArgs<ExtArgs>
    _count?: boolean | CustomerGroupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerGroups"]>

  export type CustomerGroupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerGroups"]>

  export type CustomerGroupsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerGroups"]>

  export type CustomerGroupsSelectScalar = {
    id?: boolean
    name?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerGroupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "storeId" | "createdAt" | "updatedAt", ExtArgs["result"]["customerGroups"]>
  export type CustomerGroupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    customerGroupMember?: boolean | CustomerGroups$customerGroupMemberArgs<ExtArgs>
    _count?: boolean | CustomerGroupsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerGroupsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type CustomerGroupsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $CustomerGroupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerGroups"
    objects: {
      store: Prisma.$OrganizationPayload<ExtArgs>
      customerGroupMember: Prisma.$CustomerGroupMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      storeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerGroups"]>
    composites: {}
  }

  type CustomerGroupsGetPayload<S extends boolean | null | undefined | CustomerGroupsDefaultArgs> = $Result.GetResult<Prisma.$CustomerGroupsPayload, S>

  type CustomerGroupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerGroupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerGroupsCountAggregateInputType | true
    }

  export interface CustomerGroupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerGroups'], meta: { name: 'CustomerGroups' } }
    /**
     * Find zero or one CustomerGroups that matches the filter.
     * @param {CustomerGroupsFindUniqueArgs} args - Arguments to find a CustomerGroups
     * @example
     * // Get one CustomerGroups
     * const customerGroups = await prisma.customerGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerGroupsFindUniqueArgs>(args: SelectSubset<T, CustomerGroupsFindUniqueArgs<ExtArgs>>): Prisma__CustomerGroupsClient<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerGroups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerGroupsFindUniqueOrThrowArgs} args - Arguments to find a CustomerGroups
     * @example
     * // Get one CustomerGroups
     * const customerGroups = await prisma.customerGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerGroupsFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerGroupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerGroupsClient<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupsFindFirstArgs} args - Arguments to find a CustomerGroups
     * @example
     * // Get one CustomerGroups
     * const customerGroups = await prisma.customerGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerGroupsFindFirstArgs>(args?: SelectSubset<T, CustomerGroupsFindFirstArgs<ExtArgs>>): Prisma__CustomerGroupsClient<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerGroups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupsFindFirstOrThrowArgs} args - Arguments to find a CustomerGroups
     * @example
     * // Get one CustomerGroups
     * const customerGroups = await prisma.customerGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerGroupsFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerGroupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerGroupsClient<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerGroups
     * const customerGroups = await prisma.customerGroups.findMany()
     * 
     * // Get first 10 CustomerGroups
     * const customerGroups = await prisma.customerGroups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerGroupsWithIdOnly = await prisma.customerGroups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerGroupsFindManyArgs>(args?: SelectSubset<T, CustomerGroupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerGroups.
     * @param {CustomerGroupsCreateArgs} args - Arguments to create a CustomerGroups.
     * @example
     * // Create one CustomerGroups
     * const CustomerGroups = await prisma.customerGroups.create({
     *   data: {
     *     // ... data to create a CustomerGroups
     *   }
     * })
     * 
     */
    create<T extends CustomerGroupsCreateArgs>(args: SelectSubset<T, CustomerGroupsCreateArgs<ExtArgs>>): Prisma__CustomerGroupsClient<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerGroups.
     * @param {CustomerGroupsCreateManyArgs} args - Arguments to create many CustomerGroups.
     * @example
     * // Create many CustomerGroups
     * const customerGroups = await prisma.customerGroups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerGroupsCreateManyArgs>(args?: SelectSubset<T, CustomerGroupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerGroups and returns the data saved in the database.
     * @param {CustomerGroupsCreateManyAndReturnArgs} args - Arguments to create many CustomerGroups.
     * @example
     * // Create many CustomerGroups
     * const customerGroups = await prisma.customerGroups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerGroups and only return the `id`
     * const customerGroupsWithIdOnly = await prisma.customerGroups.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerGroupsCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerGroupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerGroups.
     * @param {CustomerGroupsDeleteArgs} args - Arguments to delete one CustomerGroups.
     * @example
     * // Delete one CustomerGroups
     * const CustomerGroups = await prisma.customerGroups.delete({
     *   where: {
     *     // ... filter to delete one CustomerGroups
     *   }
     * })
     * 
     */
    delete<T extends CustomerGroupsDeleteArgs>(args: SelectSubset<T, CustomerGroupsDeleteArgs<ExtArgs>>): Prisma__CustomerGroupsClient<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerGroups.
     * @param {CustomerGroupsUpdateArgs} args - Arguments to update one CustomerGroups.
     * @example
     * // Update one CustomerGroups
     * const customerGroups = await prisma.customerGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerGroupsUpdateArgs>(args: SelectSubset<T, CustomerGroupsUpdateArgs<ExtArgs>>): Prisma__CustomerGroupsClient<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerGroups.
     * @param {CustomerGroupsDeleteManyArgs} args - Arguments to filter CustomerGroups to delete.
     * @example
     * // Delete a few CustomerGroups
     * const { count } = await prisma.customerGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerGroupsDeleteManyArgs>(args?: SelectSubset<T, CustomerGroupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerGroups
     * const customerGroups = await prisma.customerGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerGroupsUpdateManyArgs>(args: SelectSubset<T, CustomerGroupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerGroups and returns the data updated in the database.
     * @param {CustomerGroupsUpdateManyAndReturnArgs} args - Arguments to update many CustomerGroups.
     * @example
     * // Update many CustomerGroups
     * const customerGroups = await prisma.customerGroups.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerGroups and only return the `id`
     * const customerGroupsWithIdOnly = await prisma.customerGroups.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerGroupsUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerGroupsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerGroups.
     * @param {CustomerGroupsUpsertArgs} args - Arguments to update or create a CustomerGroups.
     * @example
     * // Update or create a CustomerGroups
     * const customerGroups = await prisma.customerGroups.upsert({
     *   create: {
     *     // ... data to create a CustomerGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerGroups we want to update
     *   }
     * })
     */
    upsert<T extends CustomerGroupsUpsertArgs>(args: SelectSubset<T, CustomerGroupsUpsertArgs<ExtArgs>>): Prisma__CustomerGroupsClient<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupsCountArgs} args - Arguments to filter CustomerGroups to count.
     * @example
     * // Count the number of CustomerGroups
     * const count = await prisma.customerGroups.count({
     *   where: {
     *     // ... the filter for the CustomerGroups we want to count
     *   }
     * })
    **/
    count<T extends CustomerGroupsCountArgs>(
      args?: Subset<T, CustomerGroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerGroupsAggregateArgs>(args: Subset<T, CustomerGroupsAggregateArgs>): Prisma.PrismaPromise<GetCustomerGroupsAggregateType<T>>

    /**
     * Group by CustomerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupsGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerGroups model
   */
  readonly fields: CustomerGroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerGroupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customerGroupMember<T extends CustomerGroups$customerGroupMemberArgs<ExtArgs> = {}>(args?: Subset<T, CustomerGroups$customerGroupMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerGroups model
   */
  interface CustomerGroupsFieldRefs {
    readonly id: FieldRef<"CustomerGroups", 'String'>
    readonly name: FieldRef<"CustomerGroups", 'String'>
    readonly storeId: FieldRef<"CustomerGroups", 'String'>
    readonly createdAt: FieldRef<"CustomerGroups", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerGroups", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerGroups findUnique
   */
  export type CustomerGroupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroups to fetch.
     */
    where: CustomerGroupsWhereUniqueInput
  }

  /**
   * CustomerGroups findUniqueOrThrow
   */
  export type CustomerGroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroups to fetch.
     */
    where: CustomerGroupsWhereUniqueInput
  }

  /**
   * CustomerGroups findFirst
   */
  export type CustomerGroupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroups to fetch.
     */
    where?: CustomerGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupsOrderByWithRelationInput | CustomerGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerGroups.
     */
    cursor?: CustomerGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerGroups.
     */
    distinct?: CustomerGroupsScalarFieldEnum | CustomerGroupsScalarFieldEnum[]
  }

  /**
   * CustomerGroups findFirstOrThrow
   */
  export type CustomerGroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroups to fetch.
     */
    where?: CustomerGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupsOrderByWithRelationInput | CustomerGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerGroups.
     */
    cursor?: CustomerGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerGroups.
     */
    distinct?: CustomerGroupsScalarFieldEnum | CustomerGroupsScalarFieldEnum[]
  }

  /**
   * CustomerGroups findMany
   */
  export type CustomerGroupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroups to fetch.
     */
    where?: CustomerGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupsOrderByWithRelationInput | CustomerGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerGroups.
     */
    cursor?: CustomerGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    distinct?: CustomerGroupsScalarFieldEnum | CustomerGroupsScalarFieldEnum[]
  }

  /**
   * CustomerGroups create
   */
  export type CustomerGroupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerGroups.
     */
    data: XOR<CustomerGroupsCreateInput, CustomerGroupsUncheckedCreateInput>
  }

  /**
   * CustomerGroups createMany
   */
  export type CustomerGroupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerGroups.
     */
    data: CustomerGroupsCreateManyInput | CustomerGroupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerGroups createManyAndReturn
   */
  export type CustomerGroupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerGroups.
     */
    data: CustomerGroupsCreateManyInput | CustomerGroupsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerGroups update
   */
  export type CustomerGroupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerGroups.
     */
    data: XOR<CustomerGroupsUpdateInput, CustomerGroupsUncheckedUpdateInput>
    /**
     * Choose, which CustomerGroups to update.
     */
    where: CustomerGroupsWhereUniqueInput
  }

  /**
   * CustomerGroups updateMany
   */
  export type CustomerGroupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerGroups.
     */
    data: XOR<CustomerGroupsUpdateManyMutationInput, CustomerGroupsUncheckedUpdateManyInput>
    /**
     * Filter which CustomerGroups to update
     */
    where?: CustomerGroupsWhereInput
    /**
     * Limit how many CustomerGroups to update.
     */
    limit?: number
  }

  /**
   * CustomerGroups updateManyAndReturn
   */
  export type CustomerGroupsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * The data used to update CustomerGroups.
     */
    data: XOR<CustomerGroupsUpdateManyMutationInput, CustomerGroupsUncheckedUpdateManyInput>
    /**
     * Filter which CustomerGroups to update
     */
    where?: CustomerGroupsWhereInput
    /**
     * Limit how many CustomerGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerGroups upsert
   */
  export type CustomerGroupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerGroups to update in case it exists.
     */
    where: CustomerGroupsWhereUniqueInput
    /**
     * In case the CustomerGroups found by the `where` argument doesn't exist, create a new CustomerGroups with this data.
     */
    create: XOR<CustomerGroupsCreateInput, CustomerGroupsUncheckedCreateInput>
    /**
     * In case the CustomerGroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerGroupsUpdateInput, CustomerGroupsUncheckedUpdateInput>
  }

  /**
   * CustomerGroups delete
   */
  export type CustomerGroupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsInclude<ExtArgs> | null
    /**
     * Filter which CustomerGroups to delete.
     */
    where: CustomerGroupsWhereUniqueInput
  }

  /**
   * CustomerGroups deleteMany
   */
  export type CustomerGroupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerGroups to delete
     */
    where?: CustomerGroupsWhereInput
    /**
     * Limit how many CustomerGroups to delete.
     */
    limit?: number
  }

  /**
   * CustomerGroups.customerGroupMember
   */
  export type CustomerGroups$customerGroupMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberInclude<ExtArgs> | null
    where?: CustomerGroupMemberWhereInput
    orderBy?: CustomerGroupMemberOrderByWithRelationInput | CustomerGroupMemberOrderByWithRelationInput[]
    cursor?: CustomerGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerGroupMemberScalarFieldEnum | CustomerGroupMemberScalarFieldEnum[]
  }

  /**
   * CustomerGroups without action
   */
  export type CustomerGroupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsInclude<ExtArgs> | null
  }


  /**
   * Model CustomerGroupMember
   */

  export type AggregateCustomerGroupMember = {
    _count: CustomerGroupMemberCountAggregateOutputType | null
    _min: CustomerGroupMemberMinAggregateOutputType | null
    _max: CustomerGroupMemberMaxAggregateOutputType | null
  }

  export type CustomerGroupMemberMinAggregateOutputType = {
    customerId: string | null
    customerGroupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerGroupMemberMaxAggregateOutputType = {
    customerId: string | null
    customerGroupId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerGroupMemberCountAggregateOutputType = {
    customerId: number
    customerGroupId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerGroupMemberMinAggregateInputType = {
    customerId?: true
    customerGroupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerGroupMemberMaxAggregateInputType = {
    customerId?: true
    customerGroupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerGroupMemberCountAggregateInputType = {
    customerId?: true
    customerGroupId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerGroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerGroupMember to aggregate.
     */
    where?: CustomerGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroupMembers to fetch.
     */
    orderBy?: CustomerGroupMemberOrderByWithRelationInput | CustomerGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerGroupMembers
    **/
    _count?: true | CustomerGroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerGroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerGroupMemberMaxAggregateInputType
  }

  export type GetCustomerGroupMemberAggregateType<T extends CustomerGroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerGroupMember[P]>
      : GetScalarType<T[P], AggregateCustomerGroupMember[P]>
  }




  export type CustomerGroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerGroupMemberWhereInput
    orderBy?: CustomerGroupMemberOrderByWithAggregationInput | CustomerGroupMemberOrderByWithAggregationInput[]
    by: CustomerGroupMemberScalarFieldEnum[] | CustomerGroupMemberScalarFieldEnum
    having?: CustomerGroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerGroupMemberCountAggregateInputType | true
    _min?: CustomerGroupMemberMinAggregateInputType
    _max?: CustomerGroupMemberMaxAggregateInputType
  }

  export type CustomerGroupMemberGroupByOutputType = {
    customerId: string
    customerGroupId: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerGroupMemberCountAggregateOutputType | null
    _min: CustomerGroupMemberMinAggregateOutputType | null
    _max: CustomerGroupMemberMaxAggregateOutputType | null
  }

  type GetCustomerGroupMemberGroupByPayload<T extends CustomerGroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type CustomerGroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerId?: boolean
    customerGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerGroup?: boolean | CustomerGroupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerGroupMember"]>

  export type CustomerGroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerId?: boolean
    customerGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerGroup?: boolean | CustomerGroupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerGroupMember"]>

  export type CustomerGroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerId?: boolean
    customerGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerGroup?: boolean | CustomerGroupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerGroupMember"]>

  export type CustomerGroupMemberSelectScalar = {
    customerId?: boolean
    customerGroupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerGroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"customerId" | "customerGroupId" | "createdAt" | "updatedAt", ExtArgs["result"]["customerGroupMember"]>
  export type CustomerGroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerGroup?: boolean | CustomerGroupsDefaultArgs<ExtArgs>
  }
  export type CustomerGroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerGroup?: boolean | CustomerGroupsDefaultArgs<ExtArgs>
  }
  export type CustomerGroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    customerGroup?: boolean | CustomerGroupsDefaultArgs<ExtArgs>
  }

  export type $CustomerGroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerGroupMember"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      customerGroup: Prisma.$CustomerGroupsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      customerId: string
      customerGroupId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerGroupMember"]>
    composites: {}
  }

  type CustomerGroupMemberGetPayload<S extends boolean | null | undefined | CustomerGroupMemberDefaultArgs> = $Result.GetResult<Prisma.$CustomerGroupMemberPayload, S>

  type CustomerGroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerGroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerGroupMemberCountAggregateInputType | true
    }

  export interface CustomerGroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerGroupMember'], meta: { name: 'CustomerGroupMember' } }
    /**
     * Find zero or one CustomerGroupMember that matches the filter.
     * @param {CustomerGroupMemberFindUniqueArgs} args - Arguments to find a CustomerGroupMember
     * @example
     * // Get one CustomerGroupMember
     * const customerGroupMember = await prisma.customerGroupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerGroupMemberFindUniqueArgs>(args: SelectSubset<T, CustomerGroupMemberFindUniqueArgs<ExtArgs>>): Prisma__CustomerGroupMemberClient<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerGroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerGroupMemberFindUniqueOrThrowArgs} args - Arguments to find a CustomerGroupMember
     * @example
     * // Get one CustomerGroupMember
     * const customerGroupMember = await prisma.customerGroupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerGroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerGroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerGroupMemberClient<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerGroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupMemberFindFirstArgs} args - Arguments to find a CustomerGroupMember
     * @example
     * // Get one CustomerGroupMember
     * const customerGroupMember = await prisma.customerGroupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerGroupMemberFindFirstArgs>(args?: SelectSubset<T, CustomerGroupMemberFindFirstArgs<ExtArgs>>): Prisma__CustomerGroupMemberClient<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerGroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupMemberFindFirstOrThrowArgs} args - Arguments to find a CustomerGroupMember
     * @example
     * // Get one CustomerGroupMember
     * const customerGroupMember = await prisma.customerGroupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerGroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerGroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerGroupMemberClient<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerGroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerGroupMembers
     * const customerGroupMembers = await prisma.customerGroupMember.findMany()
     * 
     * // Get first 10 CustomerGroupMembers
     * const customerGroupMembers = await prisma.customerGroupMember.findMany({ take: 10 })
     * 
     * // Only select the `customerId`
     * const customerGroupMemberWithCustomerIdOnly = await prisma.customerGroupMember.findMany({ select: { customerId: true } })
     * 
     */
    findMany<T extends CustomerGroupMemberFindManyArgs>(args?: SelectSubset<T, CustomerGroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerGroupMember.
     * @param {CustomerGroupMemberCreateArgs} args - Arguments to create a CustomerGroupMember.
     * @example
     * // Create one CustomerGroupMember
     * const CustomerGroupMember = await prisma.customerGroupMember.create({
     *   data: {
     *     // ... data to create a CustomerGroupMember
     *   }
     * })
     * 
     */
    create<T extends CustomerGroupMemberCreateArgs>(args: SelectSubset<T, CustomerGroupMemberCreateArgs<ExtArgs>>): Prisma__CustomerGroupMemberClient<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerGroupMembers.
     * @param {CustomerGroupMemberCreateManyArgs} args - Arguments to create many CustomerGroupMembers.
     * @example
     * // Create many CustomerGroupMembers
     * const customerGroupMember = await prisma.customerGroupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerGroupMemberCreateManyArgs>(args?: SelectSubset<T, CustomerGroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerGroupMembers and returns the data saved in the database.
     * @param {CustomerGroupMemberCreateManyAndReturnArgs} args - Arguments to create many CustomerGroupMembers.
     * @example
     * // Create many CustomerGroupMembers
     * const customerGroupMember = await prisma.customerGroupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerGroupMembers and only return the `customerId`
     * const customerGroupMemberWithCustomerIdOnly = await prisma.customerGroupMember.createManyAndReturn({
     *   select: { customerId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerGroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerGroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerGroupMember.
     * @param {CustomerGroupMemberDeleteArgs} args - Arguments to delete one CustomerGroupMember.
     * @example
     * // Delete one CustomerGroupMember
     * const CustomerGroupMember = await prisma.customerGroupMember.delete({
     *   where: {
     *     // ... filter to delete one CustomerGroupMember
     *   }
     * })
     * 
     */
    delete<T extends CustomerGroupMemberDeleteArgs>(args: SelectSubset<T, CustomerGroupMemberDeleteArgs<ExtArgs>>): Prisma__CustomerGroupMemberClient<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerGroupMember.
     * @param {CustomerGroupMemberUpdateArgs} args - Arguments to update one CustomerGroupMember.
     * @example
     * // Update one CustomerGroupMember
     * const customerGroupMember = await prisma.customerGroupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerGroupMemberUpdateArgs>(args: SelectSubset<T, CustomerGroupMemberUpdateArgs<ExtArgs>>): Prisma__CustomerGroupMemberClient<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerGroupMembers.
     * @param {CustomerGroupMemberDeleteManyArgs} args - Arguments to filter CustomerGroupMembers to delete.
     * @example
     * // Delete a few CustomerGroupMembers
     * const { count } = await prisma.customerGroupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerGroupMemberDeleteManyArgs>(args?: SelectSubset<T, CustomerGroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerGroupMembers
     * const customerGroupMember = await prisma.customerGroupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerGroupMemberUpdateManyArgs>(args: SelectSubset<T, CustomerGroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerGroupMembers and returns the data updated in the database.
     * @param {CustomerGroupMemberUpdateManyAndReturnArgs} args - Arguments to update many CustomerGroupMembers.
     * @example
     * // Update many CustomerGroupMembers
     * const customerGroupMember = await prisma.customerGroupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerGroupMembers and only return the `customerId`
     * const customerGroupMemberWithCustomerIdOnly = await prisma.customerGroupMember.updateManyAndReturn({
     *   select: { customerId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerGroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerGroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerGroupMember.
     * @param {CustomerGroupMemberUpsertArgs} args - Arguments to update or create a CustomerGroupMember.
     * @example
     * // Update or create a CustomerGroupMember
     * const customerGroupMember = await prisma.customerGroupMember.upsert({
     *   create: {
     *     // ... data to create a CustomerGroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerGroupMember we want to update
     *   }
     * })
     */
    upsert<T extends CustomerGroupMemberUpsertArgs>(args: SelectSubset<T, CustomerGroupMemberUpsertArgs<ExtArgs>>): Prisma__CustomerGroupMemberClient<$Result.GetResult<Prisma.$CustomerGroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupMemberCountArgs} args - Arguments to filter CustomerGroupMembers to count.
     * @example
     * // Count the number of CustomerGroupMembers
     * const count = await prisma.customerGroupMember.count({
     *   where: {
     *     // ... the filter for the CustomerGroupMembers we want to count
     *   }
     * })
    **/
    count<T extends CustomerGroupMemberCountArgs>(
      args?: Subset<T, CustomerGroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerGroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerGroupMemberAggregateArgs>(args: Subset<T, CustomerGroupMemberAggregateArgs>): Prisma.PrismaPromise<GetCustomerGroupMemberAggregateType<T>>

    /**
     * Group by CustomerGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerGroupMember model
   */
  readonly fields: CustomerGroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerGroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerGroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customerGroup<T extends CustomerGroupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerGroupsDefaultArgs<ExtArgs>>): Prisma__CustomerGroupsClient<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerGroupMember model
   */
  interface CustomerGroupMemberFieldRefs {
    readonly customerId: FieldRef<"CustomerGroupMember", 'String'>
    readonly customerGroupId: FieldRef<"CustomerGroupMember", 'String'>
    readonly createdAt: FieldRef<"CustomerGroupMember", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerGroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerGroupMember findUnique
   */
  export type CustomerGroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroupMember to fetch.
     */
    where: CustomerGroupMemberWhereUniqueInput
  }

  /**
   * CustomerGroupMember findUniqueOrThrow
   */
  export type CustomerGroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroupMember to fetch.
     */
    where: CustomerGroupMemberWhereUniqueInput
  }

  /**
   * CustomerGroupMember findFirst
   */
  export type CustomerGroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroupMember to fetch.
     */
    where?: CustomerGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroupMembers to fetch.
     */
    orderBy?: CustomerGroupMemberOrderByWithRelationInput | CustomerGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerGroupMembers.
     */
    cursor?: CustomerGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerGroupMembers.
     */
    distinct?: CustomerGroupMemberScalarFieldEnum | CustomerGroupMemberScalarFieldEnum[]
  }

  /**
   * CustomerGroupMember findFirstOrThrow
   */
  export type CustomerGroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroupMember to fetch.
     */
    where?: CustomerGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroupMembers to fetch.
     */
    orderBy?: CustomerGroupMemberOrderByWithRelationInput | CustomerGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerGroupMembers.
     */
    cursor?: CustomerGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerGroupMembers.
     */
    distinct?: CustomerGroupMemberScalarFieldEnum | CustomerGroupMemberScalarFieldEnum[]
  }

  /**
   * CustomerGroupMember findMany
   */
  export type CustomerGroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroupMembers to fetch.
     */
    where?: CustomerGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroupMembers to fetch.
     */
    orderBy?: CustomerGroupMemberOrderByWithRelationInput | CustomerGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerGroupMembers.
     */
    cursor?: CustomerGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroupMembers.
     */
    skip?: number
    distinct?: CustomerGroupMemberScalarFieldEnum | CustomerGroupMemberScalarFieldEnum[]
  }

  /**
   * CustomerGroupMember create
   */
  export type CustomerGroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerGroupMember.
     */
    data: XOR<CustomerGroupMemberCreateInput, CustomerGroupMemberUncheckedCreateInput>
  }

  /**
   * CustomerGroupMember createMany
   */
  export type CustomerGroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerGroupMembers.
     */
    data: CustomerGroupMemberCreateManyInput | CustomerGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerGroupMember createManyAndReturn
   */
  export type CustomerGroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerGroupMembers.
     */
    data: CustomerGroupMemberCreateManyInput | CustomerGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerGroupMember update
   */
  export type CustomerGroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerGroupMember.
     */
    data: XOR<CustomerGroupMemberUpdateInput, CustomerGroupMemberUncheckedUpdateInput>
    /**
     * Choose, which CustomerGroupMember to update.
     */
    where: CustomerGroupMemberWhereUniqueInput
  }

  /**
   * CustomerGroupMember updateMany
   */
  export type CustomerGroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerGroupMembers.
     */
    data: XOR<CustomerGroupMemberUpdateManyMutationInput, CustomerGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which CustomerGroupMembers to update
     */
    where?: CustomerGroupMemberWhereInput
    /**
     * Limit how many CustomerGroupMembers to update.
     */
    limit?: number
  }

  /**
   * CustomerGroupMember updateManyAndReturn
   */
  export type CustomerGroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update CustomerGroupMembers.
     */
    data: XOR<CustomerGroupMemberUpdateManyMutationInput, CustomerGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which CustomerGroupMembers to update
     */
    where?: CustomerGroupMemberWhereInput
    /**
     * Limit how many CustomerGroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerGroupMember upsert
   */
  export type CustomerGroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerGroupMember to update in case it exists.
     */
    where: CustomerGroupMemberWhereUniqueInput
    /**
     * In case the CustomerGroupMember found by the `where` argument doesn't exist, create a new CustomerGroupMember with this data.
     */
    create: XOR<CustomerGroupMemberCreateInput, CustomerGroupMemberUncheckedCreateInput>
    /**
     * In case the CustomerGroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerGroupMemberUpdateInput, CustomerGroupMemberUncheckedUpdateInput>
  }

  /**
   * CustomerGroupMember delete
   */
  export type CustomerGroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberInclude<ExtArgs> | null
    /**
     * Filter which CustomerGroupMember to delete.
     */
    where: CustomerGroupMemberWhereUniqueInput
  }

  /**
   * CustomerGroupMember deleteMany
   */
  export type CustomerGroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerGroupMembers to delete
     */
    where?: CustomerGroupMemberWhereInput
    /**
     * Limit how many CustomerGroupMembers to delete.
     */
    limit?: number
  }

  /**
   * CustomerGroupMember without action
   */
  export type CustomerGroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupMember
     */
    select?: CustomerGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroupMember
     */
    omit?: CustomerGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    name: string | null
    amount: number | null
    description: string | null
    paymentMethod: string | null
    paymentStatus: string | null
    date: Date | null
    locationId: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    amount: number | null
    description: string | null
    paymentMethod: string | null
    paymentStatus: string | null
    date: Date | null
    locationId: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    name: number
    amount: number
    description: number
    paymentMethod: number
    paymentStatus: number
    date: number
    locationId: number
    storeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    description?: true
    paymentMethod?: true
    paymentStatus?: true
    date?: true
    locationId?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    description?: true
    paymentMethod?: true
    paymentStatus?: true
    date?: true
    locationId?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    name?: true
    amount?: true
    description?: true
    paymentMethod?: true
    paymentStatus?: true
    date?: true
    locationId?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    name: string | null
    amount: number | null
    description: string | null
    paymentMethod: string | null
    paymentStatus: string | null
    date: Date | null
    locationId: string
    storeId: string
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    description?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    date?: boolean
    locationId?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expenseCategory?: boolean | Expense$expenseCategoryArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | ExpenseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    description?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    date?: boolean
    locationId?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    amount?: boolean
    description?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    date?: boolean
    locationId?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    name?: boolean
    amount?: boolean
    description?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    date?: boolean
    locationId?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "amount" | "description" | "paymentMethod" | "paymentStatus" | "date" | "locationId" | "storeId" | "createdAt" | "updatedAt", ExtArgs["result"]["expense"]>
  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenseCategory?: boolean | Expense$expenseCategoryArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | ExpenseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      expenseCategory: Prisma.$ExpenseCategoryPayload<ExtArgs>[]
      store: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      amount: number | null
      description: string | null
      paymentMethod: string | null
      paymentStatus: string | null
      date: Date | null
      locationId: string
      storeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expenseCategory<T extends Expense$expenseCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Expense$expenseCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly name: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Float'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly paymentMethod: FieldRef<"Expense", 'String'>
    readonly paymentStatus: FieldRef<"Expense", 'String'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly locationId: FieldRef<"Expense", 'String'>
    readonly storeId: FieldRef<"Expense", 'String'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense.expenseCategory
   */
  export type Expense$expenseCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    cursor?: ExpenseCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseCategory
   */

  export type AggregateExpenseCategory = {
    _count: ExpenseCategoryCountAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  export type ExpenseCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    date: Date | null
    expenseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    date: Date | null
    expenseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    date: number
    expenseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    date?: true
    expenseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    date?: true
    expenseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    date?: true
    expenseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategory to aggregate.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseCategories
    **/
    _count?: true | ExpenseCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type GetExpenseCategoryAggregateType<T extends ExpenseCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseCategory[P]>
      : GetScalarType<T[P], AggregateExpenseCategory[P]>
  }




  export type ExpenseCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithAggregationInput | ExpenseCategoryOrderByWithAggregationInput[]
    by: ExpenseCategoryScalarFieldEnum[] | ExpenseCategoryScalarFieldEnum
    having?: ExpenseCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCategoryCountAggregateInputType | true
    _min?: ExpenseCategoryMinAggregateInputType
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type ExpenseCategoryGroupByOutputType = {
    id: string
    name: string
    description: string
    date: Date
    expenseId: string
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCategoryCountAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  type GetExpenseCategoryGroupByPayload<T extends ExpenseCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    date?: boolean
    expenseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    date?: boolean
    expenseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    date?: boolean
    expenseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    date?: boolean
    expenseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "date" | "expenseId" | "createdAt" | "updatedAt", ExtArgs["result"]["expenseCategory"]>
  export type ExpenseCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
  }
  export type ExpenseCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
  }
  export type ExpenseCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
  }

  export type $ExpenseCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseCategory"
    objects: {
      expense: Prisma.$ExpensePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      date: Date
      expenseId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expenseCategory"]>
    composites: {}
  }

  type ExpenseCategoryGetPayload<S extends boolean | null | undefined | ExpenseCategoryDefaultArgs> = $Result.GetResult<Prisma.$ExpenseCategoryPayload, S>

  type ExpenseCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCategoryCountAggregateInputType | true
    }

  export interface ExpenseCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseCategory'], meta: { name: 'ExpenseCategory' } }
    /**
     * Find zero or one ExpenseCategory that matches the filter.
     * @param {ExpenseCategoryFindUniqueArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseCategoryFindUniqueArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseCategoryFindUniqueOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseCategoryFindFirstArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany()
     * 
     * // Get first 10 ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseCategoryFindManyArgs>(args?: SelectSubset<T, ExpenseCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseCategory.
     * @param {ExpenseCategoryCreateArgs} args - Arguments to create a ExpenseCategory.
     * @example
     * // Create one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.create({
     *   data: {
     *     // ... data to create a ExpenseCategory
     *   }
     * })
     * 
     */
    create<T extends ExpenseCategoryCreateArgs>(args: SelectSubset<T, ExpenseCategoryCreateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseCategories.
     * @param {ExpenseCategoryCreateManyArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCategoryCreateManyArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseCategories and returns the data saved in the database.
     * @param {ExpenseCategoryCreateManyAndReturnArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseCategories and only return the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseCategory.
     * @param {ExpenseCategoryDeleteArgs} args - Arguments to delete one ExpenseCategory.
     * @example
     * // Delete one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.delete({
     *   where: {
     *     // ... filter to delete one ExpenseCategory
     *   }
     * })
     * 
     */
    delete<T extends ExpenseCategoryDeleteArgs>(args: SelectSubset<T, ExpenseCategoryDeleteArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseCategory.
     * @param {ExpenseCategoryUpdateArgs} args - Arguments to update one ExpenseCategory.
     * @example
     * // Update one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseCategoryUpdateArgs>(args: SelectSubset<T, ExpenseCategoryUpdateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseCategories.
     * @param {ExpenseCategoryDeleteManyArgs} args - Arguments to filter ExpenseCategories to delete.
     * @example
     * // Delete a few ExpenseCategories
     * const { count } = await prisma.expenseCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseCategoryDeleteManyArgs>(args?: SelectSubset<T, ExpenseCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseCategoryUpdateManyArgs>(args: SelectSubset<T, ExpenseCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseCategories and returns the data updated in the database.
     * @param {ExpenseCategoryUpdateManyAndReturnArgs} args - Arguments to update many ExpenseCategories.
     * @example
     * // Update many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseCategories and only return the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseCategory.
     * @param {ExpenseCategoryUpsertArgs} args - Arguments to update or create a ExpenseCategory.
     * @example
     * // Update or create a ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.upsert({
     *   create: {
     *     // ... data to create a ExpenseCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseCategory we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseCategoryUpsertArgs>(args: SelectSubset<T, ExpenseCategoryUpsertArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryCountArgs} args - Arguments to filter ExpenseCategories to count.
     * @example
     * // Count the number of ExpenseCategories
     * const count = await prisma.expenseCategory.count({
     *   where: {
     *     // ... the filter for the ExpenseCategories we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCategoryCountArgs>(
      args?: Subset<T, ExpenseCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseCategoryAggregateArgs>(args: Subset<T, ExpenseCategoryAggregateArgs>): Prisma.PrismaPromise<GetExpenseCategoryAggregateType<T>>

    /**
     * Group by ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseCategory model
   */
  readonly fields: ExpenseCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expense<T extends ExpenseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseDefaultArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseCategory model
   */
  interface ExpenseCategoryFieldRefs {
    readonly id: FieldRef<"ExpenseCategory", 'String'>
    readonly name: FieldRef<"ExpenseCategory", 'String'>
    readonly description: FieldRef<"ExpenseCategory", 'String'>
    readonly date: FieldRef<"ExpenseCategory", 'DateTime'>
    readonly expenseId: FieldRef<"ExpenseCategory", 'String'>
    readonly createdAt: FieldRef<"ExpenseCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ExpenseCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseCategory findUnique
   */
  export type ExpenseCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findUniqueOrThrow
   */
  export type ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findFirst
   */
  export type ExpenseCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findFirstOrThrow
   */
  export type ExpenseCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findMany
   */
  export type ExpenseCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategories to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory create
   */
  export type ExpenseCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
  }

  /**
   * ExpenseCategory createMany
   */
  export type ExpenseCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseCategory createManyAndReturn
   */
  export type ExpenseCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseCategory update
   */
  export type ExpenseCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
    /**
     * Choose, which ExpenseCategory to update.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory updateMany
   */
  export type ExpenseCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseCategories.
     */
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseCategories to update
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to update.
     */
    limit?: number
  }

  /**
   * ExpenseCategory updateManyAndReturn
   */
  export type ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseCategories.
     */
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseCategories to update
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseCategory upsert
   */
  export type ExpenseCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseCategory to update in case it exists.
     */
    where: ExpenseCategoryWhereUniqueInput
    /**
     * In case the ExpenseCategory found by the `where` argument doesn't exist, create a new ExpenseCategory with this data.
     */
    create: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
    /**
     * In case the ExpenseCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
  }

  /**
   * ExpenseCategory delete
   */
  export type ExpenseCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter which ExpenseCategory to delete.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory deleteMany
   */
  export type ExpenseCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategories to delete
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to delete.
     */
    limit?: number
  }

  /**
   * ExpenseCategory without action
   */
  export type ExpenseCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
  }


  /**
   * Model FeatureFlag
   */

  export type AggregateFeatureFlag = {
    _count: FeatureFlagCountAggregateOutputType | null
    _avg: FeatureFlagAvgAggregateOutputType | null
    _sum: FeatureFlagSumAggregateOutputType | null
    _min: FeatureFlagMinAggregateOutputType | null
    _max: FeatureFlagMaxAggregateOutputType | null
  }

  export type FeatureFlagAvgAggregateOutputType = {
    rollout: number | null
  }

  export type FeatureFlagSumAggregateOutputType = {
    rollout: number | null
  }

  export type FeatureFlagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    isEnabled: boolean | null
    rollout: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureFlagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    isEnabled: boolean | null
    rollout: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureFlagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    isEnabled: number
    rollout: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureFlagAvgAggregateInputType = {
    rollout?: true
  }

  export type FeatureFlagSumAggregateInputType = {
    rollout?: true
  }

  export type FeatureFlagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    isEnabled?: true
    rollout?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureFlagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    isEnabled?: true
    rollout?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureFlagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    isEnabled?: true
    rollout?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureFlagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureFlag to aggregate.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeatureFlags
    **/
    _count?: true | FeatureFlagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureFlagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureFlagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureFlagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureFlagMaxAggregateInputType
  }

  export type GetFeatureFlagAggregateType<T extends FeatureFlagAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatureFlag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatureFlag[P]>
      : GetScalarType<T[P], AggregateFeatureFlag[P]>
  }




  export type FeatureFlagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureFlagWhereInput
    orderBy?: FeatureFlagOrderByWithAggregationInput | FeatureFlagOrderByWithAggregationInput[]
    by: FeatureFlagScalarFieldEnum[] | FeatureFlagScalarFieldEnum
    having?: FeatureFlagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureFlagCountAggregateInputType | true
    _avg?: FeatureFlagAvgAggregateInputType
    _sum?: FeatureFlagSumAggregateInputType
    _min?: FeatureFlagMinAggregateInputType
    _max?: FeatureFlagMaxAggregateInputType
  }

  export type FeatureFlagGroupByOutputType = {
    id: string
    name: string
    slug: string
    isEnabled: boolean
    rollout: number
    description: string
    createdAt: Date
    updatedAt: Date
    _count: FeatureFlagCountAggregateOutputType | null
    _avg: FeatureFlagAvgAggregateOutputType | null
    _sum: FeatureFlagSumAggregateOutputType | null
    _min: FeatureFlagMinAggregateOutputType | null
    _max: FeatureFlagMaxAggregateOutputType | null
  }

  type GetFeatureFlagGroupByPayload<T extends FeatureFlagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureFlagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureFlagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureFlagGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureFlagGroupByOutputType[P]>
        }
      >
    >


  export type FeatureFlagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    isEnabled?: boolean
    rollout?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featureFlag"]>

  export type FeatureFlagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    isEnabled?: boolean
    rollout?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featureFlag"]>

  export type FeatureFlagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    isEnabled?: boolean
    rollout?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featureFlag"]>

  export type FeatureFlagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    isEnabled?: boolean
    rollout?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeatureFlagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "isEnabled" | "rollout" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["featureFlag"]>

  export type $FeatureFlagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeatureFlag"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      isEnabled: boolean
      rollout: number
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featureFlag"]>
    composites: {}
  }

  type FeatureFlagGetPayload<S extends boolean | null | undefined | FeatureFlagDefaultArgs> = $Result.GetResult<Prisma.$FeatureFlagPayload, S>

  type FeatureFlagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureFlagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureFlagCountAggregateInputType | true
    }

  export interface FeatureFlagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeatureFlag'], meta: { name: 'FeatureFlag' } }
    /**
     * Find zero or one FeatureFlag that matches the filter.
     * @param {FeatureFlagFindUniqueArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureFlagFindUniqueArgs>(args: SelectSubset<T, FeatureFlagFindUniqueArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeatureFlag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureFlagFindUniqueOrThrowArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureFlagFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureFlagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureFlag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagFindFirstArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureFlagFindFirstArgs>(args?: SelectSubset<T, FeatureFlagFindFirstArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeatureFlag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagFindFirstOrThrowArgs} args - Arguments to find a FeatureFlag
     * @example
     * // Get one FeatureFlag
     * const featureFlag = await prisma.featureFlag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureFlagFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureFlagFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeatureFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeatureFlags
     * const featureFlags = await prisma.featureFlag.findMany()
     * 
     * // Get first 10 FeatureFlags
     * const featureFlags = await prisma.featureFlag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureFlagWithIdOnly = await prisma.featureFlag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureFlagFindManyArgs>(args?: SelectSubset<T, FeatureFlagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeatureFlag.
     * @param {FeatureFlagCreateArgs} args - Arguments to create a FeatureFlag.
     * @example
     * // Create one FeatureFlag
     * const FeatureFlag = await prisma.featureFlag.create({
     *   data: {
     *     // ... data to create a FeatureFlag
     *   }
     * })
     * 
     */
    create<T extends FeatureFlagCreateArgs>(args: SelectSubset<T, FeatureFlagCreateArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeatureFlags.
     * @param {FeatureFlagCreateManyArgs} args - Arguments to create many FeatureFlags.
     * @example
     * // Create many FeatureFlags
     * const featureFlag = await prisma.featureFlag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureFlagCreateManyArgs>(args?: SelectSubset<T, FeatureFlagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeatureFlags and returns the data saved in the database.
     * @param {FeatureFlagCreateManyAndReturnArgs} args - Arguments to create many FeatureFlags.
     * @example
     * // Create many FeatureFlags
     * const featureFlag = await prisma.featureFlag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeatureFlags and only return the `id`
     * const featureFlagWithIdOnly = await prisma.featureFlag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureFlagCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureFlagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeatureFlag.
     * @param {FeatureFlagDeleteArgs} args - Arguments to delete one FeatureFlag.
     * @example
     * // Delete one FeatureFlag
     * const FeatureFlag = await prisma.featureFlag.delete({
     *   where: {
     *     // ... filter to delete one FeatureFlag
     *   }
     * })
     * 
     */
    delete<T extends FeatureFlagDeleteArgs>(args: SelectSubset<T, FeatureFlagDeleteArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeatureFlag.
     * @param {FeatureFlagUpdateArgs} args - Arguments to update one FeatureFlag.
     * @example
     * // Update one FeatureFlag
     * const featureFlag = await prisma.featureFlag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureFlagUpdateArgs>(args: SelectSubset<T, FeatureFlagUpdateArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeatureFlags.
     * @param {FeatureFlagDeleteManyArgs} args - Arguments to filter FeatureFlags to delete.
     * @example
     * // Delete a few FeatureFlags
     * const { count } = await prisma.featureFlag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureFlagDeleteManyArgs>(args?: SelectSubset<T, FeatureFlagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeatureFlags
     * const featureFlag = await prisma.featureFlag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureFlagUpdateManyArgs>(args: SelectSubset<T, FeatureFlagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeatureFlags and returns the data updated in the database.
     * @param {FeatureFlagUpdateManyAndReturnArgs} args - Arguments to update many FeatureFlags.
     * @example
     * // Update many FeatureFlags
     * const featureFlag = await prisma.featureFlag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeatureFlags and only return the `id`
     * const featureFlagWithIdOnly = await prisma.featureFlag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureFlagUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureFlagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeatureFlag.
     * @param {FeatureFlagUpsertArgs} args - Arguments to update or create a FeatureFlag.
     * @example
     * // Update or create a FeatureFlag
     * const featureFlag = await prisma.featureFlag.upsert({
     *   create: {
     *     // ... data to create a FeatureFlag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeatureFlag we want to update
     *   }
     * })
     */
    upsert<T extends FeatureFlagUpsertArgs>(args: SelectSubset<T, FeatureFlagUpsertArgs<ExtArgs>>): Prisma__FeatureFlagClient<$Result.GetResult<Prisma.$FeatureFlagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagCountArgs} args - Arguments to filter FeatureFlags to count.
     * @example
     * // Count the number of FeatureFlags
     * const count = await prisma.featureFlag.count({
     *   where: {
     *     // ... the filter for the FeatureFlags we want to count
     *   }
     * })
    **/
    count<T extends FeatureFlagCountArgs>(
      args?: Subset<T, FeatureFlagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureFlagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeatureFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureFlagAggregateArgs>(args: Subset<T, FeatureFlagAggregateArgs>): Prisma.PrismaPromise<GetFeatureFlagAggregateType<T>>

    /**
     * Group by FeatureFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFlagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureFlagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureFlagGroupByArgs['orderBy'] }
        : { orderBy?: FeatureFlagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureFlagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureFlagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeatureFlag model
   */
  readonly fields: FeatureFlagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeatureFlag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureFlagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeatureFlag model
   */
  interface FeatureFlagFieldRefs {
    readonly id: FieldRef<"FeatureFlag", 'String'>
    readonly name: FieldRef<"FeatureFlag", 'String'>
    readonly slug: FieldRef<"FeatureFlag", 'String'>
    readonly isEnabled: FieldRef<"FeatureFlag", 'Boolean'>
    readonly rollout: FieldRef<"FeatureFlag", 'Int'>
    readonly description: FieldRef<"FeatureFlag", 'String'>
    readonly createdAt: FieldRef<"FeatureFlag", 'DateTime'>
    readonly updatedAt: FieldRef<"FeatureFlag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeatureFlag findUnique
   */
  export type FeatureFlagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag findUniqueOrThrow
   */
  export type FeatureFlagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag findFirst
   */
  export type FeatureFlagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureFlags.
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureFlags.
     */
    distinct?: FeatureFlagScalarFieldEnum | FeatureFlagScalarFieldEnum[]
  }

  /**
   * FeatureFlag findFirstOrThrow
   */
  export type FeatureFlagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlag to fetch.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeatureFlags.
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeatureFlags.
     */
    distinct?: FeatureFlagScalarFieldEnum | FeatureFlagScalarFieldEnum[]
  }

  /**
   * FeatureFlag findMany
   */
  export type FeatureFlagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter, which FeatureFlags to fetch.
     */
    where?: FeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeatureFlags to fetch.
     */
    orderBy?: FeatureFlagOrderByWithRelationInput | FeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeatureFlags.
     */
    cursor?: FeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeatureFlags.
     */
    skip?: number
    distinct?: FeatureFlagScalarFieldEnum | FeatureFlagScalarFieldEnum[]
  }

  /**
   * FeatureFlag create
   */
  export type FeatureFlagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The data needed to create a FeatureFlag.
     */
    data: XOR<FeatureFlagCreateInput, FeatureFlagUncheckedCreateInput>
  }

  /**
   * FeatureFlag createMany
   */
  export type FeatureFlagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeatureFlags.
     */
    data: FeatureFlagCreateManyInput | FeatureFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureFlag createManyAndReturn
   */
  export type FeatureFlagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The data used to create many FeatureFlags.
     */
    data: FeatureFlagCreateManyInput | FeatureFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeatureFlag update
   */
  export type FeatureFlagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The data needed to update a FeatureFlag.
     */
    data: XOR<FeatureFlagUpdateInput, FeatureFlagUncheckedUpdateInput>
    /**
     * Choose, which FeatureFlag to update.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag updateMany
   */
  export type FeatureFlagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeatureFlags.
     */
    data: XOR<FeatureFlagUpdateManyMutationInput, FeatureFlagUncheckedUpdateManyInput>
    /**
     * Filter which FeatureFlags to update
     */
    where?: FeatureFlagWhereInput
    /**
     * Limit how many FeatureFlags to update.
     */
    limit?: number
  }

  /**
   * FeatureFlag updateManyAndReturn
   */
  export type FeatureFlagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The data used to update FeatureFlags.
     */
    data: XOR<FeatureFlagUpdateManyMutationInput, FeatureFlagUncheckedUpdateManyInput>
    /**
     * Filter which FeatureFlags to update
     */
    where?: FeatureFlagWhereInput
    /**
     * Limit how many FeatureFlags to update.
     */
    limit?: number
  }

  /**
   * FeatureFlag upsert
   */
  export type FeatureFlagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * The filter to search for the FeatureFlag to update in case it exists.
     */
    where: FeatureFlagWhereUniqueInput
    /**
     * In case the FeatureFlag found by the `where` argument doesn't exist, create a new FeatureFlag with this data.
     */
    create: XOR<FeatureFlagCreateInput, FeatureFlagUncheckedCreateInput>
    /**
     * In case the FeatureFlag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureFlagUpdateInput, FeatureFlagUncheckedUpdateInput>
  }

  /**
   * FeatureFlag delete
   */
  export type FeatureFlagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
    /**
     * Filter which FeatureFlag to delete.
     */
    where: FeatureFlagWhereUniqueInput
  }

  /**
   * FeatureFlag deleteMany
   */
  export type FeatureFlagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeatureFlags to delete
     */
    where?: FeatureFlagWhereInput
    /**
     * Limit how many FeatureFlags to delete.
     */
    limit?: number
  }

  /**
   * FeatureFlag without action
   */
  export type FeatureFlagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureFlag
     */
    select?: FeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeatureFlag
     */
    omit?: FeatureFlagOmit<ExtArgs> | null
  }


  /**
   * Model BankDetails
   */

  export type AggregateBankDetails = {
    _count: BankDetailsCountAggregateOutputType | null
    _min: BankDetailsMinAggregateOutputType | null
    _max: BankDetailsMaxAggregateOutputType | null
  }

  export type BankDetailsMinAggregateOutputType = {
    id: string | null
    bankName: string | null
    bankCode: string | null
    accountName: string | null
    accountNumber: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankDetailsMaxAggregateOutputType = {
    id: string | null
    bankName: string | null
    bankCode: string | null
    accountName: string | null
    accountNumber: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankDetailsCountAggregateOutputType = {
    id: number
    bankName: number
    bankCode: number
    accountName: number
    accountNumber: number
    storeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankDetailsMinAggregateInputType = {
    id?: true
    bankName?: true
    bankCode?: true
    accountName?: true
    accountNumber?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankDetailsMaxAggregateInputType = {
    id?: true
    bankName?: true
    bankCode?: true
    accountName?: true
    accountNumber?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankDetailsCountAggregateInputType = {
    id?: true
    bankName?: true
    bankCode?: true
    accountName?: true
    accountNumber?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetails to aggregate.
     */
    where?: BankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailsOrderByWithRelationInput | BankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankDetails
    **/
    _count?: true | BankDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankDetailsMaxAggregateInputType
  }

  export type GetBankDetailsAggregateType<T extends BankDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateBankDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankDetails[P]>
      : GetScalarType<T[P], AggregateBankDetails[P]>
  }




  export type BankDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankDetailsWhereInput
    orderBy?: BankDetailsOrderByWithAggregationInput | BankDetailsOrderByWithAggregationInput[]
    by: BankDetailsScalarFieldEnum[] | BankDetailsScalarFieldEnum
    having?: BankDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankDetailsCountAggregateInputType | true
    _min?: BankDetailsMinAggregateInputType
    _max?: BankDetailsMaxAggregateInputType
  }

  export type BankDetailsGroupByOutputType = {
    id: string
    bankName: string
    bankCode: string
    accountName: string
    accountNumber: string
    storeId: string
    createdAt: Date
    updatedAt: Date
    _count: BankDetailsCountAggregateOutputType | null
    _min: BankDetailsMinAggregateOutputType | null
    _max: BankDetailsMaxAggregateOutputType | null
  }

  type GetBankDetailsGroupByPayload<T extends BankDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], BankDetailsGroupByOutputType[P]>
        }
      >
    >


  export type BankDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    bankCode?: boolean
    accountName?: boolean
    accountNumber?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetails"]>

  export type BankDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    bankCode?: boolean
    accountName?: boolean
    accountNumber?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetails"]>

  export type BankDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    bankCode?: boolean
    accountName?: boolean
    accountNumber?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetails"]>

  export type BankDetailsSelectScalar = {
    id?: boolean
    bankName?: boolean
    bankCode?: boolean
    accountName?: boolean
    accountNumber?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bankName" | "bankCode" | "accountName" | "accountNumber" | "storeId" | "createdAt" | "updatedAt", ExtArgs["result"]["bankDetails"]>
  export type BankDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type BankDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type BankDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $BankDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankDetails"
    objects: {
      store: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bankName: string
      bankCode: string
      accountName: string
      accountNumber: string
      storeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankDetails"]>
    composites: {}
  }

  type BankDetailsGetPayload<S extends boolean | null | undefined | BankDetailsDefaultArgs> = $Result.GetResult<Prisma.$BankDetailsPayload, S>

  type BankDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankDetailsCountAggregateInputType | true
    }

  export interface BankDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankDetails'], meta: { name: 'BankDetails' } }
    /**
     * Find zero or one BankDetails that matches the filter.
     * @param {BankDetailsFindUniqueArgs} args - Arguments to find a BankDetails
     * @example
     * // Get one BankDetails
     * const bankDetails = await prisma.bankDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankDetailsFindUniqueArgs>(args: SelectSubset<T, BankDetailsFindUniqueArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankDetailsFindUniqueOrThrowArgs} args - Arguments to find a BankDetails
     * @example
     * // Get one BankDetails
     * const bankDetails = await prisma.bankDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, BankDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsFindFirstArgs} args - Arguments to find a BankDetails
     * @example
     * // Get one BankDetails
     * const bankDetails = await prisma.bankDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankDetailsFindFirstArgs>(args?: SelectSubset<T, BankDetailsFindFirstArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsFindFirstOrThrowArgs} args - Arguments to find a BankDetails
     * @example
     * // Get one BankDetails
     * const bankDetails = await prisma.bankDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, BankDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankDetails
     * const bankDetails = await prisma.bankDetails.findMany()
     * 
     * // Get first 10 BankDetails
     * const bankDetails = await prisma.bankDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankDetailsWithIdOnly = await prisma.bankDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankDetailsFindManyArgs>(args?: SelectSubset<T, BankDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankDetails.
     * @param {BankDetailsCreateArgs} args - Arguments to create a BankDetails.
     * @example
     * // Create one BankDetails
     * const BankDetails = await prisma.bankDetails.create({
     *   data: {
     *     // ... data to create a BankDetails
     *   }
     * })
     * 
     */
    create<T extends BankDetailsCreateArgs>(args: SelectSubset<T, BankDetailsCreateArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankDetails.
     * @param {BankDetailsCreateManyArgs} args - Arguments to create many BankDetails.
     * @example
     * // Create many BankDetails
     * const bankDetails = await prisma.bankDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankDetailsCreateManyArgs>(args?: SelectSubset<T, BankDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankDetails and returns the data saved in the database.
     * @param {BankDetailsCreateManyAndReturnArgs} args - Arguments to create many BankDetails.
     * @example
     * // Create many BankDetails
     * const bankDetails = await prisma.bankDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankDetails and only return the `id`
     * const bankDetailsWithIdOnly = await prisma.bankDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, BankDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankDetails.
     * @param {BankDetailsDeleteArgs} args - Arguments to delete one BankDetails.
     * @example
     * // Delete one BankDetails
     * const BankDetails = await prisma.bankDetails.delete({
     *   where: {
     *     // ... filter to delete one BankDetails
     *   }
     * })
     * 
     */
    delete<T extends BankDetailsDeleteArgs>(args: SelectSubset<T, BankDetailsDeleteArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankDetails.
     * @param {BankDetailsUpdateArgs} args - Arguments to update one BankDetails.
     * @example
     * // Update one BankDetails
     * const bankDetails = await prisma.bankDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankDetailsUpdateArgs>(args: SelectSubset<T, BankDetailsUpdateArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankDetails.
     * @param {BankDetailsDeleteManyArgs} args - Arguments to filter BankDetails to delete.
     * @example
     * // Delete a few BankDetails
     * const { count } = await prisma.bankDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankDetailsDeleteManyArgs>(args?: SelectSubset<T, BankDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankDetails
     * const bankDetails = await prisma.bankDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankDetailsUpdateManyArgs>(args: SelectSubset<T, BankDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails and returns the data updated in the database.
     * @param {BankDetailsUpdateManyAndReturnArgs} args - Arguments to update many BankDetails.
     * @example
     * // Update many BankDetails
     * const bankDetails = await prisma.bankDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankDetails and only return the `id`
     * const bankDetailsWithIdOnly = await prisma.bankDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, BankDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankDetails.
     * @param {BankDetailsUpsertArgs} args - Arguments to update or create a BankDetails.
     * @example
     * // Update or create a BankDetails
     * const bankDetails = await prisma.bankDetails.upsert({
     *   create: {
     *     // ... data to create a BankDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankDetails we want to update
     *   }
     * })
     */
    upsert<T extends BankDetailsUpsertArgs>(args: SelectSubset<T, BankDetailsUpsertArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsCountArgs} args - Arguments to filter BankDetails to count.
     * @example
     * // Count the number of BankDetails
     * const count = await prisma.bankDetails.count({
     *   where: {
     *     // ... the filter for the BankDetails we want to count
     *   }
     * })
    **/
    count<T extends BankDetailsCountArgs>(
      args?: Subset<T, BankDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankDetailsAggregateArgs>(args: Subset<T, BankDetailsAggregateArgs>): Prisma.PrismaPromise<GetBankDetailsAggregateType<T>>

    /**
     * Group by BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankDetailsGroupByArgs['orderBy'] }
        : { orderBy?: BankDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankDetails model
   */
  readonly fields: BankDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankDetails model
   */
  interface BankDetailsFieldRefs {
    readonly id: FieldRef<"BankDetails", 'String'>
    readonly bankName: FieldRef<"BankDetails", 'String'>
    readonly bankCode: FieldRef<"BankDetails", 'String'>
    readonly accountName: FieldRef<"BankDetails", 'String'>
    readonly accountNumber: FieldRef<"BankDetails", 'String'>
    readonly storeId: FieldRef<"BankDetails", 'String'>
    readonly createdAt: FieldRef<"BankDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"BankDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankDetails findUnique
   */
  export type BankDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where: BankDetailsWhereUniqueInput
  }

  /**
   * BankDetails findUniqueOrThrow
   */
  export type BankDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where: BankDetailsWhereUniqueInput
  }

  /**
   * BankDetails findFirst
   */
  export type BankDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailsOrderByWithRelationInput | BankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: BankDetailsScalarFieldEnum | BankDetailsScalarFieldEnum[]
  }

  /**
   * BankDetails findFirstOrThrow
   */
  export type BankDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailsOrderByWithRelationInput | BankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: BankDetailsScalarFieldEnum | BankDetailsScalarFieldEnum[]
  }

  /**
   * BankDetails findMany
   */
  export type BankDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailsOrderByWithRelationInput | BankDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankDetails.
     */
    cursor?: BankDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    distinct?: BankDetailsScalarFieldEnum | BankDetailsScalarFieldEnum[]
  }

  /**
   * BankDetails create
   */
  export type BankDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a BankDetails.
     */
    data: XOR<BankDetailsCreateInput, BankDetailsUncheckedCreateInput>
  }

  /**
   * BankDetails createMany
   */
  export type BankDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankDetails.
     */
    data: BankDetailsCreateManyInput | BankDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankDetails createManyAndReturn
   */
  export type BankDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many BankDetails.
     */
    data: BankDetailsCreateManyInput | BankDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankDetails update
   */
  export type BankDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a BankDetails.
     */
    data: XOR<BankDetailsUpdateInput, BankDetailsUncheckedUpdateInput>
    /**
     * Choose, which BankDetails to update.
     */
    where: BankDetailsWhereUniqueInput
  }

  /**
   * BankDetails updateMany
   */
  export type BankDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailsUpdateManyMutationInput, BankDetailsUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailsWhereInput
    /**
     * Limit how many BankDetails to update.
     */
    limit?: number
  }

  /**
   * BankDetails updateManyAndReturn
   */
  export type BankDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailsUpdateManyMutationInput, BankDetailsUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailsWhereInput
    /**
     * Limit how many BankDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankDetails upsert
   */
  export type BankDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the BankDetails to update in case it exists.
     */
    where: BankDetailsWhereUniqueInput
    /**
     * In case the BankDetails found by the `where` argument doesn't exist, create a new BankDetails with this data.
     */
    create: XOR<BankDetailsCreateInput, BankDetailsUncheckedCreateInput>
    /**
     * In case the BankDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankDetailsUpdateInput, BankDetailsUncheckedUpdateInput>
  }

  /**
   * BankDetails delete
   */
  export type BankDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    /**
     * Filter which BankDetails to delete.
     */
    where: BankDetailsWhereUniqueInput
  }

  /**
   * BankDetails deleteMany
   */
  export type BankDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetails to delete
     */
    where?: BankDetailsWhereInput
    /**
     * Limit how many BankDetails to delete.
     */
    limit?: number
  }

  /**
   * BankDetails without action
   */
  export type BankDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    balance: Decimal | null
  }

  export type WalletSumAggregateOutputType = {
    balance: Decimal | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    balance: Decimal | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    balance: Decimal | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    balance: number
    storeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    balance?: true
  }

  export type WalletSumAggregateInputType = {
    balance?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    balance?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    balance?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    balance?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    balance: Decimal
    storeId: string
    createdAt: Date
    updatedAt: Date
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    balance?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "balance" | "storeId" | "createdAt" | "updatedAt", ExtArgs["result"]["wallet"]>
  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type WalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      store: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      balance: Prisma.Decimal
      storeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets and returns the data updated in the database.
     * @param {WalletUpdateManyAndReturnArgs} args - Arguments to update many Wallets.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly balance: FieldRef<"Wallet", 'Decimal'>
    readonly storeId: FieldRef<"Wallet", 'String'>
    readonly createdAt: FieldRef<"Wallet", 'DateTime'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallet updateManyAndReturn
   */
  export type WalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to delete.
     */
    limit?: number
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    total: Decimal | null
    tax: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    total: Decimal | null
    tax: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    invoiceNumber: string | null
    title: string | null
    customerEmail: string | null
    description: string | null
    status: string | null
    downloadUrl: string | null
    paymentLink: string | null
    qrCode: string | null
    amount: string | null
    total: Decimal | null
    tax: Decimal | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    invoiceNumber: string | null
    title: string | null
    customerEmail: string | null
    description: string | null
    status: string | null
    downloadUrl: string | null
    paymentLink: string | null
    qrCode: string | null
    amount: string | null
    total: Decimal | null
    tax: Decimal | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    storeId: number
    invoiceNumber: number
    title: number
    customerEmail: number
    description: number
    status: number
    downloadUrl: number
    paymentLink: number
    qrCode: number
    amount: number
    total: number
    tax: number
    dueDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    total?: true
    tax?: true
  }

  export type InvoiceSumAggregateInputType = {
    total?: true
    tax?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    storeId?: true
    invoiceNumber?: true
    title?: true
    customerEmail?: true
    description?: true
    status?: true
    downloadUrl?: true
    paymentLink?: true
    qrCode?: true
    amount?: true
    total?: true
    tax?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    storeId?: true
    invoiceNumber?: true
    title?: true
    customerEmail?: true
    description?: true
    status?: true
    downloadUrl?: true
    paymentLink?: true
    qrCode?: true
    amount?: true
    total?: true
    tax?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    storeId?: true
    invoiceNumber?: true
    title?: true
    customerEmail?: true
    description?: true
    status?: true
    downloadUrl?: true
    paymentLink?: true
    qrCode?: true
    amount?: true
    total?: true
    tax?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    storeId: string
    invoiceNumber: string
    title: string
    customerEmail: string
    description: string | null
    status: string | null
    downloadUrl: string
    paymentLink: string | null
    qrCode: string | null
    amount: string
    total: Decimal
    tax: Decimal
    dueDate: Date
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    invoiceNumber?: boolean
    title?: boolean
    customerEmail?: boolean
    description?: boolean
    status?: boolean
    downloadUrl?: boolean
    paymentLink?: boolean
    qrCode?: boolean
    amount?: boolean
    total?: boolean
    tax?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    invoiceNumber?: boolean
    title?: boolean
    customerEmail?: boolean
    description?: boolean
    status?: boolean
    downloadUrl?: boolean
    paymentLink?: boolean
    qrCode?: boolean
    amount?: boolean
    total?: boolean
    tax?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    invoiceNumber?: boolean
    title?: boolean
    customerEmail?: boolean
    description?: boolean
    status?: boolean
    downloadUrl?: boolean
    paymentLink?: boolean
    qrCode?: boolean
    amount?: boolean
    total?: boolean
    tax?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    storeId?: boolean
    invoiceNumber?: boolean
    title?: boolean
    customerEmail?: boolean
    description?: boolean
    status?: boolean
    downloadUrl?: boolean
    paymentLink?: boolean
    qrCode?: boolean
    amount?: boolean
    total?: boolean
    tax?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeId" | "invoiceNumber" | "title" | "customerEmail" | "description" | "status" | "downloadUrl" | "paymentLink" | "qrCode" | "amount" | "total" | "tax" | "dueDate" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      store: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      invoiceNumber: string
      title: string
      customerEmail: string
      description: string | null
      status: string | null
      downloadUrl: string
      paymentLink: string | null
      qrCode: string | null
      amount: string
      total: Prisma.Decimal
      tax: Prisma.Decimal
      dueDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly storeId: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly title: FieldRef<"Invoice", 'String'>
    readonly customerEmail: FieldRef<"Invoice", 'String'>
    readonly description: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly downloadUrl: FieldRef<"Invoice", 'String'>
    readonly paymentLink: FieldRef<"Invoice", 'String'>
    readonly qrCode: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'String'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
    readonly tax: FieldRef<"Invoice", 'Decimal'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    country: string | null
    region: string | null
    city: string | null
    description: string | null
    storeId: string | null
    isdefaultLocation: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    country: string | null
    region: string | null
    city: string | null
    description: string | null
    storeId: string | null
    isdefaultLocation: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    address: number
    country: number
    region: number
    city: number
    description: number
    storeId: number
    isdefaultLocation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    country?: true
    region?: true
    city?: true
    description?: true
    storeId?: true
    isdefaultLocation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    country?: true
    region?: true
    city?: true
    description?: true
    storeId?: true
    isdefaultLocation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    country?: true
    region?: true
    city?: true
    description?: true
    storeId?: true
    isdefaultLocation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    name: string
    address: string | null
    country: string | null
    region: string | null
    city: string | null
    description: string | null
    storeId: string
    isdefaultLocation: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    description?: boolean
    storeId?: boolean
    isdefaultLocation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Location$userArgs<ExtArgs>
    order?: boolean | Location$orderArgs<ExtArgs>
    product?: boolean | Location$productArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    description?: boolean
    storeId?: boolean
    isdefaultLocation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    description?: boolean
    storeId?: boolean
    isdefaultLocation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    description?: boolean
    storeId?: boolean
    isdefaultLocation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "country" | "region" | "city" | "description" | "storeId" | "isdefaultLocation" | "createdAt" | "updatedAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Location$userArgs<ExtArgs>
    order?: boolean | Location$orderArgs<ExtArgs>
    product?: boolean | Location$productArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>[]
      order: Prisma.$OrderPayload<ExtArgs>[]
      product: Prisma.$ProductPayload<ExtArgs>[]
      store: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      country: string | null
      region: string | null
      city: string | null
      description: string | null
      storeId: string
      isdefaultLocation: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Location$userArgs<ExtArgs> = {}>(args?: Subset<T, Location$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    order<T extends Location$orderArgs<ExtArgs> = {}>(args?: Subset<T, Location$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    product<T extends Location$productArgs<ExtArgs> = {}>(args?: Subset<T, Location$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly country: FieldRef<"Location", 'String'>
    readonly region: FieldRef<"Location", 'String'>
    readonly city: FieldRef<"Location", 'String'>
    readonly description: FieldRef<"Location", 'String'>
    readonly storeId: FieldRef<"Location", 'String'>
    readonly isdefaultLocation: FieldRef<"Location", 'Boolean'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.user
   */
  export type Location$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Location.order
   */
  export type Location$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Location.product
   */
  export type Location$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    grandTotal: number | null
    deliveryTrackingNumber: number | null
    totalAmount: number | null
    subtotalAmount: number | null
    discountAmount: number | null
    taxAmount: number | null
    shippingFee: number | null
  }

  export type OrderSumAggregateOutputType = {
    grandTotal: number | null
    deliveryTrackingNumber: number | null
    totalAmount: number | null
    subtotalAmount: number | null
    discountAmount: number | null
    taxAmount: number | null
    shippingFee: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    locationId: string | null
    createdBy: string | null
    storeId: string | null
    shippingMethodId: string | null
    grandTotal: number | null
    iscustomerAssigned: boolean | null
    status: $Enums.OrderStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    deliveryTrackingNumber: number | null
    totalAmount: number | null
    subtotalAmount: number | null
    discountAmount: number | null
    taxAmount: number | null
    shippingFee: number | null
    shippingZoneName: string | null
    shippingAddress: string | null
    shippingStatus: string | null
    channel: string | null
    isposConfirmed: boolean | null
    customerName: string | null
    customerEmail: string | null
    customerPhoneNumber: string | null
    posConfirmedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    locationId: string | null
    createdBy: string | null
    storeId: string | null
    shippingMethodId: string | null
    grandTotal: number | null
    iscustomerAssigned: boolean | null
    status: $Enums.OrderStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    deliveryTrackingNumber: number | null
    totalAmount: number | null
    subtotalAmount: number | null
    discountAmount: number | null
    taxAmount: number | null
    shippingFee: number | null
    shippingZoneName: string | null
    shippingAddress: string | null
    shippingStatus: string | null
    channel: string | null
    isposConfirmed: boolean | null
    customerName: string | null
    customerEmail: string | null
    customerPhoneNumber: string | null
    posConfirmedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    customerId: number
    locationId: number
    createdBy: number
    storeId: number
    shippingMethodId: number
    grandTotal: number
    iscustomerAssigned: number
    status: number
    paymentStatus: number
    paymentMethod: number
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount: number
    taxAmount: number
    shippingFee: number
    shippingZoneName: number
    shippingAddress: number
    shippingStatus: number
    channel: number
    isposConfirmed: number
    customerName: number
    customerEmail: number
    customerPhoneNumber: number
    posConfirmedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    grandTotal?: true
    deliveryTrackingNumber?: true
    totalAmount?: true
    subtotalAmount?: true
    discountAmount?: true
    taxAmount?: true
    shippingFee?: true
  }

  export type OrderSumAggregateInputType = {
    grandTotal?: true
    deliveryTrackingNumber?: true
    totalAmount?: true
    subtotalAmount?: true
    discountAmount?: true
    taxAmount?: true
    shippingFee?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    customerId?: true
    locationId?: true
    createdBy?: true
    storeId?: true
    shippingMethodId?: true
    grandTotal?: true
    iscustomerAssigned?: true
    status?: true
    paymentStatus?: true
    paymentMethod?: true
    deliveryTrackingNumber?: true
    totalAmount?: true
    subtotalAmount?: true
    discountAmount?: true
    taxAmount?: true
    shippingFee?: true
    shippingZoneName?: true
    shippingAddress?: true
    shippingStatus?: true
    channel?: true
    isposConfirmed?: true
    customerName?: true
    customerEmail?: true
    customerPhoneNumber?: true
    posConfirmedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    customerId?: true
    locationId?: true
    createdBy?: true
    storeId?: true
    shippingMethodId?: true
    grandTotal?: true
    iscustomerAssigned?: true
    status?: true
    paymentStatus?: true
    paymentMethod?: true
    deliveryTrackingNumber?: true
    totalAmount?: true
    subtotalAmount?: true
    discountAmount?: true
    taxAmount?: true
    shippingFee?: true
    shippingZoneName?: true
    shippingAddress?: true
    shippingStatus?: true
    channel?: true
    isposConfirmed?: true
    customerName?: true
    customerEmail?: true
    customerPhoneNumber?: true
    posConfirmedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    customerId?: true
    locationId?: true
    createdBy?: true
    storeId?: true
    shippingMethodId?: true
    grandTotal?: true
    iscustomerAssigned?: true
    status?: true
    paymentStatus?: true
    paymentMethod?: true
    deliveryTrackingNumber?: true
    totalAmount?: true
    subtotalAmount?: true
    discountAmount?: true
    taxAmount?: true
    shippingFee?: true
    shippingZoneName?: true
    shippingAddress?: true
    shippingStatus?: true
    channel?: true
    isposConfirmed?: true
    customerName?: true
    customerEmail?: true
    customerPhoneNumber?: true
    posConfirmedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    customerId: string
    locationId: string
    createdBy: string | null
    storeId: string | null
    shippingMethodId: string | null
    grandTotal: number
    iscustomerAssigned: boolean
    status: $Enums.OrderStatus
    paymentStatus: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName: string | null
    shippingAddress: string | null
    shippingStatus: string | null
    channel: string | null
    isposConfirmed: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    locationId?: boolean
    createdBy?: boolean
    storeId?: boolean
    shippingMethodId?: boolean
    grandTotal?: boolean
    iscustomerAssigned?: boolean
    status?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    deliveryTrackingNumber?: boolean
    totalAmount?: boolean
    subtotalAmount?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    shippingFee?: boolean
    shippingZoneName?: boolean
    shippingAddress?: boolean
    shippingStatus?: boolean
    channel?: boolean
    isposConfirmed?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhoneNumber?: boolean
    posConfirmedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    pos?: boolean | Order$posArgs<ExtArgs>
    cart?: boolean | Order$cartArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    location?: boolean | Order$locationArgs<ExtArgs>
    store?: boolean | Order$storeArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    locationId?: boolean
    createdBy?: boolean
    storeId?: boolean
    shippingMethodId?: boolean
    grandTotal?: boolean
    iscustomerAssigned?: boolean
    status?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    deliveryTrackingNumber?: boolean
    totalAmount?: boolean
    subtotalAmount?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    shippingFee?: boolean
    shippingZoneName?: boolean
    shippingAddress?: boolean
    shippingStatus?: boolean
    channel?: boolean
    isposConfirmed?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhoneNumber?: boolean
    posConfirmedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    location?: boolean | Order$locationArgs<ExtArgs>
    store?: boolean | Order$storeArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    locationId?: boolean
    createdBy?: boolean
    storeId?: boolean
    shippingMethodId?: boolean
    grandTotal?: boolean
    iscustomerAssigned?: boolean
    status?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    deliveryTrackingNumber?: boolean
    totalAmount?: boolean
    subtotalAmount?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    shippingFee?: boolean
    shippingZoneName?: boolean
    shippingAddress?: boolean
    shippingStatus?: boolean
    channel?: boolean
    isposConfirmed?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhoneNumber?: boolean
    posConfirmedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    location?: boolean | Order$locationArgs<ExtArgs>
    store?: boolean | Order$storeArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    customerId?: boolean
    locationId?: boolean
    createdBy?: boolean
    storeId?: boolean
    shippingMethodId?: boolean
    grandTotal?: boolean
    iscustomerAssigned?: boolean
    status?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    deliveryTrackingNumber?: boolean
    totalAmount?: boolean
    subtotalAmount?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    shippingFee?: boolean
    shippingZoneName?: boolean
    shippingAddress?: boolean
    shippingStatus?: boolean
    channel?: boolean
    isposConfirmed?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhoneNumber?: boolean
    posConfirmedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "locationId" | "createdBy" | "storeId" | "shippingMethodId" | "grandTotal" | "iscustomerAssigned" | "status" | "paymentStatus" | "paymentMethod" | "deliveryTrackingNumber" | "totalAmount" | "subtotalAmount" | "discountAmount" | "taxAmount" | "shippingFee" | "shippingZoneName" | "shippingAddress" | "shippingStatus" | "channel" | "isposConfirmed" | "customerName" | "customerEmail" | "customerPhoneNumber" | "posConfirmedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    pos?: boolean | Order$posArgs<ExtArgs>
    cart?: boolean | Order$cartArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    location?: boolean | Order$locationArgs<ExtArgs>
    store?: boolean | Order$storeArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    location?: boolean | Order$locationArgs<ExtArgs>
    store?: boolean | Order$storeArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    location?: boolean | Order$locationArgs<ExtArgs>
    store?: boolean | Order$storeArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      pos: Prisma.$POSPayload<ExtArgs> | null
      cart: Prisma.$CartPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs> | null
      store: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      locationId: string
      createdBy: string | null
      storeId: string | null
      shippingMethodId: string | null
      grandTotal: number
      iscustomerAssigned: boolean
      status: $Enums.OrderStatus
      paymentStatus: $Enums.PaymentStatus
      paymentMethod: $Enums.PaymentMethod
      deliveryTrackingNumber: number
      totalAmount: number
      subtotalAmount: number
      discountAmount: number | null
      taxAmount: number
      shippingFee: number
      shippingZoneName: string | null
      shippingAddress: string | null
      shippingStatus: string | null
      channel: string | null
      isposConfirmed: boolean | null
      customerName: string
      customerEmail: string
      customerPhoneNumber: string
      posConfirmedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Order$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pos<T extends Order$posArgs<ExtArgs> = {}>(args?: Subset<T, Order$posArgs<ExtArgs>>): Prisma__POSClient<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cart<T extends Order$cartArgs<ExtArgs> = {}>(args?: Subset<T, Order$cartArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends Order$locationArgs<ExtArgs> = {}>(args?: Subset<T, Order$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    store<T extends Order$storeArgs<ExtArgs> = {}>(args?: Subset<T, Order$storeArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly locationId: FieldRef<"Order", 'String'>
    readonly createdBy: FieldRef<"Order", 'String'>
    readonly storeId: FieldRef<"Order", 'String'>
    readonly shippingMethodId: FieldRef<"Order", 'String'>
    readonly grandTotal: FieldRef<"Order", 'Float'>
    readonly iscustomerAssigned: FieldRef<"Order", 'Boolean'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly paymentStatus: FieldRef<"Order", 'PaymentStatus'>
    readonly paymentMethod: FieldRef<"Order", 'PaymentMethod'>
    readonly deliveryTrackingNumber: FieldRef<"Order", 'Int'>
    readonly totalAmount: FieldRef<"Order", 'Float'>
    readonly subtotalAmount: FieldRef<"Order", 'Float'>
    readonly discountAmount: FieldRef<"Order", 'Float'>
    readonly taxAmount: FieldRef<"Order", 'Float'>
    readonly shippingFee: FieldRef<"Order", 'Float'>
    readonly shippingZoneName: FieldRef<"Order", 'String'>
    readonly shippingAddress: FieldRef<"Order", 'String'>
    readonly shippingStatus: FieldRef<"Order", 'String'>
    readonly channel: FieldRef<"Order", 'String'>
    readonly isposConfirmed: FieldRef<"Order", 'Boolean'>
    readonly customerName: FieldRef<"Order", 'String'>
    readonly customerEmail: FieldRef<"Order", 'String'>
    readonly customerPhoneNumber: FieldRef<"Order", 'String'>
    readonly posConfirmedAt: FieldRef<"Order", 'DateTime'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.orderItems
   */
  export type Order$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.pos
   */
  export type Order$posArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
    where?: POSWhereInput
  }

  /**
   * Order.cart
   */
  export type Order$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
  }

  /**
   * Order.location
   */
  export type Order$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Order.store
   */
  export type Order$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    price: number | null
    orderId: string | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    price: number | null
    orderId: string | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    quantity: number
    price: number
    orderId: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    quantity?: true
    price?: true
    orderId?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    quantity?: true
    price?: true
    orderId?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    quantity?: true
    price?: true
    orderId?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    quantity: number
    price: number
    orderId: string
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    price?: boolean
    orderId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    price?: boolean
    orderId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    price?: boolean
    orderId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    quantity?: boolean
    price?: boolean
    orderId?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "price" | "orderId", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quantity: number
      price: number
      orderId: string
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Float'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model POS
   */

  export type AggregatePOS = {
    _count: POSCountAggregateOutputType | null
    _min: POSMinAggregateOutputType | null
    _max: POSMaxAggregateOutputType | null
  }

  export type POSMinAggregateOutputType = {
    id: string | null
    staffId: string | null
    orderId: string | null
    customerId: string | null
    terminalId: string | null
    confirmed: boolean | null
    confirmedAt: Date | null
  }

  export type POSMaxAggregateOutputType = {
    id: string | null
    staffId: string | null
    orderId: string | null
    customerId: string | null
    terminalId: string | null
    confirmed: boolean | null
    confirmedAt: Date | null
  }

  export type POSCountAggregateOutputType = {
    id: number
    staffId: number
    orderId: number
    customerId: number
    terminalId: number
    confirmed: number
    confirmedAt: number
    _all: number
  }


  export type POSMinAggregateInputType = {
    id?: true
    staffId?: true
    orderId?: true
    customerId?: true
    terminalId?: true
    confirmed?: true
    confirmedAt?: true
  }

  export type POSMaxAggregateInputType = {
    id?: true
    staffId?: true
    orderId?: true
    customerId?: true
    terminalId?: true
    confirmed?: true
    confirmedAt?: true
  }

  export type POSCountAggregateInputType = {
    id?: true
    staffId?: true
    orderId?: true
    customerId?: true
    terminalId?: true
    confirmed?: true
    confirmedAt?: true
    _all?: true
  }

  export type POSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POS to aggregate.
     */
    where?: POSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     */
    orderBy?: POSOrderByWithRelationInput | POSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POS
    **/
    _count?: true | POSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POSMaxAggregateInputType
  }

  export type GetPOSAggregateType<T extends POSAggregateArgs> = {
        [P in keyof T & keyof AggregatePOS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOS[P]>
      : GetScalarType<T[P], AggregatePOS[P]>
  }




  export type POSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSWhereInput
    orderBy?: POSOrderByWithAggregationInput | POSOrderByWithAggregationInput[]
    by: POSScalarFieldEnum[] | POSScalarFieldEnum
    having?: POSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POSCountAggregateInputType | true
    _min?: POSMinAggregateInputType
    _max?: POSMaxAggregateInputType
  }

  export type POSGroupByOutputType = {
    id: string
    staffId: string
    orderId: string
    customerId: string
    terminalId: string
    confirmed: boolean
    confirmedAt: Date | null
    _count: POSCountAggregateOutputType | null
    _min: POSMinAggregateOutputType | null
    _max: POSMaxAggregateOutputType | null
  }

  type GetPOSGroupByPayload<T extends POSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POSGroupByOutputType[P]>
            : GetScalarType<T[P], POSGroupByOutputType[P]>
        }
      >
    >


  export type POSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    orderId?: boolean
    customerId?: boolean
    terminalId?: boolean
    confirmed?: boolean
    confirmedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOS"]>

  export type POSSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    orderId?: boolean
    customerId?: boolean
    terminalId?: boolean
    confirmed?: boolean
    confirmedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOS"]>

  export type POSSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    orderId?: boolean
    customerId?: boolean
    terminalId?: boolean
    confirmed?: boolean
    confirmedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOS"]>

  export type POSSelectScalar = {
    id?: boolean
    staffId?: boolean
    orderId?: boolean
    customerId?: boolean
    terminalId?: boolean
    confirmed?: boolean
    confirmedAt?: boolean
  }

  export type POSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "staffId" | "orderId" | "customerId" | "terminalId" | "confirmed" | "confirmedAt", ExtArgs["result"]["pOS"]>
  export type POSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type POSIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type POSIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $POSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POS"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      staff: Prisma.$UserPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffId: string
      orderId: string
      customerId: string
      terminalId: string
      confirmed: boolean
      confirmedAt: Date | null
    }, ExtArgs["result"]["pOS"]>
    composites: {}
  }

  type POSGetPayload<S extends boolean | null | undefined | POSDefaultArgs> = $Result.GetResult<Prisma.$POSPayload, S>

  type POSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<POSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: POSCountAggregateInputType | true
    }

  export interface POSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POS'], meta: { name: 'POS' } }
    /**
     * Find zero or one POS that matches the filter.
     * @param {POSFindUniqueArgs} args - Arguments to find a POS
     * @example
     * // Get one POS
     * const pOS = await prisma.pOS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends POSFindUniqueArgs>(args: SelectSubset<T, POSFindUniqueArgs<ExtArgs>>): Prisma__POSClient<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one POS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {POSFindUniqueOrThrowArgs} args - Arguments to find a POS
     * @example
     * // Get one POS
     * const pOS = await prisma.pOS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends POSFindUniqueOrThrowArgs>(args: SelectSubset<T, POSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__POSClient<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSFindFirstArgs} args - Arguments to find a POS
     * @example
     * // Get one POS
     * const pOS = await prisma.pOS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends POSFindFirstArgs>(args?: SelectSubset<T, POSFindFirstArgs<ExtArgs>>): Prisma__POSClient<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSFindFirstOrThrowArgs} args - Arguments to find a POS
     * @example
     * // Get one POS
     * const pOS = await prisma.pOS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends POSFindFirstOrThrowArgs>(args?: SelectSubset<T, POSFindFirstOrThrowArgs<ExtArgs>>): Prisma__POSClient<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more POS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POS
     * const pOS = await prisma.pOS.findMany()
     * 
     * // Get first 10 POS
     * const pOS = await prisma.pOS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOSWithIdOnly = await prisma.pOS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends POSFindManyArgs>(args?: SelectSubset<T, POSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a POS.
     * @param {POSCreateArgs} args - Arguments to create a POS.
     * @example
     * // Create one POS
     * const POS = await prisma.pOS.create({
     *   data: {
     *     // ... data to create a POS
     *   }
     * })
     * 
     */
    create<T extends POSCreateArgs>(args: SelectSubset<T, POSCreateArgs<ExtArgs>>): Prisma__POSClient<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many POS.
     * @param {POSCreateManyArgs} args - Arguments to create many POS.
     * @example
     * // Create many POS
     * const pOS = await prisma.pOS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends POSCreateManyArgs>(args?: SelectSubset<T, POSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many POS and returns the data saved in the database.
     * @param {POSCreateManyAndReturnArgs} args - Arguments to create many POS.
     * @example
     * // Create many POS
     * const pOS = await prisma.pOS.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many POS and only return the `id`
     * const pOSWithIdOnly = await prisma.pOS.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends POSCreateManyAndReturnArgs>(args?: SelectSubset<T, POSCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a POS.
     * @param {POSDeleteArgs} args - Arguments to delete one POS.
     * @example
     * // Delete one POS
     * const POS = await prisma.pOS.delete({
     *   where: {
     *     // ... filter to delete one POS
     *   }
     * })
     * 
     */
    delete<T extends POSDeleteArgs>(args: SelectSubset<T, POSDeleteArgs<ExtArgs>>): Prisma__POSClient<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one POS.
     * @param {POSUpdateArgs} args - Arguments to update one POS.
     * @example
     * // Update one POS
     * const pOS = await prisma.pOS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends POSUpdateArgs>(args: SelectSubset<T, POSUpdateArgs<ExtArgs>>): Prisma__POSClient<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more POS.
     * @param {POSDeleteManyArgs} args - Arguments to filter POS to delete.
     * @example
     * // Delete a few POS
     * const { count } = await prisma.pOS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends POSDeleteManyArgs>(args?: SelectSubset<T, POSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POS
     * const pOS = await prisma.pOS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends POSUpdateManyArgs>(args: SelectSubset<T, POSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POS and returns the data updated in the database.
     * @param {POSUpdateManyAndReturnArgs} args - Arguments to update many POS.
     * @example
     * // Update many POS
     * const pOS = await prisma.pOS.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more POS and only return the `id`
     * const pOSWithIdOnly = await prisma.pOS.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends POSUpdateManyAndReturnArgs>(args: SelectSubset<T, POSUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one POS.
     * @param {POSUpsertArgs} args - Arguments to update or create a POS.
     * @example
     * // Update or create a POS
     * const pOS = await prisma.pOS.upsert({
     *   create: {
     *     // ... data to create a POS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POS we want to update
     *   }
     * })
     */
    upsert<T extends POSUpsertArgs>(args: SelectSubset<T, POSUpsertArgs<ExtArgs>>): Prisma__POSClient<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of POS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSCountArgs} args - Arguments to filter POS to count.
     * @example
     * // Count the number of POS
     * const count = await prisma.pOS.count({
     *   where: {
     *     // ... the filter for the POS we want to count
     *   }
     * })
    **/
    count<T extends POSCountArgs>(
      args?: Subset<T, POSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POSAggregateArgs>(args: Subset<T, POSAggregateArgs>): Prisma.PrismaPromise<GetPOSAggregateType<T>>

    /**
     * Group by POS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POSGroupByArgs['orderBy'] }
        : { orderBy?: POSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POS model
   */
  readonly fields: POSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the POS model
   */
  interface POSFieldRefs {
    readonly id: FieldRef<"POS", 'String'>
    readonly staffId: FieldRef<"POS", 'String'>
    readonly orderId: FieldRef<"POS", 'String'>
    readonly customerId: FieldRef<"POS", 'String'>
    readonly terminalId: FieldRef<"POS", 'String'>
    readonly confirmed: FieldRef<"POS", 'Boolean'>
    readonly confirmedAt: FieldRef<"POS", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * POS findUnique
   */
  export type POSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
    /**
     * Filter, which POS to fetch.
     */
    where: POSWhereUniqueInput
  }

  /**
   * POS findUniqueOrThrow
   */
  export type POSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
    /**
     * Filter, which POS to fetch.
     */
    where: POSWhereUniqueInput
  }

  /**
   * POS findFirst
   */
  export type POSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
    /**
     * Filter, which POS to fetch.
     */
    where?: POSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     */
    orderBy?: POSOrderByWithRelationInput | POSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POS.
     */
    cursor?: POSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POS.
     */
    distinct?: POSScalarFieldEnum | POSScalarFieldEnum[]
  }

  /**
   * POS findFirstOrThrow
   */
  export type POSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
    /**
     * Filter, which POS to fetch.
     */
    where?: POSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     */
    orderBy?: POSOrderByWithRelationInput | POSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POS.
     */
    cursor?: POSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POS.
     */
    distinct?: POSScalarFieldEnum | POSScalarFieldEnum[]
  }

  /**
   * POS findMany
   */
  export type POSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
    /**
     * Filter, which POS to fetch.
     */
    where?: POSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     */
    orderBy?: POSOrderByWithRelationInput | POSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POS.
     */
    cursor?: POSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     */
    skip?: number
    distinct?: POSScalarFieldEnum | POSScalarFieldEnum[]
  }

  /**
   * POS create
   */
  export type POSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
    /**
     * The data needed to create a POS.
     */
    data: XOR<POSCreateInput, POSUncheckedCreateInput>
  }

  /**
   * POS createMany
   */
  export type POSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POS.
     */
    data: POSCreateManyInput | POSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * POS createManyAndReturn
   */
  export type POSCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * The data used to create many POS.
     */
    data: POSCreateManyInput | POSCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * POS update
   */
  export type POSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
    /**
     * The data needed to update a POS.
     */
    data: XOR<POSUpdateInput, POSUncheckedUpdateInput>
    /**
     * Choose, which POS to update.
     */
    where: POSWhereUniqueInput
  }

  /**
   * POS updateMany
   */
  export type POSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POS.
     */
    data: XOR<POSUpdateManyMutationInput, POSUncheckedUpdateManyInput>
    /**
     * Filter which POS to update
     */
    where?: POSWhereInput
    /**
     * Limit how many POS to update.
     */
    limit?: number
  }

  /**
   * POS updateManyAndReturn
   */
  export type POSUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * The data used to update POS.
     */
    data: XOR<POSUpdateManyMutationInput, POSUncheckedUpdateManyInput>
    /**
     * Filter which POS to update
     */
    where?: POSWhereInput
    /**
     * Limit how many POS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * POS upsert
   */
  export type POSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
    /**
     * The filter to search for the POS to update in case it exists.
     */
    where: POSWhereUniqueInput
    /**
     * In case the POS found by the `where` argument doesn't exist, create a new POS with this data.
     */
    create: XOR<POSCreateInput, POSUncheckedCreateInput>
    /**
     * In case the POS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POSUpdateInput, POSUncheckedUpdateInput>
  }

  /**
   * POS delete
   */
  export type POSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
    /**
     * Filter which POS to delete.
     */
    where: POSWhereUniqueInput
  }

  /**
   * POS deleteMany
   */
  export type POSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POS to delete
     */
    where?: POSWhereInput
    /**
     * Limit how many POS to delete.
     */
    limit?: number
  }

  /**
   * POS without action
   */
  export type POSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
  }


  /**
   * Model PointOfSale
   */

  export type AggregatePointOfSale = {
    _count: PointOfSaleCountAggregateOutputType | null
    _min: PointOfSaleMinAggregateOutputType | null
    _max: PointOfSaleMaxAggregateOutputType | null
  }

  export type PointOfSaleMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    staffAssignedId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PointOfSaleMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    staffAssignedId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PointOfSaleCountAggregateOutputType = {
    id: number
    storeId: number
    staffAssignedId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PointOfSaleMinAggregateInputType = {
    id?: true
    storeId?: true
    staffAssignedId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PointOfSaleMaxAggregateInputType = {
    id?: true
    storeId?: true
    staffAssignedId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PointOfSaleCountAggregateInputType = {
    id?: true
    storeId?: true
    staffAssignedId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PointOfSaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointOfSale to aggregate.
     */
    where?: PointOfSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointOfSales to fetch.
     */
    orderBy?: PointOfSaleOrderByWithRelationInput | PointOfSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointOfSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointOfSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointOfSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointOfSales
    **/
    _count?: true | PointOfSaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointOfSaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointOfSaleMaxAggregateInputType
  }

  export type GetPointOfSaleAggregateType<T extends PointOfSaleAggregateArgs> = {
        [P in keyof T & keyof AggregatePointOfSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointOfSale[P]>
      : GetScalarType<T[P], AggregatePointOfSale[P]>
  }




  export type PointOfSaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointOfSaleWhereInput
    orderBy?: PointOfSaleOrderByWithAggregationInput | PointOfSaleOrderByWithAggregationInput[]
    by: PointOfSaleScalarFieldEnum[] | PointOfSaleScalarFieldEnum
    having?: PointOfSaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointOfSaleCountAggregateInputType | true
    _min?: PointOfSaleMinAggregateInputType
    _max?: PointOfSaleMaxAggregateInputType
  }

  export type PointOfSaleGroupByOutputType = {
    id: string
    storeId: string
    staffAssignedId: string
    createdAt: Date
    updatedAt: Date
    _count: PointOfSaleCountAggregateOutputType | null
    _min: PointOfSaleMinAggregateOutputType | null
    _max: PointOfSaleMaxAggregateOutputType | null
  }

  type GetPointOfSaleGroupByPayload<T extends PointOfSaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointOfSaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointOfSaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointOfSaleGroupByOutputType[P]>
            : GetScalarType<T[P], PointOfSaleGroupByOutputType[P]>
        }
      >
    >


  export type PointOfSaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    staffAssignedId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    staffAssigned?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointOfSale"]>

  export type PointOfSaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    staffAssignedId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    staffAssigned?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointOfSale"]>

  export type PointOfSaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    staffAssignedId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    staffAssigned?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointOfSale"]>

  export type PointOfSaleSelectScalar = {
    id?: boolean
    storeId?: boolean
    staffAssignedId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PointOfSaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeId" | "staffAssignedId" | "createdAt" | "updatedAt", ExtArgs["result"]["pointOfSale"]>
  export type PointOfSaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    staffAssigned?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PointOfSaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    staffAssigned?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PointOfSaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    staffAssigned?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PointOfSalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointOfSale"
    objects: {
      store: Prisma.$OrganizationPayload<ExtArgs>
      staffAssigned: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      staffAssignedId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pointOfSale"]>
    composites: {}
  }

  type PointOfSaleGetPayload<S extends boolean | null | undefined | PointOfSaleDefaultArgs> = $Result.GetResult<Prisma.$PointOfSalePayload, S>

  type PointOfSaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PointOfSaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PointOfSaleCountAggregateInputType | true
    }

  export interface PointOfSaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointOfSale'], meta: { name: 'PointOfSale' } }
    /**
     * Find zero or one PointOfSale that matches the filter.
     * @param {PointOfSaleFindUniqueArgs} args - Arguments to find a PointOfSale
     * @example
     * // Get one PointOfSale
     * const pointOfSale = await prisma.pointOfSale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointOfSaleFindUniqueArgs>(args: SelectSubset<T, PointOfSaleFindUniqueArgs<ExtArgs>>): Prisma__PointOfSaleClient<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PointOfSale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PointOfSaleFindUniqueOrThrowArgs} args - Arguments to find a PointOfSale
     * @example
     * // Get one PointOfSale
     * const pointOfSale = await prisma.pointOfSale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointOfSaleFindUniqueOrThrowArgs>(args: SelectSubset<T, PointOfSaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointOfSaleClient<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointOfSale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointOfSaleFindFirstArgs} args - Arguments to find a PointOfSale
     * @example
     * // Get one PointOfSale
     * const pointOfSale = await prisma.pointOfSale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointOfSaleFindFirstArgs>(args?: SelectSubset<T, PointOfSaleFindFirstArgs<ExtArgs>>): Prisma__PointOfSaleClient<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointOfSale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointOfSaleFindFirstOrThrowArgs} args - Arguments to find a PointOfSale
     * @example
     * // Get one PointOfSale
     * const pointOfSale = await prisma.pointOfSale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointOfSaleFindFirstOrThrowArgs>(args?: SelectSubset<T, PointOfSaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointOfSaleClient<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PointOfSales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointOfSaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointOfSales
     * const pointOfSales = await prisma.pointOfSale.findMany()
     * 
     * // Get first 10 PointOfSales
     * const pointOfSales = await prisma.pointOfSale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointOfSaleWithIdOnly = await prisma.pointOfSale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointOfSaleFindManyArgs>(args?: SelectSubset<T, PointOfSaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PointOfSale.
     * @param {PointOfSaleCreateArgs} args - Arguments to create a PointOfSale.
     * @example
     * // Create one PointOfSale
     * const PointOfSale = await prisma.pointOfSale.create({
     *   data: {
     *     // ... data to create a PointOfSale
     *   }
     * })
     * 
     */
    create<T extends PointOfSaleCreateArgs>(args: SelectSubset<T, PointOfSaleCreateArgs<ExtArgs>>): Prisma__PointOfSaleClient<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PointOfSales.
     * @param {PointOfSaleCreateManyArgs} args - Arguments to create many PointOfSales.
     * @example
     * // Create many PointOfSales
     * const pointOfSale = await prisma.pointOfSale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointOfSaleCreateManyArgs>(args?: SelectSubset<T, PointOfSaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PointOfSales and returns the data saved in the database.
     * @param {PointOfSaleCreateManyAndReturnArgs} args - Arguments to create many PointOfSales.
     * @example
     * // Create many PointOfSales
     * const pointOfSale = await prisma.pointOfSale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PointOfSales and only return the `id`
     * const pointOfSaleWithIdOnly = await prisma.pointOfSale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PointOfSaleCreateManyAndReturnArgs>(args?: SelectSubset<T, PointOfSaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PointOfSale.
     * @param {PointOfSaleDeleteArgs} args - Arguments to delete one PointOfSale.
     * @example
     * // Delete one PointOfSale
     * const PointOfSale = await prisma.pointOfSale.delete({
     *   where: {
     *     // ... filter to delete one PointOfSale
     *   }
     * })
     * 
     */
    delete<T extends PointOfSaleDeleteArgs>(args: SelectSubset<T, PointOfSaleDeleteArgs<ExtArgs>>): Prisma__PointOfSaleClient<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PointOfSale.
     * @param {PointOfSaleUpdateArgs} args - Arguments to update one PointOfSale.
     * @example
     * // Update one PointOfSale
     * const pointOfSale = await prisma.pointOfSale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointOfSaleUpdateArgs>(args: SelectSubset<T, PointOfSaleUpdateArgs<ExtArgs>>): Prisma__PointOfSaleClient<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PointOfSales.
     * @param {PointOfSaleDeleteManyArgs} args - Arguments to filter PointOfSales to delete.
     * @example
     * // Delete a few PointOfSales
     * const { count } = await prisma.pointOfSale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointOfSaleDeleteManyArgs>(args?: SelectSubset<T, PointOfSaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointOfSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointOfSaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointOfSales
     * const pointOfSale = await prisma.pointOfSale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointOfSaleUpdateManyArgs>(args: SelectSubset<T, PointOfSaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointOfSales and returns the data updated in the database.
     * @param {PointOfSaleUpdateManyAndReturnArgs} args - Arguments to update many PointOfSales.
     * @example
     * // Update many PointOfSales
     * const pointOfSale = await prisma.pointOfSale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PointOfSales and only return the `id`
     * const pointOfSaleWithIdOnly = await prisma.pointOfSale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PointOfSaleUpdateManyAndReturnArgs>(args: SelectSubset<T, PointOfSaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PointOfSale.
     * @param {PointOfSaleUpsertArgs} args - Arguments to update or create a PointOfSale.
     * @example
     * // Update or create a PointOfSale
     * const pointOfSale = await prisma.pointOfSale.upsert({
     *   create: {
     *     // ... data to create a PointOfSale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointOfSale we want to update
     *   }
     * })
     */
    upsert<T extends PointOfSaleUpsertArgs>(args: SelectSubset<T, PointOfSaleUpsertArgs<ExtArgs>>): Prisma__PointOfSaleClient<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PointOfSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointOfSaleCountArgs} args - Arguments to filter PointOfSales to count.
     * @example
     * // Count the number of PointOfSales
     * const count = await prisma.pointOfSale.count({
     *   where: {
     *     // ... the filter for the PointOfSales we want to count
     *   }
     * })
    **/
    count<T extends PointOfSaleCountArgs>(
      args?: Subset<T, PointOfSaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointOfSaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointOfSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointOfSaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointOfSaleAggregateArgs>(args: Subset<T, PointOfSaleAggregateArgs>): Prisma.PrismaPromise<GetPointOfSaleAggregateType<T>>

    /**
     * Group by PointOfSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointOfSaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointOfSaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointOfSaleGroupByArgs['orderBy'] }
        : { orderBy?: PointOfSaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointOfSaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointOfSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointOfSale model
   */
  readonly fields: PointOfSaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointOfSale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointOfSaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staffAssigned<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointOfSale model
   */
  interface PointOfSaleFieldRefs {
    readonly id: FieldRef<"PointOfSale", 'String'>
    readonly storeId: FieldRef<"PointOfSale", 'String'>
    readonly staffAssignedId: FieldRef<"PointOfSale", 'String'>
    readonly createdAt: FieldRef<"PointOfSale", 'DateTime'>
    readonly updatedAt: FieldRef<"PointOfSale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PointOfSale findUnique
   */
  export type PointOfSaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleInclude<ExtArgs> | null
    /**
     * Filter, which PointOfSale to fetch.
     */
    where: PointOfSaleWhereUniqueInput
  }

  /**
   * PointOfSale findUniqueOrThrow
   */
  export type PointOfSaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleInclude<ExtArgs> | null
    /**
     * Filter, which PointOfSale to fetch.
     */
    where: PointOfSaleWhereUniqueInput
  }

  /**
   * PointOfSale findFirst
   */
  export type PointOfSaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleInclude<ExtArgs> | null
    /**
     * Filter, which PointOfSale to fetch.
     */
    where?: PointOfSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointOfSales to fetch.
     */
    orderBy?: PointOfSaleOrderByWithRelationInput | PointOfSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointOfSales.
     */
    cursor?: PointOfSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointOfSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointOfSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointOfSales.
     */
    distinct?: PointOfSaleScalarFieldEnum | PointOfSaleScalarFieldEnum[]
  }

  /**
   * PointOfSale findFirstOrThrow
   */
  export type PointOfSaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleInclude<ExtArgs> | null
    /**
     * Filter, which PointOfSale to fetch.
     */
    where?: PointOfSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointOfSales to fetch.
     */
    orderBy?: PointOfSaleOrderByWithRelationInput | PointOfSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointOfSales.
     */
    cursor?: PointOfSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointOfSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointOfSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointOfSales.
     */
    distinct?: PointOfSaleScalarFieldEnum | PointOfSaleScalarFieldEnum[]
  }

  /**
   * PointOfSale findMany
   */
  export type PointOfSaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleInclude<ExtArgs> | null
    /**
     * Filter, which PointOfSales to fetch.
     */
    where?: PointOfSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointOfSales to fetch.
     */
    orderBy?: PointOfSaleOrderByWithRelationInput | PointOfSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointOfSales.
     */
    cursor?: PointOfSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointOfSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointOfSales.
     */
    skip?: number
    distinct?: PointOfSaleScalarFieldEnum | PointOfSaleScalarFieldEnum[]
  }

  /**
   * PointOfSale create
   */
  export type PointOfSaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleInclude<ExtArgs> | null
    /**
     * The data needed to create a PointOfSale.
     */
    data: XOR<PointOfSaleCreateInput, PointOfSaleUncheckedCreateInput>
  }

  /**
   * PointOfSale createMany
   */
  export type PointOfSaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointOfSales.
     */
    data: PointOfSaleCreateManyInput | PointOfSaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointOfSale createManyAndReturn
   */
  export type PointOfSaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * The data used to create many PointOfSales.
     */
    data: PointOfSaleCreateManyInput | PointOfSaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointOfSale update
   */
  export type PointOfSaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleInclude<ExtArgs> | null
    /**
     * The data needed to update a PointOfSale.
     */
    data: XOR<PointOfSaleUpdateInput, PointOfSaleUncheckedUpdateInput>
    /**
     * Choose, which PointOfSale to update.
     */
    where: PointOfSaleWhereUniqueInput
  }

  /**
   * PointOfSale updateMany
   */
  export type PointOfSaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointOfSales.
     */
    data: XOR<PointOfSaleUpdateManyMutationInput, PointOfSaleUncheckedUpdateManyInput>
    /**
     * Filter which PointOfSales to update
     */
    where?: PointOfSaleWhereInput
    /**
     * Limit how many PointOfSales to update.
     */
    limit?: number
  }

  /**
   * PointOfSale updateManyAndReturn
   */
  export type PointOfSaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * The data used to update PointOfSales.
     */
    data: XOR<PointOfSaleUpdateManyMutationInput, PointOfSaleUncheckedUpdateManyInput>
    /**
     * Filter which PointOfSales to update
     */
    where?: PointOfSaleWhereInput
    /**
     * Limit how many PointOfSales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointOfSale upsert
   */
  export type PointOfSaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleInclude<ExtArgs> | null
    /**
     * The filter to search for the PointOfSale to update in case it exists.
     */
    where: PointOfSaleWhereUniqueInput
    /**
     * In case the PointOfSale found by the `where` argument doesn't exist, create a new PointOfSale with this data.
     */
    create: XOR<PointOfSaleCreateInput, PointOfSaleUncheckedCreateInput>
    /**
     * In case the PointOfSale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointOfSaleUpdateInput, PointOfSaleUncheckedUpdateInput>
  }

  /**
   * PointOfSale delete
   */
  export type PointOfSaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleInclude<ExtArgs> | null
    /**
     * Filter which PointOfSale to delete.
     */
    where: PointOfSaleWhereUniqueInput
  }

  /**
   * PointOfSale deleteMany
   */
  export type PointOfSaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointOfSales to delete
     */
    where?: PointOfSaleWhereInput
    /**
     * Limit how many PointOfSales to delete.
     */
    limit?: number
  }

  /**
   * PointOfSale without action
   */
  export type PointOfSaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    stock: number | null
    price: Decimal | null
    length: number | null
    width: number | null
    height: number | null
  }

  export type ProductSumAggregateOutputType = {
    stock: number | null
    price: Decimal | null
    length: number | null
    width: number | null
    height: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    shortDescription: string | null
    description: string | null
    sku: string | null
    stock: number | null
    price: Decimal | null
    shippingWeight: string | null
    handleTime: string | null
    freeShipping: boolean | null
    packaging: string | null
    discountPrice: string | null
    unitSold: string | null
    length: number | null
    width: number | null
    height: number | null
    productSize: string | null
    productStatus: $Enums.ProductStatus | null
    storeId: string | null
    locationId: string | null
    purchaseOrderId: string | null
    collectionId: string | null
    hasVariation: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    warehouseId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    shortDescription: string | null
    description: string | null
    sku: string | null
    stock: number | null
    price: Decimal | null
    shippingWeight: string | null
    handleTime: string | null
    freeShipping: boolean | null
    packaging: string | null
    discountPrice: string | null
    unitSold: string | null
    length: number | null
    width: number | null
    height: number | null
    productSize: string | null
    productStatus: $Enums.ProductStatus | null
    storeId: string | null
    locationId: string | null
    purchaseOrderId: string | null
    collectionId: string | null
    hasVariation: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    warehouseId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    shortDescription: number
    description: number
    sku: number
    stock: number
    price: number
    shippingWeight: number
    handleTime: number
    freeShipping: number
    packaging: number
    discountPrice: number
    unitSold: number
    length: number
    width: number
    height: number
    productSize: number
    productStatus: number
    imageUrl: number
    storeId: number
    locationId: number
    purchaseOrderId: number
    collectionId: number
    hasVariation: number
    createdAt: number
    updatedAt: number
    warehouseId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    stock?: true
    price?: true
    length?: true
    width?: true
    height?: true
  }

  export type ProductSumAggregateInputType = {
    stock?: true
    price?: true
    length?: true
    width?: true
    height?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    shortDescription?: true
    description?: true
    sku?: true
    stock?: true
    price?: true
    shippingWeight?: true
    handleTime?: true
    freeShipping?: true
    packaging?: true
    discountPrice?: true
    unitSold?: true
    length?: true
    width?: true
    height?: true
    productSize?: true
    productStatus?: true
    storeId?: true
    locationId?: true
    purchaseOrderId?: true
    collectionId?: true
    hasVariation?: true
    createdAt?: true
    updatedAt?: true
    warehouseId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    shortDescription?: true
    description?: true
    sku?: true
    stock?: true
    price?: true
    shippingWeight?: true
    handleTime?: true
    freeShipping?: true
    packaging?: true
    discountPrice?: true
    unitSold?: true
    length?: true
    width?: true
    height?: true
    productSize?: true
    productStatus?: true
    storeId?: true
    locationId?: true
    purchaseOrderId?: true
    collectionId?: true
    hasVariation?: true
    createdAt?: true
    updatedAt?: true
    warehouseId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    shortDescription?: true
    description?: true
    sku?: true
    stock?: true
    price?: true
    shippingWeight?: true
    handleTime?: true
    freeShipping?: true
    packaging?: true
    discountPrice?: true
    unitSold?: true
    length?: true
    width?: true
    height?: true
    productSize?: true
    productStatus?: true
    imageUrl?: true
    storeId?: true
    locationId?: true
    purchaseOrderId?: true
    collectionId?: true
    hasVariation?: true
    createdAt?: true
    updatedAt?: true
    warehouseId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    shortDescription: string | null
    description: string | null
    sku: string | null
    stock: number | null
    price: Decimal
    shippingWeight: string | null
    handleTime: string | null
    freeShipping: boolean | null
    packaging: string | null
    discountPrice: string | null
    unitSold: string | null
    length: number | null
    width: number | null
    height: number | null
    productSize: string | null
    productStatus: $Enums.ProductStatus | null
    imageUrl: string[]
    storeId: string
    locationId: string | null
    purchaseOrderId: string | null
    collectionId: string | null
    hasVariation: boolean | null
    createdAt: Date
    updatedAt: Date
    warehouseId: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    description?: boolean
    sku?: boolean
    stock?: boolean
    price?: boolean
    shippingWeight?: boolean
    handleTime?: boolean
    freeShipping?: boolean
    packaging?: boolean
    discountPrice?: boolean
    unitSold?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    productSize?: boolean
    productStatus?: boolean
    imageUrl?: boolean
    storeId?: boolean
    locationId?: boolean
    purchaseOrderId?: boolean
    collectionId?: boolean
    hasVariation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouseId?: boolean
    featuredBrands?: boolean | Product$featuredBrandsArgs<ExtArgs>
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    productVariation?: boolean | Product$productVariationArgs<ExtArgs>
    productCategory?: boolean | Product$productCategoryArgs<ExtArgs>
    inventoryItems?: boolean | Product$inventoryItemsArgs<ExtArgs>
    collection?: boolean | Product$collectionArgs<ExtArgs>
    purchase?: boolean | Product$purchaseArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    warehouse?: boolean | Product$warehouseArgs<ExtArgs>
    location?: boolean | Product$locationArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    description?: boolean
    sku?: boolean
    stock?: boolean
    price?: boolean
    shippingWeight?: boolean
    handleTime?: boolean
    freeShipping?: boolean
    packaging?: boolean
    discountPrice?: boolean
    unitSold?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    productSize?: boolean
    productStatus?: boolean
    imageUrl?: boolean
    storeId?: boolean
    locationId?: boolean
    purchaseOrderId?: boolean
    collectionId?: boolean
    hasVariation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouseId?: boolean
    collection?: boolean | Product$collectionArgs<ExtArgs>
    purchase?: boolean | Product$purchaseArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    warehouse?: boolean | Product$warehouseArgs<ExtArgs>
    location?: boolean | Product$locationArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    description?: boolean
    sku?: boolean
    stock?: boolean
    price?: boolean
    shippingWeight?: boolean
    handleTime?: boolean
    freeShipping?: boolean
    packaging?: boolean
    discountPrice?: boolean
    unitSold?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    productSize?: boolean
    productStatus?: boolean
    imageUrl?: boolean
    storeId?: boolean
    locationId?: boolean
    purchaseOrderId?: boolean
    collectionId?: boolean
    hasVariation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouseId?: boolean
    collection?: boolean | Product$collectionArgs<ExtArgs>
    purchase?: boolean | Product$purchaseArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    warehouse?: boolean | Product$warehouseArgs<ExtArgs>
    location?: boolean | Product$locationArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    description?: boolean
    sku?: boolean
    stock?: boolean
    price?: boolean
    shippingWeight?: boolean
    handleTime?: boolean
    freeShipping?: boolean
    packaging?: boolean
    discountPrice?: boolean
    unitSold?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    productSize?: boolean
    productStatus?: boolean
    imageUrl?: boolean
    storeId?: boolean
    locationId?: boolean
    purchaseOrderId?: boolean
    collectionId?: boolean
    hasVariation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouseId?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "shortDescription" | "description" | "sku" | "stock" | "price" | "shippingWeight" | "handleTime" | "freeShipping" | "packaging" | "discountPrice" | "unitSold" | "length" | "width" | "height" | "productSize" | "productStatus" | "imageUrl" | "storeId" | "locationId" | "purchaseOrderId" | "collectionId" | "hasVariation" | "createdAt" | "updatedAt" | "warehouseId", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    featuredBrands?: boolean | Product$featuredBrandsArgs<ExtArgs>
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    productVariation?: boolean | Product$productVariationArgs<ExtArgs>
    productCategory?: boolean | Product$productCategoryArgs<ExtArgs>
    inventoryItems?: boolean | Product$inventoryItemsArgs<ExtArgs>
    collection?: boolean | Product$collectionArgs<ExtArgs>
    purchase?: boolean | Product$purchaseArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    warehouse?: boolean | Product$warehouseArgs<ExtArgs>
    location?: boolean | Product$locationArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | Product$collectionArgs<ExtArgs>
    purchase?: boolean | Product$purchaseArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    warehouse?: boolean | Product$warehouseArgs<ExtArgs>
    location?: boolean | Product$locationArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | Product$collectionArgs<ExtArgs>
    purchase?: boolean | Product$purchaseArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    warehouse?: boolean | Product$warehouseArgs<ExtArgs>
    location?: boolean | Product$locationArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      featuredBrands: Prisma.$FeaturedBrandsPayload<ExtArgs>[]
      cartItems: Prisma.$CartItemPayload<ExtArgs>[]
      productVariation: Prisma.$ProductVariationPayload<ExtArgs>[]
      productCategory: Prisma.$ProductCategoryPayload<ExtArgs>[]
      inventoryItems: Prisma.$InventoryPayload<ExtArgs>[]
      collection: Prisma.$ProductCollectionPayload<ExtArgs> | null
      purchase: Prisma.$PurchasePayload<ExtArgs> | null
      store: Prisma.$OrganizationPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      shortDescription: string | null
      description: string | null
      sku: string | null
      stock: number | null
      price: Prisma.Decimal
      shippingWeight: string | null
      handleTime: string | null
      freeShipping: boolean | null
      packaging: string | null
      discountPrice: string | null
      unitSold: string | null
      length: number | null
      width: number | null
      height: number | null
      productSize: string | null
      productStatus: $Enums.ProductStatus | null
      imageUrl: string[]
      storeId: string
      locationId: string | null
      purchaseOrderId: string | null
      collectionId: string | null
      hasVariation: boolean | null
      createdAt: Date
      updatedAt: Date
      warehouseId: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    featuredBrands<T extends Product$featuredBrandsArgs<ExtArgs> = {}>(args?: Subset<T, Product$featuredBrandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedBrandsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cartItems<T extends Product$cartItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productVariation<T extends Product$productVariationArgs<ExtArgs> = {}>(args?: Subset<T, Product$productVariationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productCategory<T extends Product$productCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$productCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryItems<T extends Product$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collection<T extends Product$collectionArgs<ExtArgs> = {}>(args?: Subset<T, Product$collectionArgs<ExtArgs>>): Prisma__ProductCollectionClient<$Result.GetResult<Prisma.$ProductCollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchase<T extends Product$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchaseArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends Product$warehouseArgs<ExtArgs> = {}>(args?: Subset<T, Product$warehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends Product$locationArgs<ExtArgs> = {}>(args?: Subset<T, Product$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly shortDescription: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly shippingWeight: FieldRef<"Product", 'String'>
    readonly handleTime: FieldRef<"Product", 'String'>
    readonly freeShipping: FieldRef<"Product", 'Boolean'>
    readonly packaging: FieldRef<"Product", 'String'>
    readonly discountPrice: FieldRef<"Product", 'String'>
    readonly unitSold: FieldRef<"Product", 'String'>
    readonly length: FieldRef<"Product", 'Float'>
    readonly width: FieldRef<"Product", 'Float'>
    readonly height: FieldRef<"Product", 'Float'>
    readonly productSize: FieldRef<"Product", 'String'>
    readonly productStatus: FieldRef<"Product", 'ProductStatus'>
    readonly imageUrl: FieldRef<"Product", 'String[]'>
    readonly storeId: FieldRef<"Product", 'String'>
    readonly locationId: FieldRef<"Product", 'String'>
    readonly purchaseOrderId: FieldRef<"Product", 'String'>
    readonly collectionId: FieldRef<"Product", 'String'>
    readonly hasVariation: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly warehouseId: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.featuredBrands
   */
  export type Product$featuredBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsInclude<ExtArgs> | null
    where?: FeaturedBrandsWhereInput
    orderBy?: FeaturedBrandsOrderByWithRelationInput | FeaturedBrandsOrderByWithRelationInput[]
    cursor?: FeaturedBrandsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeaturedBrandsScalarFieldEnum | FeaturedBrandsScalarFieldEnum[]
  }

  /**
   * Product.cartItems
   */
  export type Product$cartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Product.productVariation
   */
  export type Product$productVariationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    where?: ProductVariationWhereInput
    orderBy?: ProductVariationOrderByWithRelationInput | ProductVariationOrderByWithRelationInput[]
    cursor?: ProductVariationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductVariationScalarFieldEnum | ProductVariationScalarFieldEnum[]
  }

  /**
   * Product.productCategory
   */
  export type Product$productCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Product.inventoryItems
   */
  export type Product$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Product.collection
   */
  export type Product$collectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCollectionInclude<ExtArgs> | null
    where?: ProductCollectionWhereInput
  }

  /**
   * Product.purchase
   */
  export type Product$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
  }

  /**
   * Product.warehouse
   */
  export type Product$warehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * Product.location
   */
  export type Product$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    storeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: string
    name: string | null
    description: string | null
    storeId: string
    createdAt: Date
    updatedAt: Date
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductCategory$productArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "storeId" | "createdAt" | "updatedAt", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductCategory$productArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>[]
      store: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      description: string | null
      storeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories and returns the data updated in the database.
     * @param {ProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductCategories.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductCategory$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'String'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly description: FieldRef<"ProductCategory", 'String'>
    readonly storeId: FieldRef<"ProductCategory", 'String'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory updateManyAndReturn
   */
  export type ProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.product
   */
  export type ProductCategory$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductCollection
   */

  export type AggregateProductCollection = {
    _count: ProductCollectionCountAggregateOutputType | null
    _min: ProductCollectionMinAggregateOutputType | null
    _max: ProductCollectionMaxAggregateOutputType | null
  }

  export type ProductCollectionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCollectionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCollectionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCollectionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCollectionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCollectionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCollectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCollection to aggregate.
     */
    where?: ProductCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCollections to fetch.
     */
    orderBy?: ProductCollectionOrderByWithRelationInput | ProductCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCollections
    **/
    _count?: true | ProductCollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCollectionMaxAggregateInputType
  }

  export type GetProductCollectionAggregateType<T extends ProductCollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCollection[P]>
      : GetScalarType<T[P], AggregateProductCollection[P]>
  }




  export type ProductCollectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCollectionWhereInput
    orderBy?: ProductCollectionOrderByWithAggregationInput | ProductCollectionOrderByWithAggregationInput[]
    by: ProductCollectionScalarFieldEnum[] | ProductCollectionScalarFieldEnum
    having?: ProductCollectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCollectionCountAggregateInputType | true
    _min?: ProductCollectionMinAggregateInputType
    _max?: ProductCollectionMaxAggregateInputType
  }

  export type ProductCollectionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCollectionCountAggregateOutputType | null
    _min: ProductCollectionMinAggregateOutputType | null
    _max: ProductCollectionMaxAggregateOutputType | null
  }

  type GetProductCollectionGroupByPayload<T extends ProductCollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCollectionGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCollectionGroupByOutputType[P]>
        }
      >
    >


  export type ProductCollectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | ProductCollection$productsArgs<ExtArgs>
    _count?: boolean | ProductCollectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCollection"]>

  export type ProductCollectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["productCollection"]>

  export type ProductCollectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["productCollection"]>

  export type ProductCollectionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductCollectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["productCollection"]>
  export type ProductCollectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductCollection$productsArgs<ExtArgs>
    _count?: boolean | ProductCollectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCollectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductCollectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductCollectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCollection"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productCollection"]>
    composites: {}
  }

  type ProductCollectionGetPayload<S extends boolean | null | undefined | ProductCollectionDefaultArgs> = $Result.GetResult<Prisma.$ProductCollectionPayload, S>

  type ProductCollectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCollectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCollectionCountAggregateInputType | true
    }

  export interface ProductCollectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCollection'], meta: { name: 'ProductCollection' } }
    /**
     * Find zero or one ProductCollection that matches the filter.
     * @param {ProductCollectionFindUniqueArgs} args - Arguments to find a ProductCollection
     * @example
     * // Get one ProductCollection
     * const productCollection = await prisma.productCollection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCollectionFindUniqueArgs>(args: SelectSubset<T, ProductCollectionFindUniqueArgs<ExtArgs>>): Prisma__ProductCollectionClient<$Result.GetResult<Prisma.$ProductCollectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCollection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCollectionFindUniqueOrThrowArgs} args - Arguments to find a ProductCollection
     * @example
     * // Get one ProductCollection
     * const productCollection = await prisma.productCollection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCollectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCollectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCollectionClient<$Result.GetResult<Prisma.$ProductCollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCollection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCollectionFindFirstArgs} args - Arguments to find a ProductCollection
     * @example
     * // Get one ProductCollection
     * const productCollection = await prisma.productCollection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCollectionFindFirstArgs>(args?: SelectSubset<T, ProductCollectionFindFirstArgs<ExtArgs>>): Prisma__ProductCollectionClient<$Result.GetResult<Prisma.$ProductCollectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCollection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCollectionFindFirstOrThrowArgs} args - Arguments to find a ProductCollection
     * @example
     * // Get one ProductCollection
     * const productCollection = await prisma.productCollection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCollectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCollectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCollectionClient<$Result.GetResult<Prisma.$ProductCollectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCollections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCollectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCollections
     * const productCollections = await prisma.productCollection.findMany()
     * 
     * // Get first 10 ProductCollections
     * const productCollections = await prisma.productCollection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCollectionWithIdOnly = await prisma.productCollection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCollectionFindManyArgs>(args?: SelectSubset<T, ProductCollectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCollection.
     * @param {ProductCollectionCreateArgs} args - Arguments to create a ProductCollection.
     * @example
     * // Create one ProductCollection
     * const ProductCollection = await prisma.productCollection.create({
     *   data: {
     *     // ... data to create a ProductCollection
     *   }
     * })
     * 
     */
    create<T extends ProductCollectionCreateArgs>(args: SelectSubset<T, ProductCollectionCreateArgs<ExtArgs>>): Prisma__ProductCollectionClient<$Result.GetResult<Prisma.$ProductCollectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCollections.
     * @param {ProductCollectionCreateManyArgs} args - Arguments to create many ProductCollections.
     * @example
     * // Create many ProductCollections
     * const productCollection = await prisma.productCollection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCollectionCreateManyArgs>(args?: SelectSubset<T, ProductCollectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCollections and returns the data saved in the database.
     * @param {ProductCollectionCreateManyAndReturnArgs} args - Arguments to create many ProductCollections.
     * @example
     * // Create many ProductCollections
     * const productCollection = await prisma.productCollection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCollections and only return the `id`
     * const productCollectionWithIdOnly = await prisma.productCollection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCollectionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCollectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCollectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCollection.
     * @param {ProductCollectionDeleteArgs} args - Arguments to delete one ProductCollection.
     * @example
     * // Delete one ProductCollection
     * const ProductCollection = await prisma.productCollection.delete({
     *   where: {
     *     // ... filter to delete one ProductCollection
     *   }
     * })
     * 
     */
    delete<T extends ProductCollectionDeleteArgs>(args: SelectSubset<T, ProductCollectionDeleteArgs<ExtArgs>>): Prisma__ProductCollectionClient<$Result.GetResult<Prisma.$ProductCollectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCollection.
     * @param {ProductCollectionUpdateArgs} args - Arguments to update one ProductCollection.
     * @example
     * // Update one ProductCollection
     * const productCollection = await prisma.productCollection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCollectionUpdateArgs>(args: SelectSubset<T, ProductCollectionUpdateArgs<ExtArgs>>): Prisma__ProductCollectionClient<$Result.GetResult<Prisma.$ProductCollectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCollections.
     * @param {ProductCollectionDeleteManyArgs} args - Arguments to filter ProductCollections to delete.
     * @example
     * // Delete a few ProductCollections
     * const { count } = await prisma.productCollection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCollectionDeleteManyArgs>(args?: SelectSubset<T, ProductCollectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCollections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCollectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCollections
     * const productCollection = await prisma.productCollection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCollectionUpdateManyArgs>(args: SelectSubset<T, ProductCollectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCollections and returns the data updated in the database.
     * @param {ProductCollectionUpdateManyAndReturnArgs} args - Arguments to update many ProductCollections.
     * @example
     * // Update many ProductCollections
     * const productCollection = await prisma.productCollection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCollections and only return the `id`
     * const productCollectionWithIdOnly = await prisma.productCollection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCollectionUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCollectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCollectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCollection.
     * @param {ProductCollectionUpsertArgs} args - Arguments to update or create a ProductCollection.
     * @example
     * // Update or create a ProductCollection
     * const productCollection = await prisma.productCollection.upsert({
     *   create: {
     *     // ... data to create a ProductCollection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCollection we want to update
     *   }
     * })
     */
    upsert<T extends ProductCollectionUpsertArgs>(args: SelectSubset<T, ProductCollectionUpsertArgs<ExtArgs>>): Prisma__ProductCollectionClient<$Result.GetResult<Prisma.$ProductCollectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCollections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCollectionCountArgs} args - Arguments to filter ProductCollections to count.
     * @example
     * // Count the number of ProductCollections
     * const count = await prisma.productCollection.count({
     *   where: {
     *     // ... the filter for the ProductCollections we want to count
     *   }
     * })
    **/
    count<T extends ProductCollectionCountArgs>(
      args?: Subset<T, ProductCollectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCollection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCollectionAggregateArgs>(args: Subset<T, ProductCollectionAggregateArgs>): Prisma.PrismaPromise<GetProductCollectionAggregateType<T>>

    /**
     * Group by ProductCollection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCollectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCollectionGroupByArgs['orderBy'] }
        : { orderBy?: ProductCollectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCollectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCollection model
   */
  readonly fields: ProductCollectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCollection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCollectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends ProductCollection$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCollection$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCollection model
   */
  interface ProductCollectionFieldRefs {
    readonly id: FieldRef<"ProductCollection", 'String'>
    readonly name: FieldRef<"ProductCollection", 'String'>
    readonly description: FieldRef<"ProductCollection", 'String'>
    readonly createdAt: FieldRef<"ProductCollection", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCollection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCollection findUnique
   */
  export type ProductCollectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCollectionInclude<ExtArgs> | null
    /**
     * Filter, which ProductCollection to fetch.
     */
    where: ProductCollectionWhereUniqueInput
  }

  /**
   * ProductCollection findUniqueOrThrow
   */
  export type ProductCollectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCollectionInclude<ExtArgs> | null
    /**
     * Filter, which ProductCollection to fetch.
     */
    where: ProductCollectionWhereUniqueInput
  }

  /**
   * ProductCollection findFirst
   */
  export type ProductCollectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCollectionInclude<ExtArgs> | null
    /**
     * Filter, which ProductCollection to fetch.
     */
    where?: ProductCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCollections to fetch.
     */
    orderBy?: ProductCollectionOrderByWithRelationInput | ProductCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCollections.
     */
    cursor?: ProductCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCollections.
     */
    distinct?: ProductCollectionScalarFieldEnum | ProductCollectionScalarFieldEnum[]
  }

  /**
   * ProductCollection findFirstOrThrow
   */
  export type ProductCollectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCollectionInclude<ExtArgs> | null
    /**
     * Filter, which ProductCollection to fetch.
     */
    where?: ProductCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCollections to fetch.
     */
    orderBy?: ProductCollectionOrderByWithRelationInput | ProductCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCollections.
     */
    cursor?: ProductCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCollections.
     */
    distinct?: ProductCollectionScalarFieldEnum | ProductCollectionScalarFieldEnum[]
  }

  /**
   * ProductCollection findMany
   */
  export type ProductCollectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCollectionInclude<ExtArgs> | null
    /**
     * Filter, which ProductCollections to fetch.
     */
    where?: ProductCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCollections to fetch.
     */
    orderBy?: ProductCollectionOrderByWithRelationInput | ProductCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCollections.
     */
    cursor?: ProductCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCollections.
     */
    skip?: number
    distinct?: ProductCollectionScalarFieldEnum | ProductCollectionScalarFieldEnum[]
  }

  /**
   * ProductCollection create
   */
  export type ProductCollectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCollectionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCollection.
     */
    data: XOR<ProductCollectionCreateInput, ProductCollectionUncheckedCreateInput>
  }

  /**
   * ProductCollection createMany
   */
  export type ProductCollectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCollections.
     */
    data: ProductCollectionCreateManyInput | ProductCollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCollection createManyAndReturn
   */
  export type ProductCollectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCollections.
     */
    data: ProductCollectionCreateManyInput | ProductCollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCollection update
   */
  export type ProductCollectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCollectionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCollection.
     */
    data: XOR<ProductCollectionUpdateInput, ProductCollectionUncheckedUpdateInput>
    /**
     * Choose, which ProductCollection to update.
     */
    where: ProductCollectionWhereUniqueInput
  }

  /**
   * ProductCollection updateMany
   */
  export type ProductCollectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCollections.
     */
    data: XOR<ProductCollectionUpdateManyMutationInput, ProductCollectionUncheckedUpdateManyInput>
    /**
     * Filter which ProductCollections to update
     */
    where?: ProductCollectionWhereInput
    /**
     * Limit how many ProductCollections to update.
     */
    limit?: number
  }

  /**
   * ProductCollection updateManyAndReturn
   */
  export type ProductCollectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * The data used to update ProductCollections.
     */
    data: XOR<ProductCollectionUpdateManyMutationInput, ProductCollectionUncheckedUpdateManyInput>
    /**
     * Filter which ProductCollections to update
     */
    where?: ProductCollectionWhereInput
    /**
     * Limit how many ProductCollections to update.
     */
    limit?: number
  }

  /**
   * ProductCollection upsert
   */
  export type ProductCollectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCollectionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCollection to update in case it exists.
     */
    where: ProductCollectionWhereUniqueInput
    /**
     * In case the ProductCollection found by the `where` argument doesn't exist, create a new ProductCollection with this data.
     */
    create: XOR<ProductCollectionCreateInput, ProductCollectionUncheckedCreateInput>
    /**
     * In case the ProductCollection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCollectionUpdateInput, ProductCollectionUncheckedUpdateInput>
  }

  /**
   * ProductCollection delete
   */
  export type ProductCollectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCollectionInclude<ExtArgs> | null
    /**
     * Filter which ProductCollection to delete.
     */
    where: ProductCollectionWhereUniqueInput
  }

  /**
   * ProductCollection deleteMany
   */
  export type ProductCollectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCollections to delete
     */
    where?: ProductCollectionWhereInput
    /**
     * Limit how many ProductCollections to delete.
     */
    limit?: number
  }

  /**
   * ProductCollection.products
   */
  export type ProductCollection$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCollection without action
   */
  export type ProductCollectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCollection
     */
    select?: ProductCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCollection
     */
    omit?: ProductCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCollectionInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariation
   */

  export type AggregateProductVariation = {
    _count: ProductVariationCountAggregateOutputType | null
    _avg: ProductVariationAvgAggregateOutputType | null
    _sum: ProductVariationSumAggregateOutputType | null
    _min: ProductVariationMinAggregateOutputType | null
    _max: ProductVariationMaxAggregateOutputType | null
  }

  export type ProductVariationAvgAggregateOutputType = {
    price: number | null
    cost: number | null
    discountPrice: number | null
    stock: number | null
  }

  export type ProductVariationSumAggregateOutputType = {
    price: number | null
    cost: number | null
    discountPrice: number | null
    stock: number | null
  }

  export type ProductVariationMinAggregateOutputType = {
    id: string | null
    productId: string | null
    sku: string | null
    price: number | null
    cost: number | null
    discountPrice: number | null
    stock: number | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariationMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    sku: string | null
    price: number | null
    cost: number | null
    discountPrice: number | null
    stock: number | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariationCountAggregateOutputType = {
    id: number
    productId: number
    sku: number
    price: number
    cost: number
    discountPrice: number
    stock: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVariationAvgAggregateInputType = {
    price?: true
    cost?: true
    discountPrice?: true
    stock?: true
  }

  export type ProductVariationSumAggregateInputType = {
    price?: true
    cost?: true
    discountPrice?: true
    stock?: true
  }

  export type ProductVariationMinAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    price?: true
    cost?: true
    discountPrice?: true
    stock?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariationMaxAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    price?: true
    cost?: true
    discountPrice?: true
    stock?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariationCountAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    price?: true
    cost?: true
    discountPrice?: true
    stock?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVariationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariation to aggregate.
     */
    where?: ProductVariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariations to fetch.
     */
    orderBy?: ProductVariationOrderByWithRelationInput | ProductVariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariations
    **/
    _count?: true | ProductVariationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductVariationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductVariationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariationMaxAggregateInputType
  }

  export type GetProductVariationAggregateType<T extends ProductVariationAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariation[P]>
      : GetScalarType<T[P], AggregateProductVariation[P]>
  }




  export type ProductVariationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariationWhereInput
    orderBy?: ProductVariationOrderByWithAggregationInput | ProductVariationOrderByWithAggregationInput[]
    by: ProductVariationScalarFieldEnum[] | ProductVariationScalarFieldEnum
    having?: ProductVariationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariationCountAggregateInputType | true
    _avg?: ProductVariationAvgAggregateInputType
    _sum?: ProductVariationSumAggregateInputType
    _min?: ProductVariationMinAggregateInputType
    _max?: ProductVariationMaxAggregateInputType
  }

  export type ProductVariationGroupByOutputType = {
    id: string
    productId: string
    sku: string
    price: number
    cost: number | null
    discountPrice: number | null
    stock: number
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductVariationCountAggregateOutputType | null
    _avg: ProductVariationAvgAggregateOutputType | null
    _sum: ProductVariationSumAggregateOutputType | null
    _min: ProductVariationMinAggregateOutputType | null
    _max: ProductVariationMaxAggregateOutputType | null
  }

  type GetProductVariationGroupByPayload<T extends ProductVariationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariationGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariationGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    price?: boolean
    cost?: boolean
    discountPrice?: boolean
    stock?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    options?: boolean | ProductVariation$optionsArgs<ExtArgs>
    _count?: boolean | ProductVariationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariation"]>

  export type ProductVariationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    price?: boolean
    cost?: boolean
    discountPrice?: boolean
    stock?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariation"]>

  export type ProductVariationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    price?: boolean
    cost?: boolean
    discountPrice?: boolean
    stock?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariation"]>

  export type ProductVariationSelectScalar = {
    id?: boolean
    productId?: boolean
    sku?: boolean
    price?: boolean
    cost?: boolean
    discountPrice?: boolean
    stock?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductVariationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "sku" | "price" | "cost" | "discountPrice" | "stock" | "imageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["productVariation"]>
  export type ProductVariationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    options?: boolean | ProductVariation$optionsArgs<ExtArgs>
    _count?: boolean | ProductVariationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductVariationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductVariationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductVariationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariation"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      options: Prisma.$ProductVariationOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      sku: string
      price: number
      cost: number | null
      discountPrice: number | null
      stock: number
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productVariation"]>
    composites: {}
  }

  type ProductVariationGetPayload<S extends boolean | null | undefined | ProductVariationDefaultArgs> = $Result.GetResult<Prisma.$ProductVariationPayload, S>

  type ProductVariationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductVariationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductVariationCountAggregateInputType | true
    }

  export interface ProductVariationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariation'], meta: { name: 'ProductVariation' } }
    /**
     * Find zero or one ProductVariation that matches the filter.
     * @param {ProductVariationFindUniqueArgs} args - Arguments to find a ProductVariation
     * @example
     * // Get one ProductVariation
     * const productVariation = await prisma.productVariation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariationFindUniqueArgs>(args: SelectSubset<T, ProductVariationFindUniqueArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductVariation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductVariationFindUniqueOrThrowArgs} args - Arguments to find a ProductVariation
     * @example
     * // Get one ProductVariation
     * const productVariation = await prisma.productVariation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationFindFirstArgs} args - Arguments to find a ProductVariation
     * @example
     * // Get one ProductVariation
     * const productVariation = await prisma.productVariation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariationFindFirstArgs>(args?: SelectSubset<T, ProductVariationFindFirstArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationFindFirstOrThrowArgs} args - Arguments to find a ProductVariation
     * @example
     * // Get one ProductVariation
     * const productVariation = await prisma.productVariation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductVariations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariations
     * const productVariations = await prisma.productVariation.findMany()
     * 
     * // Get first 10 ProductVariations
     * const productVariations = await prisma.productVariation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariationWithIdOnly = await prisma.productVariation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariationFindManyArgs>(args?: SelectSubset<T, ProductVariationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductVariation.
     * @param {ProductVariationCreateArgs} args - Arguments to create a ProductVariation.
     * @example
     * // Create one ProductVariation
     * const ProductVariation = await prisma.productVariation.create({
     *   data: {
     *     // ... data to create a ProductVariation
     *   }
     * })
     * 
     */
    create<T extends ProductVariationCreateArgs>(args: SelectSubset<T, ProductVariationCreateArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductVariations.
     * @param {ProductVariationCreateManyArgs} args - Arguments to create many ProductVariations.
     * @example
     * // Create many ProductVariations
     * const productVariation = await prisma.productVariation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariationCreateManyArgs>(args?: SelectSubset<T, ProductVariationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductVariations and returns the data saved in the database.
     * @param {ProductVariationCreateManyAndReturnArgs} args - Arguments to create many ProductVariations.
     * @example
     * // Create many ProductVariations
     * const productVariation = await prisma.productVariation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductVariations and only return the `id`
     * const productVariationWithIdOnly = await prisma.productVariation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductVariationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductVariationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductVariation.
     * @param {ProductVariationDeleteArgs} args - Arguments to delete one ProductVariation.
     * @example
     * // Delete one ProductVariation
     * const ProductVariation = await prisma.productVariation.delete({
     *   where: {
     *     // ... filter to delete one ProductVariation
     *   }
     * })
     * 
     */
    delete<T extends ProductVariationDeleteArgs>(args: SelectSubset<T, ProductVariationDeleteArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductVariation.
     * @param {ProductVariationUpdateArgs} args - Arguments to update one ProductVariation.
     * @example
     * // Update one ProductVariation
     * const productVariation = await prisma.productVariation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariationUpdateArgs>(args: SelectSubset<T, ProductVariationUpdateArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductVariations.
     * @param {ProductVariationDeleteManyArgs} args - Arguments to filter ProductVariations to delete.
     * @example
     * // Delete a few ProductVariations
     * const { count } = await prisma.productVariation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariationDeleteManyArgs>(args?: SelectSubset<T, ProductVariationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariations
     * const productVariation = await prisma.productVariation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariationUpdateManyArgs>(args: SelectSubset<T, ProductVariationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariations and returns the data updated in the database.
     * @param {ProductVariationUpdateManyAndReturnArgs} args - Arguments to update many ProductVariations.
     * @example
     * // Update many ProductVariations
     * const productVariation = await prisma.productVariation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductVariations and only return the `id`
     * const productVariationWithIdOnly = await prisma.productVariation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductVariationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductVariationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductVariation.
     * @param {ProductVariationUpsertArgs} args - Arguments to update or create a ProductVariation.
     * @example
     * // Update or create a ProductVariation
     * const productVariation = await prisma.productVariation.upsert({
     *   create: {
     *     // ... data to create a ProductVariation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariation we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariationUpsertArgs>(args: SelectSubset<T, ProductVariationUpsertArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductVariations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationCountArgs} args - Arguments to filter ProductVariations to count.
     * @example
     * // Count the number of ProductVariations
     * const count = await prisma.productVariation.count({
     *   where: {
     *     // ... the filter for the ProductVariations we want to count
     *   }
     * })
    **/
    count<T extends ProductVariationCountArgs>(
      args?: Subset<T, ProductVariationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariationAggregateArgs>(args: Subset<T, ProductVariationAggregateArgs>): Prisma.PrismaPromise<GetProductVariationAggregateType<T>>

    /**
     * Group by ProductVariation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariationGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariation model
   */
  readonly fields: ProductVariationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    options<T extends ProductVariation$optionsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariation$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariation model
   */
  interface ProductVariationFieldRefs {
    readonly id: FieldRef<"ProductVariation", 'String'>
    readonly productId: FieldRef<"ProductVariation", 'String'>
    readonly sku: FieldRef<"ProductVariation", 'String'>
    readonly price: FieldRef<"ProductVariation", 'Float'>
    readonly cost: FieldRef<"ProductVariation", 'Float'>
    readonly discountPrice: FieldRef<"ProductVariation", 'Float'>
    readonly stock: FieldRef<"ProductVariation", 'Int'>
    readonly imageUrl: FieldRef<"ProductVariation", 'String'>
    readonly createdAt: FieldRef<"ProductVariation", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariation findUnique
   */
  export type ProductVariationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariation to fetch.
     */
    where: ProductVariationWhereUniqueInput
  }

  /**
   * ProductVariation findUniqueOrThrow
   */
  export type ProductVariationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariation to fetch.
     */
    where: ProductVariationWhereUniqueInput
  }

  /**
   * ProductVariation findFirst
   */
  export type ProductVariationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariation to fetch.
     */
    where?: ProductVariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariations to fetch.
     */
    orderBy?: ProductVariationOrderByWithRelationInput | ProductVariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariations.
     */
    cursor?: ProductVariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariations.
     */
    distinct?: ProductVariationScalarFieldEnum | ProductVariationScalarFieldEnum[]
  }

  /**
   * ProductVariation findFirstOrThrow
   */
  export type ProductVariationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariation to fetch.
     */
    where?: ProductVariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariations to fetch.
     */
    orderBy?: ProductVariationOrderByWithRelationInput | ProductVariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariations.
     */
    cursor?: ProductVariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariations.
     */
    distinct?: ProductVariationScalarFieldEnum | ProductVariationScalarFieldEnum[]
  }

  /**
   * ProductVariation findMany
   */
  export type ProductVariationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariations to fetch.
     */
    where?: ProductVariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariations to fetch.
     */
    orderBy?: ProductVariationOrderByWithRelationInput | ProductVariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariations.
     */
    cursor?: ProductVariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariations.
     */
    skip?: number
    distinct?: ProductVariationScalarFieldEnum | ProductVariationScalarFieldEnum[]
  }

  /**
   * ProductVariation create
   */
  export type ProductVariationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariation.
     */
    data: XOR<ProductVariationCreateInput, ProductVariationUncheckedCreateInput>
  }

  /**
   * ProductVariation createMany
   */
  export type ProductVariationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariations.
     */
    data: ProductVariationCreateManyInput | ProductVariationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVariation createManyAndReturn
   */
  export type ProductVariationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * The data used to create many ProductVariations.
     */
    data: ProductVariationCreateManyInput | ProductVariationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariation update
   */
  export type ProductVariationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariation.
     */
    data: XOR<ProductVariationUpdateInput, ProductVariationUncheckedUpdateInput>
    /**
     * Choose, which ProductVariation to update.
     */
    where: ProductVariationWhereUniqueInput
  }

  /**
   * ProductVariation updateMany
   */
  export type ProductVariationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariations.
     */
    data: XOR<ProductVariationUpdateManyMutationInput, ProductVariationUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariations to update
     */
    where?: ProductVariationWhereInput
    /**
     * Limit how many ProductVariations to update.
     */
    limit?: number
  }

  /**
   * ProductVariation updateManyAndReturn
   */
  export type ProductVariationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * The data used to update ProductVariations.
     */
    data: XOR<ProductVariationUpdateManyMutationInput, ProductVariationUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariations to update
     */
    where?: ProductVariationWhereInput
    /**
     * Limit how many ProductVariations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariation upsert
   */
  export type ProductVariationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariation to update in case it exists.
     */
    where: ProductVariationWhereUniqueInput
    /**
     * In case the ProductVariation found by the `where` argument doesn't exist, create a new ProductVariation with this data.
     */
    create: XOR<ProductVariationCreateInput, ProductVariationUncheckedCreateInput>
    /**
     * In case the ProductVariation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariationUpdateInput, ProductVariationUncheckedUpdateInput>
  }

  /**
   * ProductVariation delete
   */
  export type ProductVariationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
    /**
     * Filter which ProductVariation to delete.
     */
    where: ProductVariationWhereUniqueInput
  }

  /**
   * ProductVariation deleteMany
   */
  export type ProductVariationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariations to delete
     */
    where?: ProductVariationWhereInput
    /**
     * Limit how many ProductVariations to delete.
     */
    limit?: number
  }

  /**
   * ProductVariation.options
   */
  export type ProductVariation$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionInclude<ExtArgs> | null
    where?: ProductVariationOptionWhereInput
    orderBy?: ProductVariationOptionOrderByWithRelationInput | ProductVariationOptionOrderByWithRelationInput[]
    cursor?: ProductVariationOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductVariationOptionScalarFieldEnum | ProductVariationOptionScalarFieldEnum[]
  }

  /**
   * ProductVariation without action
   */
  export type ProductVariationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariation
     */
    select?: ProductVariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariation
     */
    omit?: ProductVariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariant
   */

  export type AggregateProductVariant = {
    _count: ProductVariantCountAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  export type ProductVariantMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVariantMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariant to aggregate.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariants
    **/
    _count?: true | ProductVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariantMaxAggregateInputType
  }

  export type GetProductVariantAggregateType<T extends ProductVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariant[P]>
      : GetScalarType<T[P], AggregateProductVariant[P]>
  }




  export type ProductVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithAggregationInput | ProductVariantOrderByWithAggregationInput[]
    by: ProductVariantScalarFieldEnum[] | ProductVariantScalarFieldEnum
    having?: ProductVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariantCountAggregateInputType | true
    _min?: ProductVariantMinAggregateInputType
    _max?: ProductVariantMaxAggregateInputType
  }

  export type ProductVariantGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ProductVariantCountAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  type GetProductVariantGroupByPayload<T extends ProductVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    values?: boolean | ProductVariant$valuesArgs<ExtArgs>
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["productVariant"]>
  export type ProductVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | ProductVariant$valuesArgs<ExtArgs>
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductVariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductVariantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariant"
    objects: {
      values: Prisma.$ProductVariantValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productVariant"]>
    composites: {}
  }

  type ProductVariantGetPayload<S extends boolean | null | undefined | ProductVariantDefaultArgs> = $Result.GetResult<Prisma.$ProductVariantPayload, S>

  type ProductVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductVariantCountAggregateInputType | true
    }

  export interface ProductVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariant'], meta: { name: 'ProductVariant' } }
    /**
     * Find zero or one ProductVariant that matches the filter.
     * @param {ProductVariantFindUniqueArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariantFindUniqueArgs>(args: SelectSubset<T, ProductVariantFindUniqueArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductVariantFindUniqueOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariantFindFirstArgs>(args?: SelectSubset<T, ProductVariantFindFirstArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariants
     * const productVariants = await prisma.productVariant.findMany()
     * 
     * // Get first 10 ProductVariants
     * const productVariants = await prisma.productVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariantFindManyArgs>(args?: SelectSubset<T, ProductVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductVariant.
     * @param {ProductVariantCreateArgs} args - Arguments to create a ProductVariant.
     * @example
     * // Create one ProductVariant
     * const ProductVariant = await prisma.productVariant.create({
     *   data: {
     *     // ... data to create a ProductVariant
     *   }
     * })
     * 
     */
    create<T extends ProductVariantCreateArgs>(args: SelectSubset<T, ProductVariantCreateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductVariants.
     * @param {ProductVariantCreateManyArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariantCreateManyArgs>(args?: SelectSubset<T, ProductVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductVariants and returns the data saved in the database.
     * @param {ProductVariantCreateManyAndReturnArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductVariantCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductVariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductVariant.
     * @param {ProductVariantDeleteArgs} args - Arguments to delete one ProductVariant.
     * @example
     * // Delete one ProductVariant
     * const ProductVariant = await prisma.productVariant.delete({
     *   where: {
     *     // ... filter to delete one ProductVariant
     *   }
     * })
     * 
     */
    delete<T extends ProductVariantDeleteArgs>(args: SelectSubset<T, ProductVariantDeleteArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductVariant.
     * @param {ProductVariantUpdateArgs} args - Arguments to update one ProductVariant.
     * @example
     * // Update one ProductVariant
     * const productVariant = await prisma.productVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariantUpdateArgs>(args: SelectSubset<T, ProductVariantUpdateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductVariants.
     * @param {ProductVariantDeleteManyArgs} args - Arguments to filter ProductVariants to delete.
     * @example
     * // Delete a few ProductVariants
     * const { count } = await prisma.productVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariantDeleteManyArgs>(args?: SelectSubset<T, ProductVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariantUpdateManyArgs>(args: SelectSubset<T, ProductVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants and returns the data updated in the database.
     * @param {ProductVariantUpdateManyAndReturnArgs} args - Arguments to update many ProductVariants.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductVariantUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductVariantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductVariant.
     * @param {ProductVariantUpsertArgs} args - Arguments to update or create a ProductVariant.
     * @example
     * // Update or create a ProductVariant
     * const productVariant = await prisma.productVariant.upsert({
     *   create: {
     *     // ... data to create a ProductVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariant we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariantUpsertArgs>(args: SelectSubset<T, ProductVariantUpsertArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantCountArgs} args - Arguments to filter ProductVariants to count.
     * @example
     * // Count the number of ProductVariants
     * const count = await prisma.productVariant.count({
     *   where: {
     *     // ... the filter for the ProductVariants we want to count
     *   }
     * })
    **/
    count<T extends ProductVariantCountArgs>(
      args?: Subset<T, ProductVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariantAggregateArgs>(args: Subset<T, ProductVariantAggregateArgs>): Prisma.PrismaPromise<GetProductVariantAggregateType<T>>

    /**
     * Group by ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariantGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariant model
   */
  readonly fields: ProductVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    values<T extends ProductVariant$valuesArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariant model
   */
  interface ProductVariantFieldRefs {
    readonly id: FieldRef<"ProductVariant", 'String'>
    readonly name: FieldRef<"ProductVariant", 'String'>
    readonly createdAt: FieldRef<"ProductVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariant findUnique
   */
  export type ProductVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findUniqueOrThrow
   */
  export type ProductVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findFirst
   */
  export type ProductVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findFirstOrThrow
   */
  export type ProductVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findMany
   */
  export type ProductVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariants to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant create
   */
  export type ProductVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariant.
     */
    data: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
  }

  /**
   * ProductVariant createMany
   */
  export type ProductVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVariant createManyAndReturn
   */
  export type ProductVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVariant update
   */
  export type ProductVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariant.
     */
    data: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
    /**
     * Choose, which ProductVariant to update.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant updateMany
   */
  export type ProductVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number
  }

  /**
   * ProductVariant updateManyAndReturn
   */
  export type ProductVariantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number
  }

  /**
   * ProductVariant upsert
   */
  export type ProductVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariant to update in case it exists.
     */
    where: ProductVariantWhereUniqueInput
    /**
     * In case the ProductVariant found by the `where` argument doesn't exist, create a new ProductVariant with this data.
     */
    create: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
    /**
     * In case the ProductVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
  }

  /**
   * ProductVariant delete
   */
  export type ProductVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter which ProductVariant to delete.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant deleteMany
   */
  export type ProductVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariants to delete
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to delete.
     */
    limit?: number
  }

  /**
   * ProductVariant.values
   */
  export type ProductVariant$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueInclude<ExtArgs> | null
    where?: ProductVariantValueWhereInput
    orderBy?: ProductVariantValueOrderByWithRelationInput | ProductVariantValueOrderByWithRelationInput[]
    cursor?: ProductVariantValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductVariantValueScalarFieldEnum | ProductVariantValueScalarFieldEnum[]
  }

  /**
   * ProductVariant without action
   */
  export type ProductVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariantValue
   */

  export type AggregateProductVariantValue = {
    _count: ProductVariantValueCountAggregateOutputType | null
    _min: ProductVariantValueMinAggregateOutputType | null
    _max: ProductVariantValueMaxAggregateOutputType | null
  }

  export type ProductVariantValueMinAggregateOutputType = {
    id: string | null
    variantId: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantValueMaxAggregateOutputType = {
    id: string | null
    variantId: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantValueCountAggregateOutputType = {
    id: number
    variantId: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVariantValueMinAggregateInputType = {
    id?: true
    variantId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantValueMaxAggregateInputType = {
    id?: true
    variantId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantValueCountAggregateInputType = {
    id?: true
    variantId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVariantValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariantValue to aggregate.
     */
    where?: ProductVariantValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariantValues to fetch.
     */
    orderBy?: ProductVariantValueOrderByWithRelationInput | ProductVariantValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariantValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariantValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariantValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariantValues
    **/
    _count?: true | ProductVariantValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariantValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariantValueMaxAggregateInputType
  }

  export type GetProductVariantValueAggregateType<T extends ProductVariantValueAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariantValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariantValue[P]>
      : GetScalarType<T[P], AggregateProductVariantValue[P]>
  }




  export type ProductVariantValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantValueWhereInput
    orderBy?: ProductVariantValueOrderByWithAggregationInput | ProductVariantValueOrderByWithAggregationInput[]
    by: ProductVariantValueScalarFieldEnum[] | ProductVariantValueScalarFieldEnum
    having?: ProductVariantValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariantValueCountAggregateInputType | true
    _min?: ProductVariantValueMinAggregateInputType
    _max?: ProductVariantValueMaxAggregateInputType
  }

  export type ProductVariantValueGroupByOutputType = {
    id: string
    variantId: string
    value: string
    createdAt: Date
    updatedAt: Date
    _count: ProductVariantValueCountAggregateOutputType | null
    _min: ProductVariantValueMinAggregateOutputType | null
    _max: ProductVariantValueMaxAggregateOutputType | null
  }

  type GetProductVariantValueGroupByPayload<T extends ProductVariantValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariantValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariantValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariantValueGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariantValueGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariantValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    options?: boolean | ProductVariantValue$optionsArgs<ExtArgs>
    _count?: boolean | ProductVariantValueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariantValue"]>

  export type ProductVariantValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariantValue"]>

  export type ProductVariantValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariantValue"]>

  export type ProductVariantValueSelectScalar = {
    id?: boolean
    variantId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductVariantValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "variantId" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["productVariantValue"]>
  export type ProductVariantValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    options?: boolean | ProductVariantValue$optionsArgs<ExtArgs>
    _count?: boolean | ProductVariantValueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductVariantValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }
  export type ProductVariantValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }

  export type $ProductVariantValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariantValue"
    objects: {
      variant: Prisma.$ProductVariantPayload<ExtArgs>
      options: Prisma.$ProductVariationOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      variantId: string
      value: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productVariantValue"]>
    composites: {}
  }

  type ProductVariantValueGetPayload<S extends boolean | null | undefined | ProductVariantValueDefaultArgs> = $Result.GetResult<Prisma.$ProductVariantValuePayload, S>

  type ProductVariantValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductVariantValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductVariantValueCountAggregateInputType | true
    }

  export interface ProductVariantValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariantValue'], meta: { name: 'ProductVariantValue' } }
    /**
     * Find zero or one ProductVariantValue that matches the filter.
     * @param {ProductVariantValueFindUniqueArgs} args - Arguments to find a ProductVariantValue
     * @example
     * // Get one ProductVariantValue
     * const productVariantValue = await prisma.productVariantValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariantValueFindUniqueArgs>(args: SelectSubset<T, ProductVariantValueFindUniqueArgs<ExtArgs>>): Prisma__ProductVariantValueClient<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductVariantValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductVariantValueFindUniqueOrThrowArgs} args - Arguments to find a ProductVariantValue
     * @example
     * // Get one ProductVariantValue
     * const productVariantValue = await prisma.productVariantValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariantValueFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariantValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariantValueClient<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariantValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantValueFindFirstArgs} args - Arguments to find a ProductVariantValue
     * @example
     * // Get one ProductVariantValue
     * const productVariantValue = await prisma.productVariantValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariantValueFindFirstArgs>(args?: SelectSubset<T, ProductVariantValueFindFirstArgs<ExtArgs>>): Prisma__ProductVariantValueClient<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariantValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantValueFindFirstOrThrowArgs} args - Arguments to find a ProductVariantValue
     * @example
     * // Get one ProductVariantValue
     * const productVariantValue = await prisma.productVariantValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariantValueFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariantValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariantValueClient<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductVariantValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariantValues
     * const productVariantValues = await prisma.productVariantValue.findMany()
     * 
     * // Get first 10 ProductVariantValues
     * const productVariantValues = await prisma.productVariantValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariantValueWithIdOnly = await prisma.productVariantValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariantValueFindManyArgs>(args?: SelectSubset<T, ProductVariantValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductVariantValue.
     * @param {ProductVariantValueCreateArgs} args - Arguments to create a ProductVariantValue.
     * @example
     * // Create one ProductVariantValue
     * const ProductVariantValue = await prisma.productVariantValue.create({
     *   data: {
     *     // ... data to create a ProductVariantValue
     *   }
     * })
     * 
     */
    create<T extends ProductVariantValueCreateArgs>(args: SelectSubset<T, ProductVariantValueCreateArgs<ExtArgs>>): Prisma__ProductVariantValueClient<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductVariantValues.
     * @param {ProductVariantValueCreateManyArgs} args - Arguments to create many ProductVariantValues.
     * @example
     * // Create many ProductVariantValues
     * const productVariantValue = await prisma.productVariantValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariantValueCreateManyArgs>(args?: SelectSubset<T, ProductVariantValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductVariantValues and returns the data saved in the database.
     * @param {ProductVariantValueCreateManyAndReturnArgs} args - Arguments to create many ProductVariantValues.
     * @example
     * // Create many ProductVariantValues
     * const productVariantValue = await prisma.productVariantValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductVariantValues and only return the `id`
     * const productVariantValueWithIdOnly = await prisma.productVariantValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductVariantValueCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductVariantValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductVariantValue.
     * @param {ProductVariantValueDeleteArgs} args - Arguments to delete one ProductVariantValue.
     * @example
     * // Delete one ProductVariantValue
     * const ProductVariantValue = await prisma.productVariantValue.delete({
     *   where: {
     *     // ... filter to delete one ProductVariantValue
     *   }
     * })
     * 
     */
    delete<T extends ProductVariantValueDeleteArgs>(args: SelectSubset<T, ProductVariantValueDeleteArgs<ExtArgs>>): Prisma__ProductVariantValueClient<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductVariantValue.
     * @param {ProductVariantValueUpdateArgs} args - Arguments to update one ProductVariantValue.
     * @example
     * // Update one ProductVariantValue
     * const productVariantValue = await prisma.productVariantValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariantValueUpdateArgs>(args: SelectSubset<T, ProductVariantValueUpdateArgs<ExtArgs>>): Prisma__ProductVariantValueClient<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductVariantValues.
     * @param {ProductVariantValueDeleteManyArgs} args - Arguments to filter ProductVariantValues to delete.
     * @example
     * // Delete a few ProductVariantValues
     * const { count } = await prisma.productVariantValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariantValueDeleteManyArgs>(args?: SelectSubset<T, ProductVariantValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariantValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariantValues
     * const productVariantValue = await prisma.productVariantValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariantValueUpdateManyArgs>(args: SelectSubset<T, ProductVariantValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariantValues and returns the data updated in the database.
     * @param {ProductVariantValueUpdateManyAndReturnArgs} args - Arguments to update many ProductVariantValues.
     * @example
     * // Update many ProductVariantValues
     * const productVariantValue = await prisma.productVariantValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductVariantValues and only return the `id`
     * const productVariantValueWithIdOnly = await prisma.productVariantValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductVariantValueUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductVariantValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductVariantValue.
     * @param {ProductVariantValueUpsertArgs} args - Arguments to update or create a ProductVariantValue.
     * @example
     * // Update or create a ProductVariantValue
     * const productVariantValue = await prisma.productVariantValue.upsert({
     *   create: {
     *     // ... data to create a ProductVariantValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariantValue we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariantValueUpsertArgs>(args: SelectSubset<T, ProductVariantValueUpsertArgs<ExtArgs>>): Prisma__ProductVariantValueClient<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductVariantValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantValueCountArgs} args - Arguments to filter ProductVariantValues to count.
     * @example
     * // Count the number of ProductVariantValues
     * const count = await prisma.productVariantValue.count({
     *   where: {
     *     // ... the filter for the ProductVariantValues we want to count
     *   }
     * })
    **/
    count<T extends ProductVariantValueCountArgs>(
      args?: Subset<T, ProductVariantValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariantValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariantValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariantValueAggregateArgs>(args: Subset<T, ProductVariantValueAggregateArgs>): Prisma.PrismaPromise<GetProductVariantValueAggregateType<T>>

    /**
     * Group by ProductVariantValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariantValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariantValueGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariantValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariantValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariantValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariantValue model
   */
  readonly fields: ProductVariantValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariantValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariantValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant<T extends ProductVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariantDefaultArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    options<T extends ProductVariantValue$optionsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariantValue$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariantValue model
   */
  interface ProductVariantValueFieldRefs {
    readonly id: FieldRef<"ProductVariantValue", 'String'>
    readonly variantId: FieldRef<"ProductVariantValue", 'String'>
    readonly value: FieldRef<"ProductVariantValue", 'String'>
    readonly createdAt: FieldRef<"ProductVariantValue", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariantValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariantValue findUnique
   */
  export type ProductVariantValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariantValue to fetch.
     */
    where: ProductVariantValueWhereUniqueInput
  }

  /**
   * ProductVariantValue findUniqueOrThrow
   */
  export type ProductVariantValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariantValue to fetch.
     */
    where: ProductVariantValueWhereUniqueInput
  }

  /**
   * ProductVariantValue findFirst
   */
  export type ProductVariantValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariantValue to fetch.
     */
    where?: ProductVariantValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariantValues to fetch.
     */
    orderBy?: ProductVariantValueOrderByWithRelationInput | ProductVariantValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariantValues.
     */
    cursor?: ProductVariantValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariantValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariantValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariantValues.
     */
    distinct?: ProductVariantValueScalarFieldEnum | ProductVariantValueScalarFieldEnum[]
  }

  /**
   * ProductVariantValue findFirstOrThrow
   */
  export type ProductVariantValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariantValue to fetch.
     */
    where?: ProductVariantValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariantValues to fetch.
     */
    orderBy?: ProductVariantValueOrderByWithRelationInput | ProductVariantValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariantValues.
     */
    cursor?: ProductVariantValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariantValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariantValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariantValues.
     */
    distinct?: ProductVariantValueScalarFieldEnum | ProductVariantValueScalarFieldEnum[]
  }

  /**
   * ProductVariantValue findMany
   */
  export type ProductVariantValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariantValues to fetch.
     */
    where?: ProductVariantValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariantValues to fetch.
     */
    orderBy?: ProductVariantValueOrderByWithRelationInput | ProductVariantValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariantValues.
     */
    cursor?: ProductVariantValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariantValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariantValues.
     */
    skip?: number
    distinct?: ProductVariantValueScalarFieldEnum | ProductVariantValueScalarFieldEnum[]
  }

  /**
   * ProductVariantValue create
   */
  export type ProductVariantValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariantValue.
     */
    data: XOR<ProductVariantValueCreateInput, ProductVariantValueUncheckedCreateInput>
  }

  /**
   * ProductVariantValue createMany
   */
  export type ProductVariantValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariantValues.
     */
    data: ProductVariantValueCreateManyInput | ProductVariantValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVariantValue createManyAndReturn
   */
  export type ProductVariantValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * The data used to create many ProductVariantValues.
     */
    data: ProductVariantValueCreateManyInput | ProductVariantValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariantValue update
   */
  export type ProductVariantValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariantValue.
     */
    data: XOR<ProductVariantValueUpdateInput, ProductVariantValueUncheckedUpdateInput>
    /**
     * Choose, which ProductVariantValue to update.
     */
    where: ProductVariantValueWhereUniqueInput
  }

  /**
   * ProductVariantValue updateMany
   */
  export type ProductVariantValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariantValues.
     */
    data: XOR<ProductVariantValueUpdateManyMutationInput, ProductVariantValueUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariantValues to update
     */
    where?: ProductVariantValueWhereInput
    /**
     * Limit how many ProductVariantValues to update.
     */
    limit?: number
  }

  /**
   * ProductVariantValue updateManyAndReturn
   */
  export type ProductVariantValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * The data used to update ProductVariantValues.
     */
    data: XOR<ProductVariantValueUpdateManyMutationInput, ProductVariantValueUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariantValues to update
     */
    where?: ProductVariantValueWhereInput
    /**
     * Limit how many ProductVariantValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariantValue upsert
   */
  export type ProductVariantValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariantValue to update in case it exists.
     */
    where: ProductVariantValueWhereUniqueInput
    /**
     * In case the ProductVariantValue found by the `where` argument doesn't exist, create a new ProductVariantValue with this data.
     */
    create: XOR<ProductVariantValueCreateInput, ProductVariantValueUncheckedCreateInput>
    /**
     * In case the ProductVariantValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariantValueUpdateInput, ProductVariantValueUncheckedUpdateInput>
  }

  /**
   * ProductVariantValue delete
   */
  export type ProductVariantValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueInclude<ExtArgs> | null
    /**
     * Filter which ProductVariantValue to delete.
     */
    where: ProductVariantValueWhereUniqueInput
  }

  /**
   * ProductVariantValue deleteMany
   */
  export type ProductVariantValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariantValues to delete
     */
    where?: ProductVariantValueWhereInput
    /**
     * Limit how many ProductVariantValues to delete.
     */
    limit?: number
  }

  /**
   * ProductVariantValue.options
   */
  export type ProductVariantValue$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionInclude<ExtArgs> | null
    where?: ProductVariationOptionWhereInput
    orderBy?: ProductVariationOptionOrderByWithRelationInput | ProductVariationOptionOrderByWithRelationInput[]
    cursor?: ProductVariationOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductVariationOptionScalarFieldEnum | ProductVariationOptionScalarFieldEnum[]
  }

  /**
   * ProductVariantValue without action
   */
  export type ProductVariantValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantValue
     */
    select?: ProductVariantValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariantValue
     */
    omit?: ProductVariantValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantValueInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariationOption
   */

  export type AggregateProductVariationOption = {
    _count: ProductVariationOptionCountAggregateOutputType | null
    _min: ProductVariationOptionMinAggregateOutputType | null
    _max: ProductVariationOptionMaxAggregateOutputType | null
  }

  export type ProductVariationOptionMinAggregateOutputType = {
    id: string | null
    variationId: string | null
    valueId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariationOptionMaxAggregateOutputType = {
    id: string | null
    variationId: string | null
    valueId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariationOptionCountAggregateOutputType = {
    id: number
    variationId: number
    valueId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVariationOptionMinAggregateInputType = {
    id?: true
    variationId?: true
    valueId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariationOptionMaxAggregateInputType = {
    id?: true
    variationId?: true
    valueId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariationOptionCountAggregateInputType = {
    id?: true
    variationId?: true
    valueId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVariationOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariationOption to aggregate.
     */
    where?: ProductVariationOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariationOptions to fetch.
     */
    orderBy?: ProductVariationOptionOrderByWithRelationInput | ProductVariationOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariationOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariationOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariationOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariationOptions
    **/
    _count?: true | ProductVariationOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariationOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariationOptionMaxAggregateInputType
  }

  export type GetProductVariationOptionAggregateType<T extends ProductVariationOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariationOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariationOption[P]>
      : GetScalarType<T[P], AggregateProductVariationOption[P]>
  }




  export type ProductVariationOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariationOptionWhereInput
    orderBy?: ProductVariationOptionOrderByWithAggregationInput | ProductVariationOptionOrderByWithAggregationInput[]
    by: ProductVariationOptionScalarFieldEnum[] | ProductVariationOptionScalarFieldEnum
    having?: ProductVariationOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariationOptionCountAggregateInputType | true
    _min?: ProductVariationOptionMinAggregateInputType
    _max?: ProductVariationOptionMaxAggregateInputType
  }

  export type ProductVariationOptionGroupByOutputType = {
    id: string
    variationId: string
    valueId: string
    createdAt: Date
    updatedAt: Date
    _count: ProductVariationOptionCountAggregateOutputType | null
    _min: ProductVariationOptionMinAggregateOutputType | null
    _max: ProductVariationOptionMaxAggregateOutputType | null
  }

  type GetProductVariationOptionGroupByPayload<T extends ProductVariationOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariationOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariationOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariationOptionGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariationOptionGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariationOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variationId?: boolean
    valueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | ProductVariationDefaultArgs<ExtArgs>
    value?: boolean | ProductVariantValueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariationOption"]>

  export type ProductVariationOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variationId?: boolean
    valueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | ProductVariationDefaultArgs<ExtArgs>
    value?: boolean | ProductVariantValueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariationOption"]>

  export type ProductVariationOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variationId?: boolean
    valueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | ProductVariationDefaultArgs<ExtArgs>
    value?: boolean | ProductVariantValueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariationOption"]>

  export type ProductVariationOptionSelectScalar = {
    id?: boolean
    variationId?: boolean
    valueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductVariationOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "variationId" | "valueId" | "createdAt" | "updatedAt", ExtArgs["result"]["productVariationOption"]>
  export type ProductVariationOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | ProductVariationDefaultArgs<ExtArgs>
    value?: boolean | ProductVariantValueDefaultArgs<ExtArgs>
  }
  export type ProductVariationOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | ProductVariationDefaultArgs<ExtArgs>
    value?: boolean | ProductVariantValueDefaultArgs<ExtArgs>
  }
  export type ProductVariationOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | ProductVariationDefaultArgs<ExtArgs>
    value?: boolean | ProductVariantValueDefaultArgs<ExtArgs>
  }

  export type $ProductVariationOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariationOption"
    objects: {
      variation: Prisma.$ProductVariationPayload<ExtArgs>
      value: Prisma.$ProductVariantValuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      variationId: string
      valueId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productVariationOption"]>
    composites: {}
  }

  type ProductVariationOptionGetPayload<S extends boolean | null | undefined | ProductVariationOptionDefaultArgs> = $Result.GetResult<Prisma.$ProductVariationOptionPayload, S>

  type ProductVariationOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductVariationOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductVariationOptionCountAggregateInputType | true
    }

  export interface ProductVariationOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariationOption'], meta: { name: 'ProductVariationOption' } }
    /**
     * Find zero or one ProductVariationOption that matches the filter.
     * @param {ProductVariationOptionFindUniqueArgs} args - Arguments to find a ProductVariationOption
     * @example
     * // Get one ProductVariationOption
     * const productVariationOption = await prisma.productVariationOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariationOptionFindUniqueArgs>(args: SelectSubset<T, ProductVariationOptionFindUniqueArgs<ExtArgs>>): Prisma__ProductVariationOptionClient<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductVariationOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductVariationOptionFindUniqueOrThrowArgs} args - Arguments to find a ProductVariationOption
     * @example
     * // Get one ProductVariationOption
     * const productVariationOption = await prisma.productVariationOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariationOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariationOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariationOptionClient<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariationOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationOptionFindFirstArgs} args - Arguments to find a ProductVariationOption
     * @example
     * // Get one ProductVariationOption
     * const productVariationOption = await prisma.productVariationOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariationOptionFindFirstArgs>(args?: SelectSubset<T, ProductVariationOptionFindFirstArgs<ExtArgs>>): Prisma__ProductVariationOptionClient<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariationOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationOptionFindFirstOrThrowArgs} args - Arguments to find a ProductVariationOption
     * @example
     * // Get one ProductVariationOption
     * const productVariationOption = await prisma.productVariationOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariationOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariationOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariationOptionClient<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductVariationOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariationOptions
     * const productVariationOptions = await prisma.productVariationOption.findMany()
     * 
     * // Get first 10 ProductVariationOptions
     * const productVariationOptions = await prisma.productVariationOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariationOptionWithIdOnly = await prisma.productVariationOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariationOptionFindManyArgs>(args?: SelectSubset<T, ProductVariationOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductVariationOption.
     * @param {ProductVariationOptionCreateArgs} args - Arguments to create a ProductVariationOption.
     * @example
     * // Create one ProductVariationOption
     * const ProductVariationOption = await prisma.productVariationOption.create({
     *   data: {
     *     // ... data to create a ProductVariationOption
     *   }
     * })
     * 
     */
    create<T extends ProductVariationOptionCreateArgs>(args: SelectSubset<T, ProductVariationOptionCreateArgs<ExtArgs>>): Prisma__ProductVariationOptionClient<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductVariationOptions.
     * @param {ProductVariationOptionCreateManyArgs} args - Arguments to create many ProductVariationOptions.
     * @example
     * // Create many ProductVariationOptions
     * const productVariationOption = await prisma.productVariationOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariationOptionCreateManyArgs>(args?: SelectSubset<T, ProductVariationOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductVariationOptions and returns the data saved in the database.
     * @param {ProductVariationOptionCreateManyAndReturnArgs} args - Arguments to create many ProductVariationOptions.
     * @example
     * // Create many ProductVariationOptions
     * const productVariationOption = await prisma.productVariationOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductVariationOptions and only return the `id`
     * const productVariationOptionWithIdOnly = await prisma.productVariationOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductVariationOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductVariationOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductVariationOption.
     * @param {ProductVariationOptionDeleteArgs} args - Arguments to delete one ProductVariationOption.
     * @example
     * // Delete one ProductVariationOption
     * const ProductVariationOption = await prisma.productVariationOption.delete({
     *   where: {
     *     // ... filter to delete one ProductVariationOption
     *   }
     * })
     * 
     */
    delete<T extends ProductVariationOptionDeleteArgs>(args: SelectSubset<T, ProductVariationOptionDeleteArgs<ExtArgs>>): Prisma__ProductVariationOptionClient<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductVariationOption.
     * @param {ProductVariationOptionUpdateArgs} args - Arguments to update one ProductVariationOption.
     * @example
     * // Update one ProductVariationOption
     * const productVariationOption = await prisma.productVariationOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariationOptionUpdateArgs>(args: SelectSubset<T, ProductVariationOptionUpdateArgs<ExtArgs>>): Prisma__ProductVariationOptionClient<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductVariationOptions.
     * @param {ProductVariationOptionDeleteManyArgs} args - Arguments to filter ProductVariationOptions to delete.
     * @example
     * // Delete a few ProductVariationOptions
     * const { count } = await prisma.productVariationOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariationOptionDeleteManyArgs>(args?: SelectSubset<T, ProductVariationOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariationOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariationOptions
     * const productVariationOption = await prisma.productVariationOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariationOptionUpdateManyArgs>(args: SelectSubset<T, ProductVariationOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariationOptions and returns the data updated in the database.
     * @param {ProductVariationOptionUpdateManyAndReturnArgs} args - Arguments to update many ProductVariationOptions.
     * @example
     * // Update many ProductVariationOptions
     * const productVariationOption = await prisma.productVariationOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductVariationOptions and only return the `id`
     * const productVariationOptionWithIdOnly = await prisma.productVariationOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductVariationOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductVariationOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductVariationOption.
     * @param {ProductVariationOptionUpsertArgs} args - Arguments to update or create a ProductVariationOption.
     * @example
     * // Update or create a ProductVariationOption
     * const productVariationOption = await prisma.productVariationOption.upsert({
     *   create: {
     *     // ... data to create a ProductVariationOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariationOption we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariationOptionUpsertArgs>(args: SelectSubset<T, ProductVariationOptionUpsertArgs<ExtArgs>>): Prisma__ProductVariationOptionClient<$Result.GetResult<Prisma.$ProductVariationOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductVariationOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationOptionCountArgs} args - Arguments to filter ProductVariationOptions to count.
     * @example
     * // Count the number of ProductVariationOptions
     * const count = await prisma.productVariationOption.count({
     *   where: {
     *     // ... the filter for the ProductVariationOptions we want to count
     *   }
     * })
    **/
    count<T extends ProductVariationOptionCountArgs>(
      args?: Subset<T, ProductVariationOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariationOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariationOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariationOptionAggregateArgs>(args: Subset<T, ProductVariationOptionAggregateArgs>): Prisma.PrismaPromise<GetProductVariationOptionAggregateType<T>>

    /**
     * Group by ProductVariationOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariationOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariationOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariationOptionGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariationOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariationOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariationOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariationOption model
   */
  readonly fields: ProductVariationOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariationOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariationOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variation<T extends ProductVariationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariationDefaultArgs<ExtArgs>>): Prisma__ProductVariationClient<$Result.GetResult<Prisma.$ProductVariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    value<T extends ProductVariantValueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariantValueDefaultArgs<ExtArgs>>): Prisma__ProductVariantValueClient<$Result.GetResult<Prisma.$ProductVariantValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariationOption model
   */
  interface ProductVariationOptionFieldRefs {
    readonly id: FieldRef<"ProductVariationOption", 'String'>
    readonly variationId: FieldRef<"ProductVariationOption", 'String'>
    readonly valueId: FieldRef<"ProductVariationOption", 'String'>
    readonly createdAt: FieldRef<"ProductVariationOption", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariationOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariationOption findUnique
   */
  export type ProductVariationOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariationOption to fetch.
     */
    where: ProductVariationOptionWhereUniqueInput
  }

  /**
   * ProductVariationOption findUniqueOrThrow
   */
  export type ProductVariationOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariationOption to fetch.
     */
    where: ProductVariationOptionWhereUniqueInput
  }

  /**
   * ProductVariationOption findFirst
   */
  export type ProductVariationOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariationOption to fetch.
     */
    where?: ProductVariationOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariationOptions to fetch.
     */
    orderBy?: ProductVariationOptionOrderByWithRelationInput | ProductVariationOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariationOptions.
     */
    cursor?: ProductVariationOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariationOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariationOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariationOptions.
     */
    distinct?: ProductVariationOptionScalarFieldEnum | ProductVariationOptionScalarFieldEnum[]
  }

  /**
   * ProductVariationOption findFirstOrThrow
   */
  export type ProductVariationOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariationOption to fetch.
     */
    where?: ProductVariationOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariationOptions to fetch.
     */
    orderBy?: ProductVariationOptionOrderByWithRelationInput | ProductVariationOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariationOptions.
     */
    cursor?: ProductVariationOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariationOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariationOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariationOptions.
     */
    distinct?: ProductVariationOptionScalarFieldEnum | ProductVariationOptionScalarFieldEnum[]
  }

  /**
   * ProductVariationOption findMany
   */
  export type ProductVariationOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariationOptions to fetch.
     */
    where?: ProductVariationOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariationOptions to fetch.
     */
    orderBy?: ProductVariationOptionOrderByWithRelationInput | ProductVariationOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariationOptions.
     */
    cursor?: ProductVariationOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariationOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariationOptions.
     */
    skip?: number
    distinct?: ProductVariationOptionScalarFieldEnum | ProductVariationOptionScalarFieldEnum[]
  }

  /**
   * ProductVariationOption create
   */
  export type ProductVariationOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariationOption.
     */
    data: XOR<ProductVariationOptionCreateInput, ProductVariationOptionUncheckedCreateInput>
  }

  /**
   * ProductVariationOption createMany
   */
  export type ProductVariationOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariationOptions.
     */
    data: ProductVariationOptionCreateManyInput | ProductVariationOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVariationOption createManyAndReturn
   */
  export type ProductVariationOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * The data used to create many ProductVariationOptions.
     */
    data: ProductVariationOptionCreateManyInput | ProductVariationOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariationOption update
   */
  export type ProductVariationOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariationOption.
     */
    data: XOR<ProductVariationOptionUpdateInput, ProductVariationOptionUncheckedUpdateInput>
    /**
     * Choose, which ProductVariationOption to update.
     */
    where: ProductVariationOptionWhereUniqueInput
  }

  /**
   * ProductVariationOption updateMany
   */
  export type ProductVariationOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariationOptions.
     */
    data: XOR<ProductVariationOptionUpdateManyMutationInput, ProductVariationOptionUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariationOptions to update
     */
    where?: ProductVariationOptionWhereInput
    /**
     * Limit how many ProductVariationOptions to update.
     */
    limit?: number
  }

  /**
   * ProductVariationOption updateManyAndReturn
   */
  export type ProductVariationOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * The data used to update ProductVariationOptions.
     */
    data: XOR<ProductVariationOptionUpdateManyMutationInput, ProductVariationOptionUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariationOptions to update
     */
    where?: ProductVariationOptionWhereInput
    /**
     * Limit how many ProductVariationOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariationOption upsert
   */
  export type ProductVariationOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariationOption to update in case it exists.
     */
    where: ProductVariationOptionWhereUniqueInput
    /**
     * In case the ProductVariationOption found by the `where` argument doesn't exist, create a new ProductVariationOption with this data.
     */
    create: XOR<ProductVariationOptionCreateInput, ProductVariationOptionUncheckedCreateInput>
    /**
     * In case the ProductVariationOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariationOptionUpdateInput, ProductVariationOptionUncheckedUpdateInput>
  }

  /**
   * ProductVariationOption delete
   */
  export type ProductVariationOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionInclude<ExtArgs> | null
    /**
     * Filter which ProductVariationOption to delete.
     */
    where: ProductVariationOptionWhereUniqueInput
  }

  /**
   * ProductVariationOption deleteMany
   */
  export type ProductVariationOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariationOptions to delete
     */
    where?: ProductVariationOptionWhereInput
    /**
     * Limit how many ProductVariationOptions to delete.
     */
    limit?: number
  }

  /**
   * ProductVariationOption without action
   */
  export type ProductVariationOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariationOption
     */
    select?: ProductVariationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariationOption
     */
    omit?: ProductVariationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariationOptionInclude<ExtArgs> | null
  }


  /**
   * Model FeaturedBrands
   */

  export type AggregateFeaturedBrands = {
    _count: FeaturedBrandsCountAggregateOutputType | null
    _min: FeaturedBrandsMinAggregateOutputType | null
    _max: FeaturedBrandsMaxAggregateOutputType | null
  }

  export type FeaturedBrandsMinAggregateOutputType = {
    id: string | null
    name: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedBrandsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedBrandsCountAggregateOutputType = {
    id: number
    name: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeaturedBrandsMinAggregateInputType = {
    id?: true
    name?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedBrandsMaxAggregateInputType = {
    id?: true
    name?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedBrandsCountAggregateInputType = {
    id?: true
    name?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeaturedBrandsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedBrands to aggregate.
     */
    where?: FeaturedBrandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedBrands to fetch.
     */
    orderBy?: FeaturedBrandsOrderByWithRelationInput | FeaturedBrandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeaturedBrandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeaturedBrands
    **/
    _count?: true | FeaturedBrandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturedBrandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturedBrandsMaxAggregateInputType
  }

  export type GetFeaturedBrandsAggregateType<T extends FeaturedBrandsAggregateArgs> = {
        [P in keyof T & keyof AggregateFeaturedBrands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeaturedBrands[P]>
      : GetScalarType<T[P], AggregateFeaturedBrands[P]>
  }




  export type FeaturedBrandsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedBrandsWhereInput
    orderBy?: FeaturedBrandsOrderByWithAggregationInput | FeaturedBrandsOrderByWithAggregationInput[]
    by: FeaturedBrandsScalarFieldEnum[] | FeaturedBrandsScalarFieldEnum
    having?: FeaturedBrandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturedBrandsCountAggregateInputType | true
    _min?: FeaturedBrandsMinAggregateInputType
    _max?: FeaturedBrandsMaxAggregateInputType
  }

  export type FeaturedBrandsGroupByOutputType = {
    id: string
    name: string
    productId: string
    createdAt: Date
    updatedAt: Date
    _count: FeaturedBrandsCountAggregateOutputType | null
    _min: FeaturedBrandsMinAggregateOutputType | null
    _max: FeaturedBrandsMaxAggregateOutputType | null
  }

  type GetFeaturedBrandsGroupByPayload<T extends FeaturedBrandsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturedBrandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturedBrandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturedBrandsGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturedBrandsGroupByOutputType[P]>
        }
      >
    >


  export type FeaturedBrandsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredBrands"]>

  export type FeaturedBrandsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredBrands"]>

  export type FeaturedBrandsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredBrands"]>

  export type FeaturedBrandsSelectScalar = {
    id?: boolean
    name?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeaturedBrandsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "productId" | "createdAt" | "updatedAt", ExtArgs["result"]["featuredBrands"]>
  export type FeaturedBrandsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type FeaturedBrandsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type FeaturedBrandsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $FeaturedBrandsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeaturedBrands"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      productId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featuredBrands"]>
    composites: {}
  }

  type FeaturedBrandsGetPayload<S extends boolean | null | undefined | FeaturedBrandsDefaultArgs> = $Result.GetResult<Prisma.$FeaturedBrandsPayload, S>

  type FeaturedBrandsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeaturedBrandsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeaturedBrandsCountAggregateInputType | true
    }

  export interface FeaturedBrandsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeaturedBrands'], meta: { name: 'FeaturedBrands' } }
    /**
     * Find zero or one FeaturedBrands that matches the filter.
     * @param {FeaturedBrandsFindUniqueArgs} args - Arguments to find a FeaturedBrands
     * @example
     * // Get one FeaturedBrands
     * const featuredBrands = await prisma.featuredBrands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeaturedBrandsFindUniqueArgs>(args: SelectSubset<T, FeaturedBrandsFindUniqueArgs<ExtArgs>>): Prisma__FeaturedBrandsClient<$Result.GetResult<Prisma.$FeaturedBrandsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeaturedBrands that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeaturedBrandsFindUniqueOrThrowArgs} args - Arguments to find a FeaturedBrands
     * @example
     * // Get one FeaturedBrands
     * const featuredBrands = await prisma.featuredBrands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeaturedBrandsFindUniqueOrThrowArgs>(args: SelectSubset<T, FeaturedBrandsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeaturedBrandsClient<$Result.GetResult<Prisma.$FeaturedBrandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBrandsFindFirstArgs} args - Arguments to find a FeaturedBrands
     * @example
     * // Get one FeaturedBrands
     * const featuredBrands = await prisma.featuredBrands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeaturedBrandsFindFirstArgs>(args?: SelectSubset<T, FeaturedBrandsFindFirstArgs<ExtArgs>>): Prisma__FeaturedBrandsClient<$Result.GetResult<Prisma.$FeaturedBrandsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedBrands that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBrandsFindFirstOrThrowArgs} args - Arguments to find a FeaturedBrands
     * @example
     * // Get one FeaturedBrands
     * const featuredBrands = await prisma.featuredBrands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeaturedBrandsFindFirstOrThrowArgs>(args?: SelectSubset<T, FeaturedBrandsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeaturedBrandsClient<$Result.GetResult<Prisma.$FeaturedBrandsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeaturedBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBrandsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeaturedBrands
     * const featuredBrands = await prisma.featuredBrands.findMany()
     * 
     * // Get first 10 FeaturedBrands
     * const featuredBrands = await prisma.featuredBrands.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuredBrandsWithIdOnly = await prisma.featuredBrands.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeaturedBrandsFindManyArgs>(args?: SelectSubset<T, FeaturedBrandsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedBrandsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeaturedBrands.
     * @param {FeaturedBrandsCreateArgs} args - Arguments to create a FeaturedBrands.
     * @example
     * // Create one FeaturedBrands
     * const FeaturedBrands = await prisma.featuredBrands.create({
     *   data: {
     *     // ... data to create a FeaturedBrands
     *   }
     * })
     * 
     */
    create<T extends FeaturedBrandsCreateArgs>(args: SelectSubset<T, FeaturedBrandsCreateArgs<ExtArgs>>): Prisma__FeaturedBrandsClient<$Result.GetResult<Prisma.$FeaturedBrandsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeaturedBrands.
     * @param {FeaturedBrandsCreateManyArgs} args - Arguments to create many FeaturedBrands.
     * @example
     * // Create many FeaturedBrands
     * const featuredBrands = await prisma.featuredBrands.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeaturedBrandsCreateManyArgs>(args?: SelectSubset<T, FeaturedBrandsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeaturedBrands and returns the data saved in the database.
     * @param {FeaturedBrandsCreateManyAndReturnArgs} args - Arguments to create many FeaturedBrands.
     * @example
     * // Create many FeaturedBrands
     * const featuredBrands = await prisma.featuredBrands.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeaturedBrands and only return the `id`
     * const featuredBrandsWithIdOnly = await prisma.featuredBrands.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeaturedBrandsCreateManyAndReturnArgs>(args?: SelectSubset<T, FeaturedBrandsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedBrandsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeaturedBrands.
     * @param {FeaturedBrandsDeleteArgs} args - Arguments to delete one FeaturedBrands.
     * @example
     * // Delete one FeaturedBrands
     * const FeaturedBrands = await prisma.featuredBrands.delete({
     *   where: {
     *     // ... filter to delete one FeaturedBrands
     *   }
     * })
     * 
     */
    delete<T extends FeaturedBrandsDeleteArgs>(args: SelectSubset<T, FeaturedBrandsDeleteArgs<ExtArgs>>): Prisma__FeaturedBrandsClient<$Result.GetResult<Prisma.$FeaturedBrandsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeaturedBrands.
     * @param {FeaturedBrandsUpdateArgs} args - Arguments to update one FeaturedBrands.
     * @example
     * // Update one FeaturedBrands
     * const featuredBrands = await prisma.featuredBrands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeaturedBrandsUpdateArgs>(args: SelectSubset<T, FeaturedBrandsUpdateArgs<ExtArgs>>): Prisma__FeaturedBrandsClient<$Result.GetResult<Prisma.$FeaturedBrandsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeaturedBrands.
     * @param {FeaturedBrandsDeleteManyArgs} args - Arguments to filter FeaturedBrands to delete.
     * @example
     * // Delete a few FeaturedBrands
     * const { count } = await prisma.featuredBrands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeaturedBrandsDeleteManyArgs>(args?: SelectSubset<T, FeaturedBrandsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBrandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeaturedBrands
     * const featuredBrands = await prisma.featuredBrands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeaturedBrandsUpdateManyArgs>(args: SelectSubset<T, FeaturedBrandsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedBrands and returns the data updated in the database.
     * @param {FeaturedBrandsUpdateManyAndReturnArgs} args - Arguments to update many FeaturedBrands.
     * @example
     * // Update many FeaturedBrands
     * const featuredBrands = await prisma.featuredBrands.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeaturedBrands and only return the `id`
     * const featuredBrandsWithIdOnly = await prisma.featuredBrands.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeaturedBrandsUpdateManyAndReturnArgs>(args: SelectSubset<T, FeaturedBrandsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedBrandsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeaturedBrands.
     * @param {FeaturedBrandsUpsertArgs} args - Arguments to update or create a FeaturedBrands.
     * @example
     * // Update or create a FeaturedBrands
     * const featuredBrands = await prisma.featuredBrands.upsert({
     *   create: {
     *     // ... data to create a FeaturedBrands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeaturedBrands we want to update
     *   }
     * })
     */
    upsert<T extends FeaturedBrandsUpsertArgs>(args: SelectSubset<T, FeaturedBrandsUpsertArgs<ExtArgs>>): Prisma__FeaturedBrandsClient<$Result.GetResult<Prisma.$FeaturedBrandsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeaturedBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBrandsCountArgs} args - Arguments to filter FeaturedBrands to count.
     * @example
     * // Count the number of FeaturedBrands
     * const count = await prisma.featuredBrands.count({
     *   where: {
     *     // ... the filter for the FeaturedBrands we want to count
     *   }
     * })
    **/
    count<T extends FeaturedBrandsCountArgs>(
      args?: Subset<T, FeaturedBrandsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturedBrandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeaturedBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBrandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturedBrandsAggregateArgs>(args: Subset<T, FeaturedBrandsAggregateArgs>): Prisma.PrismaPromise<GetFeaturedBrandsAggregateType<T>>

    /**
     * Group by FeaturedBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBrandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturedBrandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturedBrandsGroupByArgs['orderBy'] }
        : { orderBy?: FeaturedBrandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturedBrandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturedBrandsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeaturedBrands model
   */
  readonly fields: FeaturedBrandsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeaturedBrands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeaturedBrandsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeaturedBrands model
   */
  interface FeaturedBrandsFieldRefs {
    readonly id: FieldRef<"FeaturedBrands", 'String'>
    readonly name: FieldRef<"FeaturedBrands", 'String'>
    readonly productId: FieldRef<"FeaturedBrands", 'String'>
    readonly createdAt: FieldRef<"FeaturedBrands", 'DateTime'>
    readonly updatedAt: FieldRef<"FeaturedBrands", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeaturedBrands findUnique
   */
  export type FeaturedBrandsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedBrands to fetch.
     */
    where: FeaturedBrandsWhereUniqueInput
  }

  /**
   * FeaturedBrands findUniqueOrThrow
   */
  export type FeaturedBrandsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedBrands to fetch.
     */
    where: FeaturedBrandsWhereUniqueInput
  }

  /**
   * FeaturedBrands findFirst
   */
  export type FeaturedBrandsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedBrands to fetch.
     */
    where?: FeaturedBrandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedBrands to fetch.
     */
    orderBy?: FeaturedBrandsOrderByWithRelationInput | FeaturedBrandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedBrands.
     */
    cursor?: FeaturedBrandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedBrands.
     */
    distinct?: FeaturedBrandsScalarFieldEnum | FeaturedBrandsScalarFieldEnum[]
  }

  /**
   * FeaturedBrands findFirstOrThrow
   */
  export type FeaturedBrandsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedBrands to fetch.
     */
    where?: FeaturedBrandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedBrands to fetch.
     */
    orderBy?: FeaturedBrandsOrderByWithRelationInput | FeaturedBrandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedBrands.
     */
    cursor?: FeaturedBrandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedBrands.
     */
    distinct?: FeaturedBrandsScalarFieldEnum | FeaturedBrandsScalarFieldEnum[]
  }

  /**
   * FeaturedBrands findMany
   */
  export type FeaturedBrandsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedBrands to fetch.
     */
    where?: FeaturedBrandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedBrands to fetch.
     */
    orderBy?: FeaturedBrandsOrderByWithRelationInput | FeaturedBrandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeaturedBrands.
     */
    cursor?: FeaturedBrandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedBrands.
     */
    skip?: number
    distinct?: FeaturedBrandsScalarFieldEnum | FeaturedBrandsScalarFieldEnum[]
  }

  /**
   * FeaturedBrands create
   */
  export type FeaturedBrandsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsInclude<ExtArgs> | null
    /**
     * The data needed to create a FeaturedBrands.
     */
    data: XOR<FeaturedBrandsCreateInput, FeaturedBrandsUncheckedCreateInput>
  }

  /**
   * FeaturedBrands createMany
   */
  export type FeaturedBrandsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeaturedBrands.
     */
    data: FeaturedBrandsCreateManyInput | FeaturedBrandsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedBrands createManyAndReturn
   */
  export type FeaturedBrandsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * The data used to create many FeaturedBrands.
     */
    data: FeaturedBrandsCreateManyInput | FeaturedBrandsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedBrands update
   */
  export type FeaturedBrandsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsInclude<ExtArgs> | null
    /**
     * The data needed to update a FeaturedBrands.
     */
    data: XOR<FeaturedBrandsUpdateInput, FeaturedBrandsUncheckedUpdateInput>
    /**
     * Choose, which FeaturedBrands to update.
     */
    where: FeaturedBrandsWhereUniqueInput
  }

  /**
   * FeaturedBrands updateMany
   */
  export type FeaturedBrandsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeaturedBrands.
     */
    data: XOR<FeaturedBrandsUpdateManyMutationInput, FeaturedBrandsUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedBrands to update
     */
    where?: FeaturedBrandsWhereInput
    /**
     * Limit how many FeaturedBrands to update.
     */
    limit?: number
  }

  /**
   * FeaturedBrands updateManyAndReturn
   */
  export type FeaturedBrandsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * The data used to update FeaturedBrands.
     */
    data: XOR<FeaturedBrandsUpdateManyMutationInput, FeaturedBrandsUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedBrands to update
     */
    where?: FeaturedBrandsWhereInput
    /**
     * Limit how many FeaturedBrands to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedBrands upsert
   */
  export type FeaturedBrandsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsInclude<ExtArgs> | null
    /**
     * The filter to search for the FeaturedBrands to update in case it exists.
     */
    where: FeaturedBrandsWhereUniqueInput
    /**
     * In case the FeaturedBrands found by the `where` argument doesn't exist, create a new FeaturedBrands with this data.
     */
    create: XOR<FeaturedBrandsCreateInput, FeaturedBrandsUncheckedCreateInput>
    /**
     * In case the FeaturedBrands was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeaturedBrandsUpdateInput, FeaturedBrandsUncheckedUpdateInput>
  }

  /**
   * FeaturedBrands delete
   */
  export type FeaturedBrandsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsInclude<ExtArgs> | null
    /**
     * Filter which FeaturedBrands to delete.
     */
    where: FeaturedBrandsWhereUniqueInput
  }

  /**
   * FeaturedBrands deleteMany
   */
  export type FeaturedBrandsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedBrands to delete
     */
    where?: FeaturedBrandsWhereInput
    /**
     * Limit how many FeaturedBrands to delete.
     */
    limit?: number
  }

  /**
   * FeaturedBrands without action
   */
  export type FeaturedBrandsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBrands
     */
    select?: FeaturedBrandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBrands
     */
    omit?: FeaturedBrandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBrandsInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    supplierName: string | null
    email: string | null
    phoneNumber: string | null
    personOfSupplier: string | null
    location: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    supplierName: string | null
    email: string | null
    phoneNumber: string | null
    personOfSupplier: string | null
    location: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    supplierName: number
    email: number
    phoneNumber: number
    personOfSupplier: number
    location: number
    storeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    supplierName?: true
    email?: true
    phoneNumber?: true
    personOfSupplier?: true
    location?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    supplierName?: true
    email?: true
    phoneNumber?: true
    personOfSupplier?: true
    location?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    supplierName?: true
    email?: true
    phoneNumber?: true
    personOfSupplier?: true
    location?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    supplierName: string
    email: string
    phoneNumber: string
    personOfSupplier: string
    location: string
    storeId: string
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierName?: boolean
    email?: boolean
    phoneNumber?: boolean
    personOfSupplier?: boolean
    location?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchase?: boolean | Supplier$purchaseArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierName?: boolean
    email?: boolean
    phoneNumber?: boolean
    personOfSupplier?: boolean
    location?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierName?: boolean
    email?: boolean
    phoneNumber?: boolean
    personOfSupplier?: boolean
    location?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    supplierName?: boolean
    email?: boolean
    phoneNumber?: boolean
    personOfSupplier?: boolean
    location?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplierName" | "email" | "phoneNumber" | "personOfSupplier" | "location" | "storeId" | "createdAt" | "updatedAt", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | Supplier$purchaseArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      purchase: Prisma.$PurchasePayload<ExtArgs>[]
      store: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplierName: string
      email: string
      phoneNumber: string
      personOfSupplier: string
      location: string
      storeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends Supplier$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly supplierName: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly phoneNumber: FieldRef<"Supplier", 'String'>
    readonly personOfSupplier: FieldRef<"Supplier", 'String'>
    readonly location: FieldRef<"Supplier", 'String'>
    readonly storeId: FieldRef<"Supplier", 'String'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.purchase
   */
  export type Supplier$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    toalCost: Decimal | null
  }

  export type PurchaseSumAggregateOutputType = {
    toalCost: Decimal | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    status: string | null
    downloadUrl: string | null
    toalCost: Decimal | null
    storeSupplierId: string | null
    storeId: string | null
    deliveryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    status: string | null
    downloadUrl: string | null
    toalCost: Decimal | null
    storeSupplierId: string | null
    storeId: string | null
    deliveryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    status: number
    downloadUrl: number
    toalCost: number
    storeSupplierId: number
    storeId: number
    deliveryDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    toalCost?: true
  }

  export type PurchaseSumAggregateInputType = {
    toalCost?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    status?: true
    downloadUrl?: true
    toalCost?: true
    storeSupplierId?: true
    storeId?: true
    deliveryDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    status?: true
    downloadUrl?: true
    toalCost?: true
    storeSupplierId?: true
    storeId?: true
    deliveryDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    status?: true
    downloadUrl?: true
    toalCost?: true
    storeSupplierId?: true
    storeId?: true
    deliveryDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    status: string
    downloadUrl: string
    toalCost: Decimal
    storeSupplierId: string
    storeId: string
    deliveryDate: Date
    createdAt: Date
    updatedAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    downloadUrl?: boolean
    toalCost?: boolean
    storeSupplierId?: boolean
    storeId?: boolean
    deliveryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeSupplier?: boolean | SupplierDefaultArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    products?: boolean | Purchase$productsArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    downloadUrl?: boolean
    toalCost?: boolean
    storeSupplierId?: boolean
    storeId?: boolean
    deliveryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeSupplier?: boolean | SupplierDefaultArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    downloadUrl?: boolean
    toalCost?: boolean
    storeSupplierId?: boolean
    storeId?: boolean
    deliveryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeSupplier?: boolean | SupplierDefaultArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    status?: boolean
    downloadUrl?: boolean
    toalCost?: boolean
    storeSupplierId?: boolean
    storeId?: boolean
    deliveryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "downloadUrl" | "toalCost" | "storeSupplierId" | "storeId" | "deliveryDate" | "createdAt" | "updatedAt", ExtArgs["result"]["purchase"]>
  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storeSupplier?: boolean | SupplierDefaultArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    products?: boolean | Purchase$productsArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storeSupplier?: boolean | SupplierDefaultArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storeSupplier?: boolean | SupplierDefaultArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      storeSupplier: Prisma.$SupplierPayload<ExtArgs>
      store: Prisma.$OrganizationPayload<ExtArgs>
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      downloadUrl: string
      toalCost: Prisma.Decimal
      storeSupplierId: string
      storeId: string
      deliveryDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases and returns the data updated in the database.
     * @param {PurchaseUpdateManyAndReturnArgs} args - Arguments to update many Purchases.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    storeSupplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    products<T extends Purchase$productsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly status: FieldRef<"Purchase", 'String'>
    readonly downloadUrl: FieldRef<"Purchase", 'String'>
    readonly toalCost: FieldRef<"Purchase", 'Decimal'>
    readonly storeSupplierId: FieldRef<"Purchase", 'String'>
    readonly storeId: FieldRef<"Purchase", 'String'>
    readonly deliveryDate: FieldRef<"Purchase", 'DateTime'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
  }

  /**
   * Purchase updateManyAndReturn
   */
  export type PurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
    /**
     * Limit how many Purchases to delete.
     */
    limit?: number
  }

  /**
   * Purchase.products
   */
  export type Purchase$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    emailVerified: boolean | null
    image: string | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    locationId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    emailVerified: boolean | null
    image: string | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    locationId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    firstName: number
    middleName: number
    lastName: number
    email: number
    phoneNumber: number
    emailVerified: number
    image: number
    role: number
    banned: number
    banReason: number
    banExpires: number
    createdAt: number
    updatedAt: number
    locationId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    middleName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    emailVerified?: true
    image?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    createdAt?: true
    updatedAt?: true
    locationId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    middleName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    emailVerified?: true
    image?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    createdAt?: true
    updatedAt?: true
    locationId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    middleName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    emailVerified?: true
    image?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    createdAt?: true
    updatedAt?: true
    locationId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    firstName: string
    middleName: string | null
    lastName: string
    email: string
    phoneNumber: string | null
    emailVerified: boolean | null
    image: string | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    createdAt: Date
    updatedAt: Date
    locationId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locationId?: boolean
    members?: boolean | User$membersArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    location?: boolean | User$locationArgs<ExtArgs>
    PointOfSale?: boolean | User$PointOfSaleArgs<ExtArgs>
    warehouse?: boolean | User$warehouseArgs<ExtArgs>
    POS?: boolean | User$POSArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locationId?: boolean
    location?: boolean | User$locationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locationId?: boolean
    location?: boolean | User$locationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locationId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "firstName" | "middleName" | "lastName" | "email" | "phoneNumber" | "emailVerified" | "image" | "role" | "banned" | "banReason" | "banExpires" | "createdAt" | "updatedAt" | "locationId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | User$membersArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    location?: boolean | User$locationArgs<ExtArgs>
    PointOfSale?: boolean | User$PointOfSaleArgs<ExtArgs>
    warehouse?: boolean | User$warehouseArgs<ExtArgs>
    POS?: boolean | User$POSArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | User$locationArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | User$locationArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      location: Prisma.$LocationPayload<ExtArgs> | null
      PointOfSale: Prisma.$PointOfSalePayload<ExtArgs> | null
      warehouse: Prisma.$WarehousePayload<ExtArgs> | null
      POS: Prisma.$POSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      firstName: string
      middleName: string | null
      lastName: string
      email: string
      phoneNumber: string | null
      emailVerified: boolean | null
      image: string | null
      role: string | null
      banned: boolean | null
      banReason: string | null
      banExpires: Date | null
      createdAt: Date
      updatedAt: Date
      locationId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends User$membersArgs<ExtArgs> = {}>(args?: Subset<T, User$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends User$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    location<T extends User$locationArgs<ExtArgs> = {}>(args?: Subset<T, User$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    PointOfSale<T extends User$PointOfSaleArgs<ExtArgs> = {}>(args?: Subset<T, User$PointOfSaleArgs<ExtArgs>>): Prisma__PointOfSaleClient<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends User$warehouseArgs<ExtArgs> = {}>(args?: Subset<T, User$warehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    POS<T extends User$POSArgs<ExtArgs> = {}>(args?: Subset<T, User$POSArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly middleName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly banned: FieldRef<"User", 'Boolean'>
    readonly banReason: FieldRef<"User", 'String'>
    readonly banExpires: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly locationId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.members
   */
  export type User$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * User.invitations
   */
  export type User$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.location
   */
  export type User$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * User.PointOfSale
   */
  export type User$PointOfSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleInclude<ExtArgs> | null
    where?: PointOfSaleWhereInput
  }

  /**
   * User.warehouse
   */
  export type User$warehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * User.POS
   */
  export type User$POSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POS
     */
    select?: POSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POS
     */
    omit?: POSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSInclude<ExtArgs> | null
    where?: POSWhereInput
    orderBy?: POSOrderByWithRelationInput | POSOrderByWithRelationInput[]
    cursor?: POSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSScalarFieldEnum | POSScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    impersonatedBy: string | null
    activeOrganizationId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    impersonatedBy: string | null
    activeOrganizationId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    impersonatedBy: number
    activeOrganizationId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    impersonatedBy?: true
    activeOrganizationId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    impersonatedBy?: true
    activeOrganizationId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    impersonatedBy?: true
    activeOrganizationId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    impersonatedBy: string | null
    activeOrganizationId: string | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
    activeOrganizationId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
    activeOrganizationId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
    activeOrganizationId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
    activeOrganizationId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId" | "impersonatedBy" | "activeOrganizationId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
      impersonatedBy: string | null
      activeOrganizationId: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly impersonatedBy: FieldRef<"Session", 'String'>
    readonly activeOrganizationId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    metadata: string | null
    businessName: string | null
    businessType: string | null
    storeBaseCurrency: string | null
    banner: string | null
    phoneNumber: string | null
    email: string | null
    website: string | null
    description: string | null
    country: string | null
    address: string | null
    state: string | null
    region: string | null
    zipCode: string | null
    city: string | null
    status: string | null
    storeTag: string | null
    whitelabel: string | null
    facebook: string | null
    instagram: string | null
    tiktok: string | null
    twitter: string | null
    linkedin: string | null
    currency: string | null
    storeUrl: string | null
    storeApproval: boolean | null
    modifyProductState: boolean | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    metadata: string | null
    businessName: string | null
    businessType: string | null
    storeBaseCurrency: string | null
    banner: string | null
    phoneNumber: string | null
    email: string | null
    website: string | null
    description: string | null
    country: string | null
    address: string | null
    state: string | null
    region: string | null
    zipCode: string | null
    city: string | null
    status: string | null
    storeTag: string | null
    whitelabel: string | null
    facebook: string | null
    instagram: string | null
    tiktok: string | null
    twitter: string | null
    linkedin: string | null
    currency: string | null
    storeUrl: string | null
    storeApproval: boolean | null
    modifyProductState: boolean | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logo: number
    createdAt: number
    updatedAt: number
    metadata: number
    businessName: number
    businessType: number
    storeBaseCurrency: number
    banner: number
    phoneNumber: number
    email: number
    website: number
    description: number
    country: number
    address: number
    state: number
    region: number
    zipCode: number
    city: number
    status: number
    storeTag: number
    whitelabel: number
    facebook: number
    instagram: number
    tiktok: number
    twitter: number
    linkedin: number
    currency: number
    storeUrl: number
    storeApproval: number
    modifyProductState: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    metadata?: true
    businessName?: true
    businessType?: true
    storeBaseCurrency?: true
    banner?: true
    phoneNumber?: true
    email?: true
    website?: true
    description?: true
    country?: true
    address?: true
    state?: true
    region?: true
    zipCode?: true
    city?: true
    status?: true
    storeTag?: true
    whitelabel?: true
    facebook?: true
    instagram?: true
    tiktok?: true
    twitter?: true
    linkedin?: true
    currency?: true
    storeUrl?: true
    storeApproval?: true
    modifyProductState?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    metadata?: true
    businessName?: true
    businessType?: true
    storeBaseCurrency?: true
    banner?: true
    phoneNumber?: true
    email?: true
    website?: true
    description?: true
    country?: true
    address?: true
    state?: true
    region?: true
    zipCode?: true
    city?: true
    status?: true
    storeTag?: true
    whitelabel?: true
    facebook?: true
    instagram?: true
    tiktok?: true
    twitter?: true
    linkedin?: true
    currency?: true
    storeUrl?: true
    storeApproval?: true
    modifyProductState?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    metadata?: true
    businessName?: true
    businessType?: true
    storeBaseCurrency?: true
    banner?: true
    phoneNumber?: true
    email?: true
    website?: true
    description?: true
    country?: true
    address?: true
    state?: true
    region?: true
    zipCode?: true
    city?: true
    status?: true
    storeTag?: true
    whitelabel?: true
    facebook?: true
    instagram?: true
    tiktok?: true
    twitter?: true
    linkedin?: true
    currency?: true
    storeUrl?: true
    storeApproval?: true
    modifyProductState?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    logo: string | null
    createdAt: Date
    updatedAt: Date
    metadata: string | null
    businessName: string | null
    businessType: string | null
    storeBaseCurrency: string | null
    banner: string | null
    phoneNumber: string | null
    email: string | null
    website: string | null
    description: string | null
    country: string | null
    address: string | null
    state: string | null
    region: string | null
    zipCode: string | null
    city: string | null
    status: string | null
    storeTag: string | null
    whitelabel: string | null
    facebook: string | null
    instagram: string | null
    tiktok: string | null
    twitter: string | null
    linkedin: string | null
    currency: string | null
    storeUrl: string | null
    storeApproval: boolean | null
    modifyProductState: boolean | null
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    businessName?: boolean
    businessType?: boolean
    storeBaseCurrency?: boolean
    banner?: boolean
    phoneNumber?: boolean
    email?: boolean
    website?: boolean
    description?: boolean
    country?: boolean
    address?: boolean
    state?: boolean
    region?: boolean
    zipCode?: boolean
    city?: boolean
    status?: boolean
    storeTag?: boolean
    whitelabel?: boolean
    facebook?: boolean
    instagram?: boolean
    tiktok?: boolean
    twitter?: boolean
    linkedin?: boolean
    currency?: boolean
    storeUrl?: boolean
    storeApproval?: boolean
    modifyProductState?: boolean
    members?: boolean | Organization$membersArgs<ExtArgs>
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>
    bankDetails?: boolean | Organization$bankDetailsArgs<ExtArgs>
    wallet?: boolean | Organization$walletArgs<ExtArgs>
    location?: boolean | Organization$locationArgs<ExtArgs>
    order?: boolean | Organization$orderArgs<ExtArgs>
    customer?: boolean | Organization$customerArgs<ExtArgs>
    customerGroups?: boolean | Organization$customerGroupsArgs<ExtArgs>
    expense?: boolean | Organization$expenseArgs<ExtArgs>
    invoice?: boolean | Organization$invoiceArgs<ExtArgs>
    pointOfSale?: boolean | Organization$pointOfSaleArgs<ExtArgs>
    product?: boolean | Organization$productArgs<ExtArgs>
    supplier?: boolean | Organization$supplierArgs<ExtArgs>
    purchase?: boolean | Organization$purchaseArgs<ExtArgs>
    settlements?: boolean | Organization$settlementsArgs<ExtArgs>
    subscription?: boolean | Organization$subscriptionArgs<ExtArgs>
    transaction?: boolean | Organization$transactionArgs<ExtArgs>
    warehouse?: boolean | Organization$warehouseArgs<ExtArgs>
    ShippingMethod?: boolean | Organization$ShippingMethodArgs<ExtArgs>
    ShippingZone?: boolean | Organization$ShippingZoneArgs<ExtArgs>
    productCategory?: boolean | Organization$productCategoryArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    businessName?: boolean
    businessType?: boolean
    storeBaseCurrency?: boolean
    banner?: boolean
    phoneNumber?: boolean
    email?: boolean
    website?: boolean
    description?: boolean
    country?: boolean
    address?: boolean
    state?: boolean
    region?: boolean
    zipCode?: boolean
    city?: boolean
    status?: boolean
    storeTag?: boolean
    whitelabel?: boolean
    facebook?: boolean
    instagram?: boolean
    tiktok?: boolean
    twitter?: boolean
    linkedin?: boolean
    currency?: boolean
    storeUrl?: boolean
    storeApproval?: boolean
    modifyProductState?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    businessName?: boolean
    businessType?: boolean
    storeBaseCurrency?: boolean
    banner?: boolean
    phoneNumber?: boolean
    email?: boolean
    website?: boolean
    description?: boolean
    country?: boolean
    address?: boolean
    state?: boolean
    region?: boolean
    zipCode?: boolean
    city?: boolean
    status?: boolean
    storeTag?: boolean
    whitelabel?: boolean
    facebook?: boolean
    instagram?: boolean
    tiktok?: boolean
    twitter?: boolean
    linkedin?: boolean
    currency?: boolean
    storeUrl?: boolean
    storeApproval?: boolean
    modifyProductState?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    businessName?: boolean
    businessType?: boolean
    storeBaseCurrency?: boolean
    banner?: boolean
    phoneNumber?: boolean
    email?: boolean
    website?: boolean
    description?: boolean
    country?: boolean
    address?: boolean
    state?: boolean
    region?: boolean
    zipCode?: boolean
    city?: boolean
    status?: boolean
    storeTag?: boolean
    whitelabel?: boolean
    facebook?: boolean
    instagram?: boolean
    tiktok?: boolean
    twitter?: boolean
    linkedin?: boolean
    currency?: boolean
    storeUrl?: boolean
    storeApproval?: boolean
    modifyProductState?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "logo" | "createdAt" | "updatedAt" | "metadata" | "businessName" | "businessType" | "storeBaseCurrency" | "banner" | "phoneNumber" | "email" | "website" | "description" | "country" | "address" | "state" | "region" | "zipCode" | "city" | "status" | "storeTag" | "whitelabel" | "facebook" | "instagram" | "tiktok" | "twitter" | "linkedin" | "currency" | "storeUrl" | "storeApproval" | "modifyProductState", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Organization$membersArgs<ExtArgs>
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>
    bankDetails?: boolean | Organization$bankDetailsArgs<ExtArgs>
    wallet?: boolean | Organization$walletArgs<ExtArgs>
    location?: boolean | Organization$locationArgs<ExtArgs>
    order?: boolean | Organization$orderArgs<ExtArgs>
    customer?: boolean | Organization$customerArgs<ExtArgs>
    customerGroups?: boolean | Organization$customerGroupsArgs<ExtArgs>
    expense?: boolean | Organization$expenseArgs<ExtArgs>
    invoice?: boolean | Organization$invoiceArgs<ExtArgs>
    pointOfSale?: boolean | Organization$pointOfSaleArgs<ExtArgs>
    product?: boolean | Organization$productArgs<ExtArgs>
    supplier?: boolean | Organization$supplierArgs<ExtArgs>
    purchase?: boolean | Organization$purchaseArgs<ExtArgs>
    settlements?: boolean | Organization$settlementsArgs<ExtArgs>
    subscription?: boolean | Organization$subscriptionArgs<ExtArgs>
    transaction?: boolean | Organization$transactionArgs<ExtArgs>
    warehouse?: boolean | Organization$warehouseArgs<ExtArgs>
    ShippingMethod?: boolean | Organization$ShippingMethodArgs<ExtArgs>
    ShippingZone?: boolean | Organization$ShippingZoneArgs<ExtArgs>
    productCategory?: boolean | Organization$productCategoryArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
      bankDetails: Prisma.$BankDetailsPayload<ExtArgs> | null
      wallet: Prisma.$WalletPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs>[]
      order: Prisma.$OrderPayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs>[]
      customerGroups: Prisma.$CustomerGroupsPayload<ExtArgs>[]
      expense: Prisma.$ExpensePayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs>[]
      pointOfSale: Prisma.$PointOfSalePayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs>[]
      supplier: Prisma.$SupplierPayload<ExtArgs>[]
      purchase: Prisma.$PurchasePayload<ExtArgs>[]
      settlements: Prisma.$SettlementPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      transaction: Prisma.$TransactionPayload<ExtArgs>[]
      warehouse: Prisma.$WarehousePayload<ExtArgs>[]
      ShippingMethod: Prisma.$ShippingMethodPayload<ExtArgs>[]
      ShippingZone: Prisma.$ShippingZonePayload<ExtArgs>[]
      productCategory: Prisma.$ProductCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
      logo: string | null
      createdAt: Date
      updatedAt: Date
      metadata: string | null
      businessName: string | null
      businessType: string | null
      storeBaseCurrency: string | null
      banner: string | null
      phoneNumber: string | null
      email: string | null
      website: string | null
      description: string | null
      country: string | null
      address: string | null
      state: string | null
      region: string | null
      zipCode: string | null
      city: string | null
      status: string | null
      storeTag: string | null
      whitelabel: string | null
      facebook: string | null
      instagram: string | null
      tiktok: string | null
      twitter: string | null
      linkedin: string | null
      currency: string | null
      storeUrl: string | null
      storeApproval: boolean | null
      modifyProductState: boolean | null
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Organization$membersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Organization$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bankDetails<T extends Organization$bankDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$bankDetailsArgs<ExtArgs>>): Prisma__BankDetailsClient<$Result.GetResult<Prisma.$BankDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    wallet<T extends Organization$walletArgs<ExtArgs> = {}>(args?: Subset<T, Organization$walletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends Organization$locationArgs<ExtArgs> = {}>(args?: Subset<T, Organization$locationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    order<T extends Organization$orderArgs<ExtArgs> = {}>(args?: Subset<T, Organization$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer<T extends Organization$customerArgs<ExtArgs> = {}>(args?: Subset<T, Organization$customerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerGroups<T extends Organization$customerGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$customerGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expense<T extends Organization$expenseArgs<ExtArgs> = {}>(args?: Subset<T, Organization$expenseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends Organization$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Organization$invoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pointOfSale<T extends Organization$pointOfSaleArgs<ExtArgs> = {}>(args?: Subset<T, Organization$pointOfSaleArgs<ExtArgs>>): Prisma__PointOfSaleClient<$Result.GetResult<Prisma.$PointOfSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends Organization$productArgs<ExtArgs> = {}>(args?: Subset<T, Organization$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supplier<T extends Organization$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Organization$supplierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchase<T extends Organization$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, Organization$purchaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settlements<T extends Organization$settlementsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$settlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends Organization$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Organization$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transaction<T extends Organization$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Organization$transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warehouse<T extends Organization$warehouseArgs<ExtArgs> = {}>(args?: Subset<T, Organization$warehouseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ShippingMethod<T extends Organization$ShippingMethodArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ShippingMethodArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ShippingZone<T extends Organization$ShippingZoneArgs<ExtArgs> = {}>(args?: Subset<T, Organization$ShippingZoneArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productCategory<T extends Organization$productCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Organization$productCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly logo: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
    readonly metadata: FieldRef<"Organization", 'String'>
    readonly businessName: FieldRef<"Organization", 'String'>
    readonly businessType: FieldRef<"Organization", 'String'>
    readonly storeBaseCurrency: FieldRef<"Organization", 'String'>
    readonly banner: FieldRef<"Organization", 'String'>
    readonly phoneNumber: FieldRef<"Organization", 'String'>
    readonly email: FieldRef<"Organization", 'String'>
    readonly website: FieldRef<"Organization", 'String'>
    readonly description: FieldRef<"Organization", 'String'>
    readonly country: FieldRef<"Organization", 'String'>
    readonly address: FieldRef<"Organization", 'String'>
    readonly state: FieldRef<"Organization", 'String'>
    readonly region: FieldRef<"Organization", 'String'>
    readonly zipCode: FieldRef<"Organization", 'String'>
    readonly city: FieldRef<"Organization", 'String'>
    readonly status: FieldRef<"Organization", 'String'>
    readonly storeTag: FieldRef<"Organization", 'String'>
    readonly whitelabel: FieldRef<"Organization", 'String'>
    readonly facebook: FieldRef<"Organization", 'String'>
    readonly instagram: FieldRef<"Organization", 'String'>
    readonly tiktok: FieldRef<"Organization", 'String'>
    readonly twitter: FieldRef<"Organization", 'String'>
    readonly linkedin: FieldRef<"Organization", 'String'>
    readonly currency: FieldRef<"Organization", 'String'>
    readonly storeUrl: FieldRef<"Organization", 'String'>
    readonly storeApproval: FieldRef<"Organization", 'Boolean'>
    readonly modifyProductState: FieldRef<"Organization", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.members
   */
  export type Organization$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Organization.invitations
   */
  export type Organization$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Organization.bankDetails
   */
  export type Organization$bankDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetails
     */
    select?: BankDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetails
     */
    omit?: BankDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailsInclude<ExtArgs> | null
    where?: BankDetailsWhereInput
  }

  /**
   * Organization.wallet
   */
  export type Organization$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * Organization.location
   */
  export type Organization$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Organization.order
   */
  export type Organization$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Organization.customer
   */
  export type Organization$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Organization.customerGroups
   */
  export type Organization$customerGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroups
     */
    select?: CustomerGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroups
     */
    omit?: CustomerGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupsInclude<ExtArgs> | null
    where?: CustomerGroupsWhereInput
    orderBy?: CustomerGroupsOrderByWithRelationInput | CustomerGroupsOrderByWithRelationInput[]
    cursor?: CustomerGroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerGroupsScalarFieldEnum | CustomerGroupsScalarFieldEnum[]
  }

  /**
   * Organization.expense
   */
  export type Organization$expenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Organization.invoice
   */
  export type Organization$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Organization.pointOfSale
   */
  export type Organization$pointOfSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointOfSale
     */
    select?: PointOfSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointOfSale
     */
    omit?: PointOfSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointOfSaleInclude<ExtArgs> | null
    where?: PointOfSaleWhereInput
  }

  /**
   * Organization.product
   */
  export type Organization$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Organization.supplier
   */
  export type Organization$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Organization.purchase
   */
  export type Organization$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Purchase
     */
    omit?: PurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Organization.settlements
   */
  export type Organization$settlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    where?: SettlementWhereInput
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    cursor?: SettlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettlementScalarFieldEnum | SettlementScalarFieldEnum[]
  }

  /**
   * Organization.subscription
   */
  export type Organization$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Organization.transaction
   */
  export type Organization$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Organization.warehouse
   */
  export type Organization$warehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    cursor?: WarehouseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Organization.ShippingMethod
   */
  export type Organization$ShippingMethodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    where?: ShippingMethodWhereInput
    orderBy?: ShippingMethodOrderByWithRelationInput | ShippingMethodOrderByWithRelationInput[]
    cursor?: ShippingMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShippingMethodScalarFieldEnum | ShippingMethodScalarFieldEnum[]
  }

  /**
   * Organization.ShippingZone
   */
  export type Organization$ShippingZoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneInclude<ExtArgs> | null
    where?: ShippingZoneWhereInput
    orderBy?: ShippingZoneOrderByWithRelationInput | ShippingZoneOrderByWithRelationInput[]
    cursor?: ShippingZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShippingZoneScalarFieldEnum | ShippingZoneScalarFieldEnum[]
  }

  /**
   * Organization.productCategory
   */
  export type Organization$productCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    organizationId: string
    userId: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "userId" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      userId: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly organizationId: FieldRef<"Member", 'String'>
    readonly userId: FieldRef<"Member", 'String'>
    readonly role: FieldRef<"Member", 'String'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    email: string | null
    role: string | null
    status: string | null
    expiresAt: Date | null
    inviterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    email: string | null
    role: string | null
    status: string | null
    expiresAt: Date | null
    inviterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    organizationId: number
    email: number
    role: number
    status: number
    expiresAt: number
    inviterId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    role?: true
    status?: true
    expiresAt?: true
    inviterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    role?: true
    status?: true
    expiresAt?: true
    inviterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    role?: true
    status?: true
    expiresAt?: true
    inviterId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    organizationId: string
    email: string
    role: string | null
    status: string
    expiresAt: Date
    inviterId: string
    createdAt: Date
    updatedAt: Date
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "email" | "role" | "status" | "expiresAt" | "inviterId" | "createdAt" | "updatedAt", ExtArgs["result"]["invitation"]>
  export type InvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      email: string
      role: string | null
      status: string
      expiresAt: Date
      inviterId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {InvitationUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */
  interface InvitationFieldRefs {
    readonly id: FieldRef<"Invitation", 'String'>
    readonly organizationId: FieldRef<"Invitation", 'String'>
    readonly email: FieldRef<"Invitation", 'String'>
    readonly role: FieldRef<"Invitation", 'String'>
    readonly status: FieldRef<"Invitation", 'String'>
    readonly expiresAt: FieldRef<"Invitation", 'DateTime'>
    readonly inviterId: FieldRef<"Invitation", 'String'>
    readonly createdAt: FieldRef<"Invitation", 'DateTime'>
    readonly updatedAt: FieldRef<"Invitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
  }

  /**
   * Invitation updateManyAndReturn
   */
  export type InvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to delete.
     */
    limit?: number
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
  }


  /**
   * Model Settlement
   */

  export type AggregateSettlement = {
    _count: SettlementCountAggregateOutputType | null
    _avg: SettlementAvgAggregateOutputType | null
    _sum: SettlementSumAggregateOutputType | null
    _min: SettlementMinAggregateOutputType | null
    _max: SettlementMaxAggregateOutputType | null
  }

  export type SettlementAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type SettlementSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type SettlementMinAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettlementMaxAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettlementCountAggregateOutputType = {
    id: number
    amount: number
    storeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettlementAvgAggregateInputType = {
    amount?: true
  }

  export type SettlementSumAggregateInputType = {
    amount?: true
  }

  export type SettlementMinAggregateInputType = {
    id?: true
    amount?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettlementMaxAggregateInputType = {
    id?: true
    amount?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettlementCountAggregateInputType = {
    id?: true
    amount?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settlement to aggregate.
     */
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     */
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settlements
    **/
    _count?: true | SettlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettlementMaxAggregateInputType
  }

  export type GetSettlementAggregateType<T extends SettlementAggregateArgs> = {
        [P in keyof T & keyof AggregateSettlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettlement[P]>
      : GetScalarType<T[P], AggregateSettlement[P]>
  }




  export type SettlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettlementWhereInput
    orderBy?: SettlementOrderByWithAggregationInput | SettlementOrderByWithAggregationInput[]
    by: SettlementScalarFieldEnum[] | SettlementScalarFieldEnum
    having?: SettlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettlementCountAggregateInputType | true
    _avg?: SettlementAvgAggregateInputType
    _sum?: SettlementSumAggregateInputType
    _min?: SettlementMinAggregateInputType
    _max?: SettlementMaxAggregateInputType
  }

  export type SettlementGroupByOutputType = {
    id: string
    amount: Decimal
    storeId: string
    createdAt: Date
    updatedAt: Date
    _count: SettlementCountAggregateOutputType | null
    _avg: SettlementAvgAggregateOutputType | null
    _sum: SettlementSumAggregateOutputType | null
    _min: SettlementMinAggregateOutputType | null
    _max: SettlementMaxAggregateOutputType | null
  }

  type GetSettlementGroupByPayload<T extends SettlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettlementGroupByOutputType[P]>
            : GetScalarType<T[P], SettlementGroupByOutputType[P]>
        }
      >
    >


  export type SettlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settlement"]>

  export type SettlementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settlement"]>

  export type SettlementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settlement"]>

  export type SettlementSelectScalar = {
    id?: boolean
    amount?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettlementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "storeId" | "createdAt" | "updatedAt", ExtArgs["result"]["settlement"]>
  export type SettlementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SettlementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type SettlementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $SettlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settlement"
    objects: {
      store: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: Prisma.Decimal
      storeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["settlement"]>
    composites: {}
  }

  type SettlementGetPayload<S extends boolean | null | undefined | SettlementDefaultArgs> = $Result.GetResult<Prisma.$SettlementPayload, S>

  type SettlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettlementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettlementCountAggregateInputType | true
    }

  export interface SettlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settlement'], meta: { name: 'Settlement' } }
    /**
     * Find zero or one Settlement that matches the filter.
     * @param {SettlementFindUniqueArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettlementFindUniqueArgs>(args: SelectSubset<T, SettlementFindUniqueArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settlement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettlementFindUniqueOrThrowArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettlementFindUniqueOrThrowArgs>(args: SelectSubset<T, SettlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementFindFirstArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettlementFindFirstArgs>(args?: SelectSubset<T, SettlementFindFirstArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementFindFirstOrThrowArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettlementFindFirstOrThrowArgs>(args?: SelectSubset<T, SettlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settlements
     * const settlements = await prisma.settlement.findMany()
     * 
     * // Get first 10 Settlements
     * const settlements = await prisma.settlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settlementWithIdOnly = await prisma.settlement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettlementFindManyArgs>(args?: SelectSubset<T, SettlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settlement.
     * @param {SettlementCreateArgs} args - Arguments to create a Settlement.
     * @example
     * // Create one Settlement
     * const Settlement = await prisma.settlement.create({
     *   data: {
     *     // ... data to create a Settlement
     *   }
     * })
     * 
     */
    create<T extends SettlementCreateArgs>(args: SelectSubset<T, SettlementCreateArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settlements.
     * @param {SettlementCreateManyArgs} args - Arguments to create many Settlements.
     * @example
     * // Create many Settlements
     * const settlement = await prisma.settlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettlementCreateManyArgs>(args?: SelectSubset<T, SettlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settlements and returns the data saved in the database.
     * @param {SettlementCreateManyAndReturnArgs} args - Arguments to create many Settlements.
     * @example
     * // Create many Settlements
     * const settlement = await prisma.settlement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settlements and only return the `id`
     * const settlementWithIdOnly = await prisma.settlement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettlementCreateManyAndReturnArgs>(args?: SelectSubset<T, SettlementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settlement.
     * @param {SettlementDeleteArgs} args - Arguments to delete one Settlement.
     * @example
     * // Delete one Settlement
     * const Settlement = await prisma.settlement.delete({
     *   where: {
     *     // ... filter to delete one Settlement
     *   }
     * })
     * 
     */
    delete<T extends SettlementDeleteArgs>(args: SelectSubset<T, SettlementDeleteArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settlement.
     * @param {SettlementUpdateArgs} args - Arguments to update one Settlement.
     * @example
     * // Update one Settlement
     * const settlement = await prisma.settlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettlementUpdateArgs>(args: SelectSubset<T, SettlementUpdateArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settlements.
     * @param {SettlementDeleteManyArgs} args - Arguments to filter Settlements to delete.
     * @example
     * // Delete a few Settlements
     * const { count } = await prisma.settlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettlementDeleteManyArgs>(args?: SelectSubset<T, SettlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settlements
     * const settlement = await prisma.settlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettlementUpdateManyArgs>(args: SelectSubset<T, SettlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settlements and returns the data updated in the database.
     * @param {SettlementUpdateManyAndReturnArgs} args - Arguments to update many Settlements.
     * @example
     * // Update many Settlements
     * const settlement = await prisma.settlement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settlements and only return the `id`
     * const settlementWithIdOnly = await prisma.settlement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettlementUpdateManyAndReturnArgs>(args: SelectSubset<T, SettlementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settlement.
     * @param {SettlementUpsertArgs} args - Arguments to update or create a Settlement.
     * @example
     * // Update or create a Settlement
     * const settlement = await prisma.settlement.upsert({
     *   create: {
     *     // ... data to create a Settlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settlement we want to update
     *   }
     * })
     */
    upsert<T extends SettlementUpsertArgs>(args: SelectSubset<T, SettlementUpsertArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementCountArgs} args - Arguments to filter Settlements to count.
     * @example
     * // Count the number of Settlements
     * const count = await prisma.settlement.count({
     *   where: {
     *     // ... the filter for the Settlements we want to count
     *   }
     * })
    **/
    count<T extends SettlementCountArgs>(
      args?: Subset<T, SettlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettlementAggregateArgs>(args: Subset<T, SettlementAggregateArgs>): Prisma.PrismaPromise<GetSettlementAggregateType<T>>

    /**
     * Group by Settlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettlementGroupByArgs['orderBy'] }
        : { orderBy?: SettlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settlement model
   */
  readonly fields: SettlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settlement model
   */
  interface SettlementFieldRefs {
    readonly id: FieldRef<"Settlement", 'String'>
    readonly amount: FieldRef<"Settlement", 'Decimal'>
    readonly storeId: FieldRef<"Settlement", 'String'>
    readonly createdAt: FieldRef<"Settlement", 'DateTime'>
    readonly updatedAt: FieldRef<"Settlement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settlement findUnique
   */
  export type SettlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlement to fetch.
     */
    where: SettlementWhereUniqueInput
  }

  /**
   * Settlement findUniqueOrThrow
   */
  export type SettlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlement to fetch.
     */
    where: SettlementWhereUniqueInput
  }

  /**
   * Settlement findFirst
   */
  export type SettlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlement to fetch.
     */
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     */
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settlements.
     */
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settlements.
     */
    distinct?: SettlementScalarFieldEnum | SettlementScalarFieldEnum[]
  }

  /**
   * Settlement findFirstOrThrow
   */
  export type SettlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlement to fetch.
     */
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     */
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settlements.
     */
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settlements.
     */
    distinct?: SettlementScalarFieldEnum | SettlementScalarFieldEnum[]
  }

  /**
   * Settlement findMany
   */
  export type SettlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlements to fetch.
     */
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     */
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settlements.
     */
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     */
    skip?: number
    distinct?: SettlementScalarFieldEnum | SettlementScalarFieldEnum[]
  }

  /**
   * Settlement create
   */
  export type SettlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * The data needed to create a Settlement.
     */
    data: XOR<SettlementCreateInput, SettlementUncheckedCreateInput>
  }

  /**
   * Settlement createMany
   */
  export type SettlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settlements.
     */
    data: SettlementCreateManyInput | SettlementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settlement createManyAndReturn
   */
  export type SettlementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * The data used to create many Settlements.
     */
    data: SettlementCreateManyInput | SettlementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Settlement update
   */
  export type SettlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * The data needed to update a Settlement.
     */
    data: XOR<SettlementUpdateInput, SettlementUncheckedUpdateInput>
    /**
     * Choose, which Settlement to update.
     */
    where: SettlementWhereUniqueInput
  }

  /**
   * Settlement updateMany
   */
  export type SettlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settlements.
     */
    data: XOR<SettlementUpdateManyMutationInput, SettlementUncheckedUpdateManyInput>
    /**
     * Filter which Settlements to update
     */
    where?: SettlementWhereInput
    /**
     * Limit how many Settlements to update.
     */
    limit?: number
  }

  /**
   * Settlement updateManyAndReturn
   */
  export type SettlementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * The data used to update Settlements.
     */
    data: XOR<SettlementUpdateManyMutationInput, SettlementUncheckedUpdateManyInput>
    /**
     * Filter which Settlements to update
     */
    where?: SettlementWhereInput
    /**
     * Limit how many Settlements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Settlement upsert
   */
  export type SettlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * The filter to search for the Settlement to update in case it exists.
     */
    where: SettlementWhereUniqueInput
    /**
     * In case the Settlement found by the `where` argument doesn't exist, create a new Settlement with this data.
     */
    create: XOR<SettlementCreateInput, SettlementUncheckedCreateInput>
    /**
     * In case the Settlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettlementUpdateInput, SettlementUncheckedUpdateInput>
  }

  /**
   * Settlement delete
   */
  export type SettlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter which Settlement to delete.
     */
    where: SettlementWhereUniqueInput
  }

  /**
   * Settlement deleteMany
   */
  export type SettlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settlements to delete
     */
    where?: SettlementWhereInput
    /**
     * Limit how many Settlements to delete.
     */
    limit?: number
  }

  /**
   * Settlement without action
   */
  export type SettlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settlement
     */
    omit?: SettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
  }


  /**
   * Model Shipping
   */

  export type AggregateShipping = {
    _count: ShippingCountAggregateOutputType | null
    _avg: ShippingAvgAggregateOutputType | null
    _sum: ShippingSumAggregateOutputType | null
    _min: ShippingMinAggregateOutputType | null
    _max: ShippingMaxAggregateOutputType | null
  }

  export type ShippingAvgAggregateOutputType = {
    shippingFee: Decimal | null
    weight: number | null
  }

  export type ShippingSumAggregateOutputType = {
    shippingFee: Decimal | null
    weight: number | null
  }

  export type ShippingMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    shippingMethodId: string | null
    trackingNumber: string | null
    carrier: string | null
    status: $Enums.ShippingStatus | null
    estimatedDelivery: Date | null
    actualDelivery: Date | null
    shippingAddress: string | null
    shippingZoneName: string | null
    shippingFee: Decimal | null
    weight: number | null
    dimensions: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    shippingMethodId: string | null
    trackingNumber: string | null
    carrier: string | null
    status: $Enums.ShippingStatus | null
    estimatedDelivery: Date | null
    actualDelivery: Date | null
    shippingAddress: string | null
    shippingZoneName: string | null
    shippingFee: Decimal | null
    weight: number | null
    dimensions: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingCountAggregateOutputType = {
    id: number
    orderId: number
    shippingMethodId: number
    trackingNumber: number
    carrier: number
    status: number
    estimatedDelivery: number
    actualDelivery: number
    shippingAddress: number
    shippingZoneName: number
    shippingFee: number
    weight: number
    dimensions: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShippingAvgAggregateInputType = {
    shippingFee?: true
    weight?: true
  }

  export type ShippingSumAggregateInputType = {
    shippingFee?: true
    weight?: true
  }

  export type ShippingMinAggregateInputType = {
    id?: true
    orderId?: true
    shippingMethodId?: true
    trackingNumber?: true
    carrier?: true
    status?: true
    estimatedDelivery?: true
    actualDelivery?: true
    shippingAddress?: true
    shippingZoneName?: true
    shippingFee?: true
    weight?: true
    dimensions?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingMaxAggregateInputType = {
    id?: true
    orderId?: true
    shippingMethodId?: true
    trackingNumber?: true
    carrier?: true
    status?: true
    estimatedDelivery?: true
    actualDelivery?: true
    shippingAddress?: true
    shippingZoneName?: true
    shippingFee?: true
    weight?: true
    dimensions?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingCountAggregateInputType = {
    id?: true
    orderId?: true
    shippingMethodId?: true
    trackingNumber?: true
    carrier?: true
    status?: true
    estimatedDelivery?: true
    actualDelivery?: true
    shippingAddress?: true
    shippingZoneName?: true
    shippingFee?: true
    weight?: true
    dimensions?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShippingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipping to aggregate.
     */
    where?: ShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shippings to fetch.
     */
    orderBy?: ShippingOrderByWithRelationInput | ShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shippings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shippings
    **/
    _count?: true | ShippingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShippingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShippingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingMaxAggregateInputType
  }

  export type GetShippingAggregateType<T extends ShippingAggregateArgs> = {
        [P in keyof T & keyof AggregateShipping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipping[P]>
      : GetScalarType<T[P], AggregateShipping[P]>
  }




  export type ShippingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingWhereInput
    orderBy?: ShippingOrderByWithAggregationInput | ShippingOrderByWithAggregationInput[]
    by: ShippingScalarFieldEnum[] | ShippingScalarFieldEnum
    having?: ShippingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingCountAggregateInputType | true
    _avg?: ShippingAvgAggregateInputType
    _sum?: ShippingSumAggregateInputType
    _min?: ShippingMinAggregateInputType
    _max?: ShippingMaxAggregateInputType
  }

  export type ShippingGroupByOutputType = {
    id: string
    orderId: string
    shippingMethodId: string
    trackingNumber: string | null
    carrier: string | null
    status: $Enums.ShippingStatus
    estimatedDelivery: Date | null
    actualDelivery: Date | null
    shippingAddress: string
    shippingZoneName: string | null
    shippingFee: Decimal
    weight: number | null
    dimensions: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShippingCountAggregateOutputType | null
    _avg: ShippingAvgAggregateOutputType | null
    _sum: ShippingSumAggregateOutputType | null
    _min: ShippingMinAggregateOutputType | null
    _max: ShippingMaxAggregateOutputType | null
  }

  type GetShippingGroupByPayload<T extends ShippingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShippingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingGroupByOutputType[P]>
        }
      >
    >


  export type ShippingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    shippingMethodId?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    status?: boolean
    estimatedDelivery?: boolean
    actualDelivery?: boolean
    shippingAddress?: boolean
    shippingZoneName?: boolean
    shippingFee?: boolean
    weight?: boolean
    dimensions?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shippingMethod?: boolean | ShippingMethodDefaultArgs<ExtArgs>
    auditLogs?: boolean | Shipping$auditLogsArgs<ExtArgs>
    _count?: boolean | ShippingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipping"]>

  export type ShippingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    shippingMethodId?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    status?: boolean
    estimatedDelivery?: boolean
    actualDelivery?: boolean
    shippingAddress?: boolean
    shippingZoneName?: boolean
    shippingFee?: boolean
    weight?: boolean
    dimensions?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shippingMethod?: boolean | ShippingMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipping"]>

  export type ShippingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    shippingMethodId?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    status?: boolean
    estimatedDelivery?: boolean
    actualDelivery?: boolean
    shippingAddress?: boolean
    shippingZoneName?: boolean
    shippingFee?: boolean
    weight?: boolean
    dimensions?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shippingMethod?: boolean | ShippingMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipping"]>

  export type ShippingSelectScalar = {
    id?: boolean
    orderId?: boolean
    shippingMethodId?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    status?: boolean
    estimatedDelivery?: boolean
    actualDelivery?: boolean
    shippingAddress?: boolean
    shippingZoneName?: boolean
    shippingFee?: boolean
    weight?: boolean
    dimensions?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShippingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "shippingMethodId" | "trackingNumber" | "carrier" | "status" | "estimatedDelivery" | "actualDelivery" | "shippingAddress" | "shippingZoneName" | "shippingFee" | "weight" | "dimensions" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["shipping"]>
  export type ShippingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shippingMethod?: boolean | ShippingMethodDefaultArgs<ExtArgs>
    auditLogs?: boolean | Shipping$auditLogsArgs<ExtArgs>
    _count?: boolean | ShippingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShippingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shippingMethod?: boolean | ShippingMethodDefaultArgs<ExtArgs>
  }
  export type ShippingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shippingMethod?: boolean | ShippingMethodDefaultArgs<ExtArgs>
  }

  export type $ShippingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shipping"
    objects: {
      shippingMethod: Prisma.$ShippingMethodPayload<ExtArgs>
      auditLogs: Prisma.$ShippingAuditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      shippingMethodId: string
      trackingNumber: string | null
      carrier: string | null
      status: $Enums.ShippingStatus
      estimatedDelivery: Date | null
      actualDelivery: Date | null
      shippingAddress: string
      shippingZoneName: string | null
      shippingFee: Prisma.Decimal
      weight: number | null
      dimensions: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shipping"]>
    composites: {}
  }

  type ShippingGetPayload<S extends boolean | null | undefined | ShippingDefaultArgs> = $Result.GetResult<Prisma.$ShippingPayload, S>

  type ShippingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShippingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShippingCountAggregateInputType | true
    }

  export interface ShippingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shipping'], meta: { name: 'Shipping' } }
    /**
     * Find zero or one Shipping that matches the filter.
     * @param {ShippingFindUniqueArgs} args - Arguments to find a Shipping
     * @example
     * // Get one Shipping
     * const shipping = await prisma.shipping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShippingFindUniqueArgs>(args: SelectSubset<T, ShippingFindUniqueArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shipping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShippingFindUniqueOrThrowArgs} args - Arguments to find a Shipping
     * @example
     * // Get one Shipping
     * const shipping = await prisma.shipping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShippingFindUniqueOrThrowArgs>(args: SelectSubset<T, ShippingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shipping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingFindFirstArgs} args - Arguments to find a Shipping
     * @example
     * // Get one Shipping
     * const shipping = await prisma.shipping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShippingFindFirstArgs>(args?: SelectSubset<T, ShippingFindFirstArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shipping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingFindFirstOrThrowArgs} args - Arguments to find a Shipping
     * @example
     * // Get one Shipping
     * const shipping = await prisma.shipping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShippingFindFirstOrThrowArgs>(args?: SelectSubset<T, ShippingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shippings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shippings
     * const shippings = await prisma.shipping.findMany()
     * 
     * // Get first 10 Shippings
     * const shippings = await prisma.shipping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingWithIdOnly = await prisma.shipping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShippingFindManyArgs>(args?: SelectSubset<T, ShippingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shipping.
     * @param {ShippingCreateArgs} args - Arguments to create a Shipping.
     * @example
     * // Create one Shipping
     * const Shipping = await prisma.shipping.create({
     *   data: {
     *     // ... data to create a Shipping
     *   }
     * })
     * 
     */
    create<T extends ShippingCreateArgs>(args: SelectSubset<T, ShippingCreateArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shippings.
     * @param {ShippingCreateManyArgs} args - Arguments to create many Shippings.
     * @example
     * // Create many Shippings
     * const shipping = await prisma.shipping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShippingCreateManyArgs>(args?: SelectSubset<T, ShippingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shippings and returns the data saved in the database.
     * @param {ShippingCreateManyAndReturnArgs} args - Arguments to create many Shippings.
     * @example
     * // Create many Shippings
     * const shipping = await prisma.shipping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shippings and only return the `id`
     * const shippingWithIdOnly = await prisma.shipping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShippingCreateManyAndReturnArgs>(args?: SelectSubset<T, ShippingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shipping.
     * @param {ShippingDeleteArgs} args - Arguments to delete one Shipping.
     * @example
     * // Delete one Shipping
     * const Shipping = await prisma.shipping.delete({
     *   where: {
     *     // ... filter to delete one Shipping
     *   }
     * })
     * 
     */
    delete<T extends ShippingDeleteArgs>(args: SelectSubset<T, ShippingDeleteArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shipping.
     * @param {ShippingUpdateArgs} args - Arguments to update one Shipping.
     * @example
     * // Update one Shipping
     * const shipping = await prisma.shipping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShippingUpdateArgs>(args: SelectSubset<T, ShippingUpdateArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shippings.
     * @param {ShippingDeleteManyArgs} args - Arguments to filter Shippings to delete.
     * @example
     * // Delete a few Shippings
     * const { count } = await prisma.shipping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShippingDeleteManyArgs>(args?: SelectSubset<T, ShippingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shippings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shippings
     * const shipping = await prisma.shipping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShippingUpdateManyArgs>(args: SelectSubset<T, ShippingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shippings and returns the data updated in the database.
     * @param {ShippingUpdateManyAndReturnArgs} args - Arguments to update many Shippings.
     * @example
     * // Update many Shippings
     * const shipping = await prisma.shipping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shippings and only return the `id`
     * const shippingWithIdOnly = await prisma.shipping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShippingUpdateManyAndReturnArgs>(args: SelectSubset<T, ShippingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shipping.
     * @param {ShippingUpsertArgs} args - Arguments to update or create a Shipping.
     * @example
     * // Update or create a Shipping
     * const shipping = await prisma.shipping.upsert({
     *   create: {
     *     // ... data to create a Shipping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shipping we want to update
     *   }
     * })
     */
    upsert<T extends ShippingUpsertArgs>(args: SelectSubset<T, ShippingUpsertArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shippings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingCountArgs} args - Arguments to filter Shippings to count.
     * @example
     * // Count the number of Shippings
     * const count = await prisma.shipping.count({
     *   where: {
     *     // ... the filter for the Shippings we want to count
     *   }
     * })
    **/
    count<T extends ShippingCountArgs>(
      args?: Subset<T, ShippingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shipping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingAggregateArgs>(args: Subset<T, ShippingAggregateArgs>): Prisma.PrismaPromise<GetShippingAggregateType<T>>

    /**
     * Group by Shipping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingGroupByArgs['orderBy'] }
        : { orderBy?: ShippingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shipping model
   */
  readonly fields: ShippingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shipping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShippingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shippingMethod<T extends ShippingMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShippingMethodDefaultArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    auditLogs<T extends Shipping$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Shipping$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shipping model
   */
  interface ShippingFieldRefs {
    readonly id: FieldRef<"Shipping", 'String'>
    readonly orderId: FieldRef<"Shipping", 'String'>
    readonly shippingMethodId: FieldRef<"Shipping", 'String'>
    readonly trackingNumber: FieldRef<"Shipping", 'String'>
    readonly carrier: FieldRef<"Shipping", 'String'>
    readonly status: FieldRef<"Shipping", 'ShippingStatus'>
    readonly estimatedDelivery: FieldRef<"Shipping", 'DateTime'>
    readonly actualDelivery: FieldRef<"Shipping", 'DateTime'>
    readonly shippingAddress: FieldRef<"Shipping", 'String'>
    readonly shippingZoneName: FieldRef<"Shipping", 'String'>
    readonly shippingFee: FieldRef<"Shipping", 'Decimal'>
    readonly weight: FieldRef<"Shipping", 'Float'>
    readonly dimensions: FieldRef<"Shipping", 'String'>
    readonly notes: FieldRef<"Shipping", 'String'>
    readonly createdAt: FieldRef<"Shipping", 'DateTime'>
    readonly updatedAt: FieldRef<"Shipping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shipping findUnique
   */
  export type ShippingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * Filter, which Shipping to fetch.
     */
    where: ShippingWhereUniqueInput
  }

  /**
   * Shipping findUniqueOrThrow
   */
  export type ShippingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * Filter, which Shipping to fetch.
     */
    where: ShippingWhereUniqueInput
  }

  /**
   * Shipping findFirst
   */
  export type ShippingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * Filter, which Shipping to fetch.
     */
    where?: ShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shippings to fetch.
     */
    orderBy?: ShippingOrderByWithRelationInput | ShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shippings.
     */
    cursor?: ShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shippings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shippings.
     */
    distinct?: ShippingScalarFieldEnum | ShippingScalarFieldEnum[]
  }

  /**
   * Shipping findFirstOrThrow
   */
  export type ShippingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * Filter, which Shipping to fetch.
     */
    where?: ShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shippings to fetch.
     */
    orderBy?: ShippingOrderByWithRelationInput | ShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shippings.
     */
    cursor?: ShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shippings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shippings.
     */
    distinct?: ShippingScalarFieldEnum | ShippingScalarFieldEnum[]
  }

  /**
   * Shipping findMany
   */
  export type ShippingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * Filter, which Shippings to fetch.
     */
    where?: ShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shippings to fetch.
     */
    orderBy?: ShippingOrderByWithRelationInput | ShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shippings.
     */
    cursor?: ShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shippings.
     */
    skip?: number
    distinct?: ShippingScalarFieldEnum | ShippingScalarFieldEnum[]
  }

  /**
   * Shipping create
   */
  export type ShippingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * The data needed to create a Shipping.
     */
    data: XOR<ShippingCreateInput, ShippingUncheckedCreateInput>
  }

  /**
   * Shipping createMany
   */
  export type ShippingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shippings.
     */
    data: ShippingCreateManyInput | ShippingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shipping createManyAndReturn
   */
  export type ShippingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * The data used to create many Shippings.
     */
    data: ShippingCreateManyInput | ShippingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shipping update
   */
  export type ShippingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * The data needed to update a Shipping.
     */
    data: XOR<ShippingUpdateInput, ShippingUncheckedUpdateInput>
    /**
     * Choose, which Shipping to update.
     */
    where: ShippingWhereUniqueInput
  }

  /**
   * Shipping updateMany
   */
  export type ShippingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shippings.
     */
    data: XOR<ShippingUpdateManyMutationInput, ShippingUncheckedUpdateManyInput>
    /**
     * Filter which Shippings to update
     */
    where?: ShippingWhereInput
    /**
     * Limit how many Shippings to update.
     */
    limit?: number
  }

  /**
   * Shipping updateManyAndReturn
   */
  export type ShippingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * The data used to update Shippings.
     */
    data: XOR<ShippingUpdateManyMutationInput, ShippingUncheckedUpdateManyInput>
    /**
     * Filter which Shippings to update
     */
    where?: ShippingWhereInput
    /**
     * Limit how many Shippings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shipping upsert
   */
  export type ShippingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * The filter to search for the Shipping to update in case it exists.
     */
    where: ShippingWhereUniqueInput
    /**
     * In case the Shipping found by the `where` argument doesn't exist, create a new Shipping with this data.
     */
    create: XOR<ShippingCreateInput, ShippingUncheckedCreateInput>
    /**
     * In case the Shipping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShippingUpdateInput, ShippingUncheckedUpdateInput>
  }

  /**
   * Shipping delete
   */
  export type ShippingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    /**
     * Filter which Shipping to delete.
     */
    where: ShippingWhereUniqueInput
  }

  /**
   * Shipping deleteMany
   */
  export type ShippingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shippings to delete
     */
    where?: ShippingWhereInput
    /**
     * Limit how many Shippings to delete.
     */
    limit?: number
  }

  /**
   * Shipping.auditLogs
   */
  export type Shipping$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditInclude<ExtArgs> | null
    where?: ShippingAuditWhereInput
    orderBy?: ShippingAuditOrderByWithRelationInput | ShippingAuditOrderByWithRelationInput[]
    cursor?: ShippingAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShippingAuditScalarFieldEnum | ShippingAuditScalarFieldEnum[]
  }

  /**
   * Shipping without action
   */
  export type ShippingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
  }


  /**
   * Model ShippingMethod
   */

  export type AggregateShippingMethod = {
    _count: ShippingMethodCountAggregateOutputType | null
    _avg: ShippingMethodAvgAggregateOutputType | null
    _sum: ShippingMethodSumAggregateOutputType | null
    _min: ShippingMethodMinAggregateOutputType | null
    _max: ShippingMethodMaxAggregateOutputType | null
  }

  export type ShippingMethodAvgAggregateOutputType = {
    baseCost: number | null
  }

  export type ShippingMethodSumAggregateOutputType = {
    baseCost: number | null
  }

  export type ShippingMethodMinAggregateOutputType = {
    id: string | null
    name: string | null
    storeId: string | null
    description: string | null
    carrier: string | null
    deliveryTime: string | null
    baseCost: number | null
    costCalculation: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingMethodMaxAggregateOutputType = {
    id: string | null
    name: string | null
    storeId: string | null
    description: string | null
    carrier: string | null
    deliveryTime: string | null
    baseCost: number | null
    costCalculation: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingMethodCountAggregateOutputType = {
    id: number
    name: number
    storeId: number
    description: number
    carrier: number
    deliveryTime: number
    baseCost: number
    costCalculation: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShippingMethodAvgAggregateInputType = {
    baseCost?: true
  }

  export type ShippingMethodSumAggregateInputType = {
    baseCost?: true
  }

  export type ShippingMethodMinAggregateInputType = {
    id?: true
    name?: true
    storeId?: true
    description?: true
    carrier?: true
    deliveryTime?: true
    baseCost?: true
    costCalculation?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingMethodMaxAggregateInputType = {
    id?: true
    name?: true
    storeId?: true
    description?: true
    carrier?: true
    deliveryTime?: true
    baseCost?: true
    costCalculation?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingMethodCountAggregateInputType = {
    id?: true
    name?: true
    storeId?: true
    description?: true
    carrier?: true
    deliveryTime?: true
    baseCost?: true
    costCalculation?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShippingMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingMethod to aggregate.
     */
    where?: ShippingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingMethods to fetch.
     */
    orderBy?: ShippingMethodOrderByWithRelationInput | ShippingMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShippingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShippingMethods
    **/
    _count?: true | ShippingMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShippingMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShippingMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingMethodMaxAggregateInputType
  }

  export type GetShippingMethodAggregateType<T extends ShippingMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateShippingMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShippingMethod[P]>
      : GetScalarType<T[P], AggregateShippingMethod[P]>
  }




  export type ShippingMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingMethodWhereInput
    orderBy?: ShippingMethodOrderByWithAggregationInput | ShippingMethodOrderByWithAggregationInput[]
    by: ShippingMethodScalarFieldEnum[] | ShippingMethodScalarFieldEnum
    having?: ShippingMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingMethodCountAggregateInputType | true
    _avg?: ShippingMethodAvgAggregateInputType
    _sum?: ShippingMethodSumAggregateInputType
    _min?: ShippingMethodMinAggregateInputType
    _max?: ShippingMethodMaxAggregateInputType
  }

  export type ShippingMethodGroupByOutputType = {
    id: string
    name: string
    storeId: string
    description: string | null
    carrier: string | null
    deliveryTime: string
    baseCost: number
    costCalculation: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ShippingMethodCountAggregateOutputType | null
    _avg: ShippingMethodAvgAggregateOutputType | null
    _sum: ShippingMethodSumAggregateOutputType | null
    _min: ShippingMethodMinAggregateOutputType | null
    _max: ShippingMethodMaxAggregateOutputType | null
  }

  type GetShippingMethodGroupByPayload<T extends ShippingMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShippingMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingMethodGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingMethodGroupByOutputType[P]>
        }
      >
    >


  export type ShippingMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    storeId?: boolean
    description?: boolean
    carrier?: boolean
    deliveryTime?: boolean
    baseCost?: boolean
    costCalculation?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    shippingZones?: boolean | ShippingMethod$shippingZonesArgs<ExtArgs>
    Shipping?: boolean | ShippingMethod$ShippingArgs<ExtArgs>
    _count?: boolean | ShippingMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingMethod"]>

  export type ShippingMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    storeId?: boolean
    description?: boolean
    carrier?: boolean
    deliveryTime?: boolean
    baseCost?: boolean
    costCalculation?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingMethod"]>

  export type ShippingMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    storeId?: boolean
    description?: boolean
    carrier?: boolean
    deliveryTime?: boolean
    baseCost?: boolean
    costCalculation?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingMethod"]>

  export type ShippingMethodSelectScalar = {
    id?: boolean
    name?: boolean
    storeId?: boolean
    description?: boolean
    carrier?: boolean
    deliveryTime?: boolean
    baseCost?: boolean
    costCalculation?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShippingMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "storeId" | "description" | "carrier" | "deliveryTime" | "baseCost" | "costCalculation" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["shippingMethod"]>
  export type ShippingMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    shippingZones?: boolean | ShippingMethod$shippingZonesArgs<ExtArgs>
    Shipping?: boolean | ShippingMethod$ShippingArgs<ExtArgs>
    _count?: boolean | ShippingMethodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShippingMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ShippingMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ShippingMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShippingMethod"
    objects: {
      store: Prisma.$OrganizationPayload<ExtArgs>
      shippingZones: Prisma.$ShippingZonePayload<ExtArgs>[]
      Shipping: Prisma.$ShippingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      storeId: string
      description: string | null
      carrier: string | null
      deliveryTime: string
      baseCost: number
      costCalculation: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shippingMethod"]>
    composites: {}
  }

  type ShippingMethodGetPayload<S extends boolean | null | undefined | ShippingMethodDefaultArgs> = $Result.GetResult<Prisma.$ShippingMethodPayload, S>

  type ShippingMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShippingMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShippingMethodCountAggregateInputType | true
    }

  export interface ShippingMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShippingMethod'], meta: { name: 'ShippingMethod' } }
    /**
     * Find zero or one ShippingMethod that matches the filter.
     * @param {ShippingMethodFindUniqueArgs} args - Arguments to find a ShippingMethod
     * @example
     * // Get one ShippingMethod
     * const shippingMethod = await prisma.shippingMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShippingMethodFindUniqueArgs>(args: SelectSubset<T, ShippingMethodFindUniqueArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShippingMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShippingMethodFindUniqueOrThrowArgs} args - Arguments to find a ShippingMethod
     * @example
     * // Get one ShippingMethod
     * const shippingMethod = await prisma.shippingMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShippingMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, ShippingMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShippingMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodFindFirstArgs} args - Arguments to find a ShippingMethod
     * @example
     * // Get one ShippingMethod
     * const shippingMethod = await prisma.shippingMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShippingMethodFindFirstArgs>(args?: SelectSubset<T, ShippingMethodFindFirstArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShippingMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodFindFirstOrThrowArgs} args - Arguments to find a ShippingMethod
     * @example
     * // Get one ShippingMethod
     * const shippingMethod = await prisma.shippingMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShippingMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, ShippingMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShippingMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShippingMethods
     * const shippingMethods = await prisma.shippingMethod.findMany()
     * 
     * // Get first 10 ShippingMethods
     * const shippingMethods = await prisma.shippingMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingMethodWithIdOnly = await prisma.shippingMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShippingMethodFindManyArgs>(args?: SelectSubset<T, ShippingMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShippingMethod.
     * @param {ShippingMethodCreateArgs} args - Arguments to create a ShippingMethod.
     * @example
     * // Create one ShippingMethod
     * const ShippingMethod = await prisma.shippingMethod.create({
     *   data: {
     *     // ... data to create a ShippingMethod
     *   }
     * })
     * 
     */
    create<T extends ShippingMethodCreateArgs>(args: SelectSubset<T, ShippingMethodCreateArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShippingMethods.
     * @param {ShippingMethodCreateManyArgs} args - Arguments to create many ShippingMethods.
     * @example
     * // Create many ShippingMethods
     * const shippingMethod = await prisma.shippingMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShippingMethodCreateManyArgs>(args?: SelectSubset<T, ShippingMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShippingMethods and returns the data saved in the database.
     * @param {ShippingMethodCreateManyAndReturnArgs} args - Arguments to create many ShippingMethods.
     * @example
     * // Create many ShippingMethods
     * const shippingMethod = await prisma.shippingMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShippingMethods and only return the `id`
     * const shippingMethodWithIdOnly = await prisma.shippingMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShippingMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, ShippingMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShippingMethod.
     * @param {ShippingMethodDeleteArgs} args - Arguments to delete one ShippingMethod.
     * @example
     * // Delete one ShippingMethod
     * const ShippingMethod = await prisma.shippingMethod.delete({
     *   where: {
     *     // ... filter to delete one ShippingMethod
     *   }
     * })
     * 
     */
    delete<T extends ShippingMethodDeleteArgs>(args: SelectSubset<T, ShippingMethodDeleteArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShippingMethod.
     * @param {ShippingMethodUpdateArgs} args - Arguments to update one ShippingMethod.
     * @example
     * // Update one ShippingMethod
     * const shippingMethod = await prisma.shippingMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShippingMethodUpdateArgs>(args: SelectSubset<T, ShippingMethodUpdateArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShippingMethods.
     * @param {ShippingMethodDeleteManyArgs} args - Arguments to filter ShippingMethods to delete.
     * @example
     * // Delete a few ShippingMethods
     * const { count } = await prisma.shippingMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShippingMethodDeleteManyArgs>(args?: SelectSubset<T, ShippingMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShippingMethods
     * const shippingMethod = await prisma.shippingMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShippingMethodUpdateManyArgs>(args: SelectSubset<T, ShippingMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingMethods and returns the data updated in the database.
     * @param {ShippingMethodUpdateManyAndReturnArgs} args - Arguments to update many ShippingMethods.
     * @example
     * // Update many ShippingMethods
     * const shippingMethod = await prisma.shippingMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShippingMethods and only return the `id`
     * const shippingMethodWithIdOnly = await prisma.shippingMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShippingMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, ShippingMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShippingMethod.
     * @param {ShippingMethodUpsertArgs} args - Arguments to update or create a ShippingMethod.
     * @example
     * // Update or create a ShippingMethod
     * const shippingMethod = await prisma.shippingMethod.upsert({
     *   create: {
     *     // ... data to create a ShippingMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShippingMethod we want to update
     *   }
     * })
     */
    upsert<T extends ShippingMethodUpsertArgs>(args: SelectSubset<T, ShippingMethodUpsertArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShippingMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodCountArgs} args - Arguments to filter ShippingMethods to count.
     * @example
     * // Count the number of ShippingMethods
     * const count = await prisma.shippingMethod.count({
     *   where: {
     *     // ... the filter for the ShippingMethods we want to count
     *   }
     * })
    **/
    count<T extends ShippingMethodCountArgs>(
      args?: Subset<T, ShippingMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShippingMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingMethodAggregateArgs>(args: Subset<T, ShippingMethodAggregateArgs>): Prisma.PrismaPromise<GetShippingMethodAggregateType<T>>

    /**
     * Group by ShippingMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingMethodGroupByArgs['orderBy'] }
        : { orderBy?: ShippingMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShippingMethod model
   */
  readonly fields: ShippingMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShippingMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShippingMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shippingZones<T extends ShippingMethod$shippingZonesArgs<ExtArgs> = {}>(args?: Subset<T, ShippingMethod$shippingZonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Shipping<T extends ShippingMethod$ShippingArgs<ExtArgs> = {}>(args?: Subset<T, ShippingMethod$ShippingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShippingMethod model
   */
  interface ShippingMethodFieldRefs {
    readonly id: FieldRef<"ShippingMethod", 'String'>
    readonly name: FieldRef<"ShippingMethod", 'String'>
    readonly storeId: FieldRef<"ShippingMethod", 'String'>
    readonly description: FieldRef<"ShippingMethod", 'String'>
    readonly carrier: FieldRef<"ShippingMethod", 'String'>
    readonly deliveryTime: FieldRef<"ShippingMethod", 'String'>
    readonly baseCost: FieldRef<"ShippingMethod", 'Float'>
    readonly costCalculation: FieldRef<"ShippingMethod", 'String'>
    readonly isActive: FieldRef<"ShippingMethod", 'Boolean'>
    readonly createdAt: FieldRef<"ShippingMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"ShippingMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShippingMethod findUnique
   */
  export type ShippingMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * Filter, which ShippingMethod to fetch.
     */
    where: ShippingMethodWhereUniqueInput
  }

  /**
   * ShippingMethod findUniqueOrThrow
   */
  export type ShippingMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * Filter, which ShippingMethod to fetch.
     */
    where: ShippingMethodWhereUniqueInput
  }

  /**
   * ShippingMethod findFirst
   */
  export type ShippingMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * Filter, which ShippingMethod to fetch.
     */
    where?: ShippingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingMethods to fetch.
     */
    orderBy?: ShippingMethodOrderByWithRelationInput | ShippingMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingMethods.
     */
    cursor?: ShippingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingMethods.
     */
    distinct?: ShippingMethodScalarFieldEnum | ShippingMethodScalarFieldEnum[]
  }

  /**
   * ShippingMethod findFirstOrThrow
   */
  export type ShippingMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * Filter, which ShippingMethod to fetch.
     */
    where?: ShippingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingMethods to fetch.
     */
    orderBy?: ShippingMethodOrderByWithRelationInput | ShippingMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingMethods.
     */
    cursor?: ShippingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingMethods.
     */
    distinct?: ShippingMethodScalarFieldEnum | ShippingMethodScalarFieldEnum[]
  }

  /**
   * ShippingMethod findMany
   */
  export type ShippingMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * Filter, which ShippingMethods to fetch.
     */
    where?: ShippingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingMethods to fetch.
     */
    orderBy?: ShippingMethodOrderByWithRelationInput | ShippingMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShippingMethods.
     */
    cursor?: ShippingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingMethods.
     */
    skip?: number
    distinct?: ShippingMethodScalarFieldEnum | ShippingMethodScalarFieldEnum[]
  }

  /**
   * ShippingMethod create
   */
  export type ShippingMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a ShippingMethod.
     */
    data: XOR<ShippingMethodCreateInput, ShippingMethodUncheckedCreateInput>
  }

  /**
   * ShippingMethod createMany
   */
  export type ShippingMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShippingMethods.
     */
    data: ShippingMethodCreateManyInput | ShippingMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShippingMethod createManyAndReturn
   */
  export type ShippingMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * The data used to create many ShippingMethods.
     */
    data: ShippingMethodCreateManyInput | ShippingMethodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShippingMethod update
   */
  export type ShippingMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a ShippingMethod.
     */
    data: XOR<ShippingMethodUpdateInput, ShippingMethodUncheckedUpdateInput>
    /**
     * Choose, which ShippingMethod to update.
     */
    where: ShippingMethodWhereUniqueInput
  }

  /**
   * ShippingMethod updateMany
   */
  export type ShippingMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShippingMethods.
     */
    data: XOR<ShippingMethodUpdateManyMutationInput, ShippingMethodUncheckedUpdateManyInput>
    /**
     * Filter which ShippingMethods to update
     */
    where?: ShippingMethodWhereInput
    /**
     * Limit how many ShippingMethods to update.
     */
    limit?: number
  }

  /**
   * ShippingMethod updateManyAndReturn
   */
  export type ShippingMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * The data used to update ShippingMethods.
     */
    data: XOR<ShippingMethodUpdateManyMutationInput, ShippingMethodUncheckedUpdateManyInput>
    /**
     * Filter which ShippingMethods to update
     */
    where?: ShippingMethodWhereInput
    /**
     * Limit how many ShippingMethods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShippingMethod upsert
   */
  export type ShippingMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the ShippingMethod to update in case it exists.
     */
    where: ShippingMethodWhereUniqueInput
    /**
     * In case the ShippingMethod found by the `where` argument doesn't exist, create a new ShippingMethod with this data.
     */
    create: XOR<ShippingMethodCreateInput, ShippingMethodUncheckedCreateInput>
    /**
     * In case the ShippingMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShippingMethodUpdateInput, ShippingMethodUncheckedUpdateInput>
  }

  /**
   * ShippingMethod delete
   */
  export type ShippingMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * Filter which ShippingMethod to delete.
     */
    where: ShippingMethodWhereUniqueInput
  }

  /**
   * ShippingMethod deleteMany
   */
  export type ShippingMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingMethods to delete
     */
    where?: ShippingMethodWhereInput
    /**
     * Limit how many ShippingMethods to delete.
     */
    limit?: number
  }

  /**
   * ShippingMethod.shippingZones
   */
  export type ShippingMethod$shippingZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneInclude<ExtArgs> | null
    where?: ShippingZoneWhereInput
    orderBy?: ShippingZoneOrderByWithRelationInput | ShippingZoneOrderByWithRelationInput[]
    cursor?: ShippingZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShippingZoneScalarFieldEnum | ShippingZoneScalarFieldEnum[]
  }

  /**
   * ShippingMethod.Shipping
   */
  export type ShippingMethod$ShippingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipping
     */
    select?: ShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipping
     */
    omit?: ShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingInclude<ExtArgs> | null
    where?: ShippingWhereInput
    orderBy?: ShippingOrderByWithRelationInput | ShippingOrderByWithRelationInput[]
    cursor?: ShippingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShippingScalarFieldEnum | ShippingScalarFieldEnum[]
  }

  /**
   * ShippingMethod without action
   */
  export type ShippingMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
  }


  /**
   * Model ShippingZone
   */

  export type AggregateShippingZone = {
    _count: ShippingZoneCountAggregateOutputType | null
    _min: ShippingZoneMinAggregateOutputType | null
    _max: ShippingZoneMaxAggregateOutputType | null
  }

  export type ShippingZoneMinAggregateOutputType = {
    id: string | null
    name: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingZoneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingZoneCountAggregateOutputType = {
    id: number
    name: number
    storeId: number
    countries: number
    regions: number
    postalCodes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShippingZoneMinAggregateInputType = {
    id?: true
    name?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingZoneMaxAggregateInputType = {
    id?: true
    name?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingZoneCountAggregateInputType = {
    id?: true
    name?: true
    storeId?: true
    countries?: true
    regions?: true
    postalCodes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShippingZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingZone to aggregate.
     */
    where?: ShippingZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingZones to fetch.
     */
    orderBy?: ShippingZoneOrderByWithRelationInput | ShippingZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShippingZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShippingZones
    **/
    _count?: true | ShippingZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingZoneMaxAggregateInputType
  }

  export type GetShippingZoneAggregateType<T extends ShippingZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateShippingZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShippingZone[P]>
      : GetScalarType<T[P], AggregateShippingZone[P]>
  }




  export type ShippingZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingZoneWhereInput
    orderBy?: ShippingZoneOrderByWithAggregationInput | ShippingZoneOrderByWithAggregationInput[]
    by: ShippingZoneScalarFieldEnum[] | ShippingZoneScalarFieldEnum
    having?: ShippingZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingZoneCountAggregateInputType | true
    _min?: ShippingZoneMinAggregateInputType
    _max?: ShippingZoneMaxAggregateInputType
  }

  export type ShippingZoneGroupByOutputType = {
    id: string
    name: string
    storeId: string
    countries: string[]
    regions: string[]
    postalCodes: string[]
    createdAt: Date
    updatedAt: Date
    _count: ShippingZoneCountAggregateOutputType | null
    _min: ShippingZoneMinAggregateOutputType | null
    _max: ShippingZoneMaxAggregateOutputType | null
  }

  type GetShippingZoneGroupByPayload<T extends ShippingZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShippingZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingZoneGroupByOutputType[P]>
        }
      >
    >


  export type ShippingZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    storeId?: boolean
    countries?: boolean
    regions?: boolean
    postalCodes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    shippingMethods?: boolean | ShippingZone$shippingMethodsArgs<ExtArgs>
    _count?: boolean | ShippingZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingZone"]>

  export type ShippingZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    storeId?: boolean
    countries?: boolean
    regions?: boolean
    postalCodes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingZone"]>

  export type ShippingZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    storeId?: boolean
    countries?: boolean
    regions?: boolean
    postalCodes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingZone"]>

  export type ShippingZoneSelectScalar = {
    id?: boolean
    name?: boolean
    storeId?: boolean
    countries?: boolean
    regions?: boolean
    postalCodes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShippingZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "storeId" | "countries" | "regions" | "postalCodes" | "createdAt" | "updatedAt", ExtArgs["result"]["shippingZone"]>
  export type ShippingZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    shippingMethods?: boolean | ShippingZone$shippingMethodsArgs<ExtArgs>
    _count?: boolean | ShippingZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShippingZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ShippingZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ShippingZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShippingZone"
    objects: {
      store: Prisma.$OrganizationPayload<ExtArgs>
      shippingMethods: Prisma.$ShippingMethodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      storeId: string
      countries: string[]
      regions: string[]
      postalCodes: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shippingZone"]>
    composites: {}
  }

  type ShippingZoneGetPayload<S extends boolean | null | undefined | ShippingZoneDefaultArgs> = $Result.GetResult<Prisma.$ShippingZonePayload, S>

  type ShippingZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShippingZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShippingZoneCountAggregateInputType | true
    }

  export interface ShippingZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShippingZone'], meta: { name: 'ShippingZone' } }
    /**
     * Find zero or one ShippingZone that matches the filter.
     * @param {ShippingZoneFindUniqueArgs} args - Arguments to find a ShippingZone
     * @example
     * // Get one ShippingZone
     * const shippingZone = await prisma.shippingZone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShippingZoneFindUniqueArgs>(args: SelectSubset<T, ShippingZoneFindUniqueArgs<ExtArgs>>): Prisma__ShippingZoneClient<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShippingZone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShippingZoneFindUniqueOrThrowArgs} args - Arguments to find a ShippingZone
     * @example
     * // Get one ShippingZone
     * const shippingZone = await prisma.shippingZone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShippingZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ShippingZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShippingZoneClient<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShippingZone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneFindFirstArgs} args - Arguments to find a ShippingZone
     * @example
     * // Get one ShippingZone
     * const shippingZone = await prisma.shippingZone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShippingZoneFindFirstArgs>(args?: SelectSubset<T, ShippingZoneFindFirstArgs<ExtArgs>>): Prisma__ShippingZoneClient<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShippingZone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneFindFirstOrThrowArgs} args - Arguments to find a ShippingZone
     * @example
     * // Get one ShippingZone
     * const shippingZone = await prisma.shippingZone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShippingZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ShippingZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShippingZoneClient<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShippingZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShippingZones
     * const shippingZones = await prisma.shippingZone.findMany()
     * 
     * // Get first 10 ShippingZones
     * const shippingZones = await prisma.shippingZone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingZoneWithIdOnly = await prisma.shippingZone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShippingZoneFindManyArgs>(args?: SelectSubset<T, ShippingZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShippingZone.
     * @param {ShippingZoneCreateArgs} args - Arguments to create a ShippingZone.
     * @example
     * // Create one ShippingZone
     * const ShippingZone = await prisma.shippingZone.create({
     *   data: {
     *     // ... data to create a ShippingZone
     *   }
     * })
     * 
     */
    create<T extends ShippingZoneCreateArgs>(args: SelectSubset<T, ShippingZoneCreateArgs<ExtArgs>>): Prisma__ShippingZoneClient<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShippingZones.
     * @param {ShippingZoneCreateManyArgs} args - Arguments to create many ShippingZones.
     * @example
     * // Create many ShippingZones
     * const shippingZone = await prisma.shippingZone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShippingZoneCreateManyArgs>(args?: SelectSubset<T, ShippingZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShippingZones and returns the data saved in the database.
     * @param {ShippingZoneCreateManyAndReturnArgs} args - Arguments to create many ShippingZones.
     * @example
     * // Create many ShippingZones
     * const shippingZone = await prisma.shippingZone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShippingZones and only return the `id`
     * const shippingZoneWithIdOnly = await prisma.shippingZone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShippingZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ShippingZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShippingZone.
     * @param {ShippingZoneDeleteArgs} args - Arguments to delete one ShippingZone.
     * @example
     * // Delete one ShippingZone
     * const ShippingZone = await prisma.shippingZone.delete({
     *   where: {
     *     // ... filter to delete one ShippingZone
     *   }
     * })
     * 
     */
    delete<T extends ShippingZoneDeleteArgs>(args: SelectSubset<T, ShippingZoneDeleteArgs<ExtArgs>>): Prisma__ShippingZoneClient<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShippingZone.
     * @param {ShippingZoneUpdateArgs} args - Arguments to update one ShippingZone.
     * @example
     * // Update one ShippingZone
     * const shippingZone = await prisma.shippingZone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShippingZoneUpdateArgs>(args: SelectSubset<T, ShippingZoneUpdateArgs<ExtArgs>>): Prisma__ShippingZoneClient<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShippingZones.
     * @param {ShippingZoneDeleteManyArgs} args - Arguments to filter ShippingZones to delete.
     * @example
     * // Delete a few ShippingZones
     * const { count } = await prisma.shippingZone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShippingZoneDeleteManyArgs>(args?: SelectSubset<T, ShippingZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShippingZones
     * const shippingZone = await prisma.shippingZone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShippingZoneUpdateManyArgs>(args: SelectSubset<T, ShippingZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingZones and returns the data updated in the database.
     * @param {ShippingZoneUpdateManyAndReturnArgs} args - Arguments to update many ShippingZones.
     * @example
     * // Update many ShippingZones
     * const shippingZone = await prisma.shippingZone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShippingZones and only return the `id`
     * const shippingZoneWithIdOnly = await prisma.shippingZone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShippingZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, ShippingZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShippingZone.
     * @param {ShippingZoneUpsertArgs} args - Arguments to update or create a ShippingZone.
     * @example
     * // Update or create a ShippingZone
     * const shippingZone = await prisma.shippingZone.upsert({
     *   create: {
     *     // ... data to create a ShippingZone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShippingZone we want to update
     *   }
     * })
     */
    upsert<T extends ShippingZoneUpsertArgs>(args: SelectSubset<T, ShippingZoneUpsertArgs<ExtArgs>>): Prisma__ShippingZoneClient<$Result.GetResult<Prisma.$ShippingZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShippingZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneCountArgs} args - Arguments to filter ShippingZones to count.
     * @example
     * // Count the number of ShippingZones
     * const count = await prisma.shippingZone.count({
     *   where: {
     *     // ... the filter for the ShippingZones we want to count
     *   }
     * })
    **/
    count<T extends ShippingZoneCountArgs>(
      args?: Subset<T, ShippingZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShippingZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingZoneAggregateArgs>(args: Subset<T, ShippingZoneAggregateArgs>): Prisma.PrismaPromise<GetShippingZoneAggregateType<T>>

    /**
     * Group by ShippingZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingZoneGroupByArgs['orderBy'] }
        : { orderBy?: ShippingZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShippingZone model
   */
  readonly fields: ShippingZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShippingZone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShippingZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shippingMethods<T extends ShippingZone$shippingMethodsArgs<ExtArgs> = {}>(args?: Subset<T, ShippingZone$shippingMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShippingZone model
   */
  interface ShippingZoneFieldRefs {
    readonly id: FieldRef<"ShippingZone", 'String'>
    readonly name: FieldRef<"ShippingZone", 'String'>
    readonly storeId: FieldRef<"ShippingZone", 'String'>
    readonly countries: FieldRef<"ShippingZone", 'String[]'>
    readonly regions: FieldRef<"ShippingZone", 'String[]'>
    readonly postalCodes: FieldRef<"ShippingZone", 'String[]'>
    readonly createdAt: FieldRef<"ShippingZone", 'DateTime'>
    readonly updatedAt: FieldRef<"ShippingZone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShippingZone findUnique
   */
  export type ShippingZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneInclude<ExtArgs> | null
    /**
     * Filter, which ShippingZone to fetch.
     */
    where: ShippingZoneWhereUniqueInput
  }

  /**
   * ShippingZone findUniqueOrThrow
   */
  export type ShippingZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneInclude<ExtArgs> | null
    /**
     * Filter, which ShippingZone to fetch.
     */
    where: ShippingZoneWhereUniqueInput
  }

  /**
   * ShippingZone findFirst
   */
  export type ShippingZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneInclude<ExtArgs> | null
    /**
     * Filter, which ShippingZone to fetch.
     */
    where?: ShippingZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingZones to fetch.
     */
    orderBy?: ShippingZoneOrderByWithRelationInput | ShippingZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingZones.
     */
    cursor?: ShippingZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingZones.
     */
    distinct?: ShippingZoneScalarFieldEnum | ShippingZoneScalarFieldEnum[]
  }

  /**
   * ShippingZone findFirstOrThrow
   */
  export type ShippingZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneInclude<ExtArgs> | null
    /**
     * Filter, which ShippingZone to fetch.
     */
    where?: ShippingZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingZones to fetch.
     */
    orderBy?: ShippingZoneOrderByWithRelationInput | ShippingZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingZones.
     */
    cursor?: ShippingZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingZones.
     */
    distinct?: ShippingZoneScalarFieldEnum | ShippingZoneScalarFieldEnum[]
  }

  /**
   * ShippingZone findMany
   */
  export type ShippingZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneInclude<ExtArgs> | null
    /**
     * Filter, which ShippingZones to fetch.
     */
    where?: ShippingZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingZones to fetch.
     */
    orderBy?: ShippingZoneOrderByWithRelationInput | ShippingZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShippingZones.
     */
    cursor?: ShippingZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingZones.
     */
    skip?: number
    distinct?: ShippingZoneScalarFieldEnum | ShippingZoneScalarFieldEnum[]
  }

  /**
   * ShippingZone create
   */
  export type ShippingZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a ShippingZone.
     */
    data: XOR<ShippingZoneCreateInput, ShippingZoneUncheckedCreateInput>
  }

  /**
   * ShippingZone createMany
   */
  export type ShippingZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShippingZones.
     */
    data: ShippingZoneCreateManyInput | ShippingZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShippingZone createManyAndReturn
   */
  export type ShippingZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * The data used to create many ShippingZones.
     */
    data: ShippingZoneCreateManyInput | ShippingZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShippingZone update
   */
  export type ShippingZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a ShippingZone.
     */
    data: XOR<ShippingZoneUpdateInput, ShippingZoneUncheckedUpdateInput>
    /**
     * Choose, which ShippingZone to update.
     */
    where: ShippingZoneWhereUniqueInput
  }

  /**
   * ShippingZone updateMany
   */
  export type ShippingZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShippingZones.
     */
    data: XOR<ShippingZoneUpdateManyMutationInput, ShippingZoneUncheckedUpdateManyInput>
    /**
     * Filter which ShippingZones to update
     */
    where?: ShippingZoneWhereInput
    /**
     * Limit how many ShippingZones to update.
     */
    limit?: number
  }

  /**
   * ShippingZone updateManyAndReturn
   */
  export type ShippingZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * The data used to update ShippingZones.
     */
    data: XOR<ShippingZoneUpdateManyMutationInput, ShippingZoneUncheckedUpdateManyInput>
    /**
     * Filter which ShippingZones to update
     */
    where?: ShippingZoneWhereInput
    /**
     * Limit how many ShippingZones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShippingZone upsert
   */
  export type ShippingZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the ShippingZone to update in case it exists.
     */
    where: ShippingZoneWhereUniqueInput
    /**
     * In case the ShippingZone found by the `where` argument doesn't exist, create a new ShippingZone with this data.
     */
    create: XOR<ShippingZoneCreateInput, ShippingZoneUncheckedCreateInput>
    /**
     * In case the ShippingZone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShippingZoneUpdateInput, ShippingZoneUncheckedUpdateInput>
  }

  /**
   * ShippingZone delete
   */
  export type ShippingZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneInclude<ExtArgs> | null
    /**
     * Filter which ShippingZone to delete.
     */
    where: ShippingZoneWhereUniqueInput
  }

  /**
   * ShippingZone deleteMany
   */
  export type ShippingZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingZones to delete
     */
    where?: ShippingZoneWhereInput
    /**
     * Limit how many ShippingZones to delete.
     */
    limit?: number
  }

  /**
   * ShippingZone.shippingMethods
   */
  export type ShippingZone$shippingMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    where?: ShippingMethodWhereInput
    orderBy?: ShippingMethodOrderByWithRelationInput | ShippingMethodOrderByWithRelationInput[]
    cursor?: ShippingMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShippingMethodScalarFieldEnum | ShippingMethodScalarFieldEnum[]
  }

  /**
   * ShippingZone without action
   */
  export type ShippingZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingZone
     */
    select?: ShippingZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingZone
     */
    omit?: ShippingZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingZoneInclude<ExtArgs> | null
  }


  /**
   * Model ShippingAudit
   */

  export type AggregateShippingAudit = {
    _count: ShippingAuditCountAggregateOutputType | null
    _min: ShippingAuditMinAggregateOutputType | null
    _max: ShippingAuditMaxAggregateOutputType | null
  }

  export type ShippingAuditMinAggregateOutputType = {
    id: string | null
    shippingId: string | null
    action: string | null
    details: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ShippingAuditMaxAggregateOutputType = {
    id: string | null
    shippingId: string | null
    action: string | null
    details: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ShippingAuditCountAggregateOutputType = {
    id: number
    shippingId: number
    action: number
    details: number
    createdAt: number
    updatedAt: number
    userId: number
    metadata: number
    _all: number
  }


  export type ShippingAuditMinAggregateInputType = {
    id?: true
    shippingId?: true
    action?: true
    details?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ShippingAuditMaxAggregateInputType = {
    id?: true
    shippingId?: true
    action?: true
    details?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ShippingAuditCountAggregateInputType = {
    id?: true
    shippingId?: true
    action?: true
    details?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    metadata?: true
    _all?: true
  }

  export type ShippingAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingAudit to aggregate.
     */
    where?: ShippingAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingAudits to fetch.
     */
    orderBy?: ShippingAuditOrderByWithRelationInput | ShippingAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShippingAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShippingAudits
    **/
    _count?: true | ShippingAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingAuditMaxAggregateInputType
  }

  export type GetShippingAuditAggregateType<T extends ShippingAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateShippingAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShippingAudit[P]>
      : GetScalarType<T[P], AggregateShippingAudit[P]>
  }




  export type ShippingAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingAuditWhereInput
    orderBy?: ShippingAuditOrderByWithAggregationInput | ShippingAuditOrderByWithAggregationInput[]
    by: ShippingAuditScalarFieldEnum[] | ShippingAuditScalarFieldEnum
    having?: ShippingAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingAuditCountAggregateInputType | true
    _min?: ShippingAuditMinAggregateInputType
    _max?: ShippingAuditMaxAggregateInputType
  }

  export type ShippingAuditGroupByOutputType = {
    id: string
    shippingId: string
    action: string
    details: string | null
    createdAt: Date
    updatedAt: Date
    userId: string | null
    metadata: JsonValue | null
    _count: ShippingAuditCountAggregateOutputType | null
    _min: ShippingAuditMinAggregateOutputType | null
    _max: ShippingAuditMaxAggregateOutputType | null
  }

  type GetShippingAuditGroupByPayload<T extends ShippingAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShippingAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingAuditGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingAuditGroupByOutputType[P]>
        }
      >
    >


  export type ShippingAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shippingId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    metadata?: boolean
    shipping?: boolean | ShippingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingAudit"]>

  export type ShippingAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shippingId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    metadata?: boolean
    shipping?: boolean | ShippingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingAudit"]>

  export type ShippingAuditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shippingId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    metadata?: boolean
    shipping?: boolean | ShippingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingAudit"]>

  export type ShippingAuditSelectScalar = {
    id?: boolean
    shippingId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    metadata?: boolean
  }

  export type ShippingAuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shippingId" | "action" | "details" | "createdAt" | "updatedAt" | "userId" | "metadata", ExtArgs["result"]["shippingAudit"]>
  export type ShippingAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipping?: boolean | ShippingDefaultArgs<ExtArgs>
  }
  export type ShippingAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipping?: boolean | ShippingDefaultArgs<ExtArgs>
  }
  export type ShippingAuditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipping?: boolean | ShippingDefaultArgs<ExtArgs>
  }

  export type $ShippingAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShippingAudit"
    objects: {
      shipping: Prisma.$ShippingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shippingId: string
      action: string
      details: string | null
      createdAt: Date
      updatedAt: Date
      userId: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["shippingAudit"]>
    composites: {}
  }

  type ShippingAuditGetPayload<S extends boolean | null | undefined | ShippingAuditDefaultArgs> = $Result.GetResult<Prisma.$ShippingAuditPayload, S>

  type ShippingAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShippingAuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShippingAuditCountAggregateInputType | true
    }

  export interface ShippingAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShippingAudit'], meta: { name: 'ShippingAudit' } }
    /**
     * Find zero or one ShippingAudit that matches the filter.
     * @param {ShippingAuditFindUniqueArgs} args - Arguments to find a ShippingAudit
     * @example
     * // Get one ShippingAudit
     * const shippingAudit = await prisma.shippingAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShippingAuditFindUniqueArgs>(args: SelectSubset<T, ShippingAuditFindUniqueArgs<ExtArgs>>): Prisma__ShippingAuditClient<$Result.GetResult<Prisma.$ShippingAuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShippingAudit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShippingAuditFindUniqueOrThrowArgs} args - Arguments to find a ShippingAudit
     * @example
     * // Get one ShippingAudit
     * const shippingAudit = await prisma.shippingAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShippingAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, ShippingAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShippingAuditClient<$Result.GetResult<Prisma.$ShippingAuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShippingAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingAuditFindFirstArgs} args - Arguments to find a ShippingAudit
     * @example
     * // Get one ShippingAudit
     * const shippingAudit = await prisma.shippingAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShippingAuditFindFirstArgs>(args?: SelectSubset<T, ShippingAuditFindFirstArgs<ExtArgs>>): Prisma__ShippingAuditClient<$Result.GetResult<Prisma.$ShippingAuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShippingAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingAuditFindFirstOrThrowArgs} args - Arguments to find a ShippingAudit
     * @example
     * // Get one ShippingAudit
     * const shippingAudit = await prisma.shippingAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShippingAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, ShippingAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShippingAuditClient<$Result.GetResult<Prisma.$ShippingAuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShippingAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShippingAudits
     * const shippingAudits = await prisma.shippingAudit.findMany()
     * 
     * // Get first 10 ShippingAudits
     * const shippingAudits = await prisma.shippingAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingAuditWithIdOnly = await prisma.shippingAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShippingAuditFindManyArgs>(args?: SelectSubset<T, ShippingAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShippingAudit.
     * @param {ShippingAuditCreateArgs} args - Arguments to create a ShippingAudit.
     * @example
     * // Create one ShippingAudit
     * const ShippingAudit = await prisma.shippingAudit.create({
     *   data: {
     *     // ... data to create a ShippingAudit
     *   }
     * })
     * 
     */
    create<T extends ShippingAuditCreateArgs>(args: SelectSubset<T, ShippingAuditCreateArgs<ExtArgs>>): Prisma__ShippingAuditClient<$Result.GetResult<Prisma.$ShippingAuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShippingAudits.
     * @param {ShippingAuditCreateManyArgs} args - Arguments to create many ShippingAudits.
     * @example
     * // Create many ShippingAudits
     * const shippingAudit = await prisma.shippingAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShippingAuditCreateManyArgs>(args?: SelectSubset<T, ShippingAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShippingAudits and returns the data saved in the database.
     * @param {ShippingAuditCreateManyAndReturnArgs} args - Arguments to create many ShippingAudits.
     * @example
     * // Create many ShippingAudits
     * const shippingAudit = await prisma.shippingAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShippingAudits and only return the `id`
     * const shippingAuditWithIdOnly = await prisma.shippingAudit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShippingAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, ShippingAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingAuditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShippingAudit.
     * @param {ShippingAuditDeleteArgs} args - Arguments to delete one ShippingAudit.
     * @example
     * // Delete one ShippingAudit
     * const ShippingAudit = await prisma.shippingAudit.delete({
     *   where: {
     *     // ... filter to delete one ShippingAudit
     *   }
     * })
     * 
     */
    delete<T extends ShippingAuditDeleteArgs>(args: SelectSubset<T, ShippingAuditDeleteArgs<ExtArgs>>): Prisma__ShippingAuditClient<$Result.GetResult<Prisma.$ShippingAuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShippingAudit.
     * @param {ShippingAuditUpdateArgs} args - Arguments to update one ShippingAudit.
     * @example
     * // Update one ShippingAudit
     * const shippingAudit = await prisma.shippingAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShippingAuditUpdateArgs>(args: SelectSubset<T, ShippingAuditUpdateArgs<ExtArgs>>): Prisma__ShippingAuditClient<$Result.GetResult<Prisma.$ShippingAuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShippingAudits.
     * @param {ShippingAuditDeleteManyArgs} args - Arguments to filter ShippingAudits to delete.
     * @example
     * // Delete a few ShippingAudits
     * const { count } = await prisma.shippingAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShippingAuditDeleteManyArgs>(args?: SelectSubset<T, ShippingAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShippingAudits
     * const shippingAudit = await prisma.shippingAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShippingAuditUpdateManyArgs>(args: SelectSubset<T, ShippingAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingAudits and returns the data updated in the database.
     * @param {ShippingAuditUpdateManyAndReturnArgs} args - Arguments to update many ShippingAudits.
     * @example
     * // Update many ShippingAudits
     * const shippingAudit = await prisma.shippingAudit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShippingAudits and only return the `id`
     * const shippingAuditWithIdOnly = await prisma.shippingAudit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShippingAuditUpdateManyAndReturnArgs>(args: SelectSubset<T, ShippingAuditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingAuditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShippingAudit.
     * @param {ShippingAuditUpsertArgs} args - Arguments to update or create a ShippingAudit.
     * @example
     * // Update or create a ShippingAudit
     * const shippingAudit = await prisma.shippingAudit.upsert({
     *   create: {
     *     // ... data to create a ShippingAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShippingAudit we want to update
     *   }
     * })
     */
    upsert<T extends ShippingAuditUpsertArgs>(args: SelectSubset<T, ShippingAuditUpsertArgs<ExtArgs>>): Prisma__ShippingAuditClient<$Result.GetResult<Prisma.$ShippingAuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShippingAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingAuditCountArgs} args - Arguments to filter ShippingAudits to count.
     * @example
     * // Count the number of ShippingAudits
     * const count = await prisma.shippingAudit.count({
     *   where: {
     *     // ... the filter for the ShippingAudits we want to count
     *   }
     * })
    **/
    count<T extends ShippingAuditCountArgs>(
      args?: Subset<T, ShippingAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShippingAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingAuditAggregateArgs>(args: Subset<T, ShippingAuditAggregateArgs>): Prisma.PrismaPromise<GetShippingAuditAggregateType<T>>

    /**
     * Group by ShippingAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingAuditGroupByArgs['orderBy'] }
        : { orderBy?: ShippingAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShippingAudit model
   */
  readonly fields: ShippingAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShippingAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShippingAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shipping<T extends ShippingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShippingDefaultArgs<ExtArgs>>): Prisma__ShippingClient<$Result.GetResult<Prisma.$ShippingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShippingAudit model
   */
  interface ShippingAuditFieldRefs {
    readonly id: FieldRef<"ShippingAudit", 'String'>
    readonly shippingId: FieldRef<"ShippingAudit", 'String'>
    readonly action: FieldRef<"ShippingAudit", 'String'>
    readonly details: FieldRef<"ShippingAudit", 'String'>
    readonly createdAt: FieldRef<"ShippingAudit", 'DateTime'>
    readonly updatedAt: FieldRef<"ShippingAudit", 'DateTime'>
    readonly userId: FieldRef<"ShippingAudit", 'String'>
    readonly metadata: FieldRef<"ShippingAudit", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ShippingAudit findUnique
   */
  export type ShippingAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditInclude<ExtArgs> | null
    /**
     * Filter, which ShippingAudit to fetch.
     */
    where: ShippingAuditWhereUniqueInput
  }

  /**
   * ShippingAudit findUniqueOrThrow
   */
  export type ShippingAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditInclude<ExtArgs> | null
    /**
     * Filter, which ShippingAudit to fetch.
     */
    where: ShippingAuditWhereUniqueInput
  }

  /**
   * ShippingAudit findFirst
   */
  export type ShippingAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditInclude<ExtArgs> | null
    /**
     * Filter, which ShippingAudit to fetch.
     */
    where?: ShippingAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingAudits to fetch.
     */
    orderBy?: ShippingAuditOrderByWithRelationInput | ShippingAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingAudits.
     */
    cursor?: ShippingAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingAudits.
     */
    distinct?: ShippingAuditScalarFieldEnum | ShippingAuditScalarFieldEnum[]
  }

  /**
   * ShippingAudit findFirstOrThrow
   */
  export type ShippingAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditInclude<ExtArgs> | null
    /**
     * Filter, which ShippingAudit to fetch.
     */
    where?: ShippingAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingAudits to fetch.
     */
    orderBy?: ShippingAuditOrderByWithRelationInput | ShippingAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingAudits.
     */
    cursor?: ShippingAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingAudits.
     */
    distinct?: ShippingAuditScalarFieldEnum | ShippingAuditScalarFieldEnum[]
  }

  /**
   * ShippingAudit findMany
   */
  export type ShippingAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditInclude<ExtArgs> | null
    /**
     * Filter, which ShippingAudits to fetch.
     */
    where?: ShippingAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingAudits to fetch.
     */
    orderBy?: ShippingAuditOrderByWithRelationInput | ShippingAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShippingAudits.
     */
    cursor?: ShippingAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingAudits.
     */
    skip?: number
    distinct?: ShippingAuditScalarFieldEnum | ShippingAuditScalarFieldEnum[]
  }

  /**
   * ShippingAudit create
   */
  export type ShippingAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a ShippingAudit.
     */
    data: XOR<ShippingAuditCreateInput, ShippingAuditUncheckedCreateInput>
  }

  /**
   * ShippingAudit createMany
   */
  export type ShippingAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShippingAudits.
     */
    data: ShippingAuditCreateManyInput | ShippingAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShippingAudit createManyAndReturn
   */
  export type ShippingAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * The data used to create many ShippingAudits.
     */
    data: ShippingAuditCreateManyInput | ShippingAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShippingAudit update
   */
  export type ShippingAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a ShippingAudit.
     */
    data: XOR<ShippingAuditUpdateInput, ShippingAuditUncheckedUpdateInput>
    /**
     * Choose, which ShippingAudit to update.
     */
    where: ShippingAuditWhereUniqueInput
  }

  /**
   * ShippingAudit updateMany
   */
  export type ShippingAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShippingAudits.
     */
    data: XOR<ShippingAuditUpdateManyMutationInput, ShippingAuditUncheckedUpdateManyInput>
    /**
     * Filter which ShippingAudits to update
     */
    where?: ShippingAuditWhereInput
    /**
     * Limit how many ShippingAudits to update.
     */
    limit?: number
  }

  /**
   * ShippingAudit updateManyAndReturn
   */
  export type ShippingAuditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * The data used to update ShippingAudits.
     */
    data: XOR<ShippingAuditUpdateManyMutationInput, ShippingAuditUncheckedUpdateManyInput>
    /**
     * Filter which ShippingAudits to update
     */
    where?: ShippingAuditWhereInput
    /**
     * Limit how many ShippingAudits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShippingAudit upsert
   */
  export type ShippingAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the ShippingAudit to update in case it exists.
     */
    where: ShippingAuditWhereUniqueInput
    /**
     * In case the ShippingAudit found by the `where` argument doesn't exist, create a new ShippingAudit with this data.
     */
    create: XOR<ShippingAuditCreateInput, ShippingAuditUncheckedCreateInput>
    /**
     * In case the ShippingAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShippingAuditUpdateInput, ShippingAuditUncheckedUpdateInput>
  }

  /**
   * ShippingAudit delete
   */
  export type ShippingAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditInclude<ExtArgs> | null
    /**
     * Filter which ShippingAudit to delete.
     */
    where: ShippingAuditWhereUniqueInput
  }

  /**
   * ShippingAudit deleteMany
   */
  export type ShippingAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingAudits to delete
     */
    where?: ShippingAuditWhereInput
    /**
     * Limit how many ShippingAudits to delete.
     */
    limit?: number
  }

  /**
   * ShippingAudit without action
   */
  export type ShippingAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingAudit
     */
    select?: ShippingAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingAudit
     */
    omit?: ShippingAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingAuditInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    customersId: number | null
    cardBin: number | null
    cardLast4: number | null
    expMonth: number | null
    expYear: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    customersId: number | null
    cardBin: number | null
    cardLast4: number | null
    expMonth: number | null
    expYear: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    channel: string | null
    customersId: number | null
    customersCode: string | null
    storeId: string | null
    authorizationCode: string | null
    status: string | null
    cardType: string | null
    cardBank: string | null
    cardBrand: string | null
    countryCode: string | null
    accountName: string | null
    cardBin: number | null
    cardLast4: number | null
    expMonth: number | null
    expYear: number | null
    interval: string | null
    emailToken: string | null
    startDate: Date | null
    endsAt: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    channel: string | null
    customersId: number | null
    customersCode: string | null
    storeId: string | null
    authorizationCode: string | null
    status: string | null
    cardType: string | null
    cardBank: string | null
    cardBrand: string | null
    countryCode: string | null
    accountName: string | null
    cardBin: number | null
    cardLast4: number | null
    expMonth: number | null
    expYear: number | null
    interval: string | null
    emailToken: string | null
    startDate: Date | null
    endsAt: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    amount: number
    channel: number
    customersId: number
    customersCode: number
    storeId: number
    authorizationCode: number
    status: number
    cardType: number
    cardBank: number
    cardBrand: number
    countryCode: number
    accountName: number
    cardBin: number
    cardLast4: number
    expMonth: number
    expYear: number
    interval: number
    emailToken: number
    startDate: number
    endsAt: number
    cancelledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    id?: true
    amount?: true
    customersId?: true
    cardBin?: true
    cardLast4?: true
    expMonth?: true
    expYear?: true
  }

  export type SubscriptionSumAggregateInputType = {
    id?: true
    amount?: true
    customersId?: true
    cardBin?: true
    cardLast4?: true
    expMonth?: true
    expYear?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    amount?: true
    channel?: true
    customersId?: true
    customersCode?: true
    storeId?: true
    authorizationCode?: true
    status?: true
    cardType?: true
    cardBank?: true
    cardBrand?: true
    countryCode?: true
    accountName?: true
    cardBin?: true
    cardLast4?: true
    expMonth?: true
    expYear?: true
    interval?: true
    emailToken?: true
    startDate?: true
    endsAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    amount?: true
    channel?: true
    customersId?: true
    customersCode?: true
    storeId?: true
    authorizationCode?: true
    status?: true
    cardType?: true
    cardBank?: true
    cardBrand?: true
    countryCode?: true
    accountName?: true
    cardBin?: true
    cardLast4?: true
    expMonth?: true
    expYear?: true
    interval?: true
    emailToken?: true
    startDate?: true
    endsAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    amount?: true
    channel?: true
    customersId?: true
    customersCode?: true
    storeId?: true
    authorizationCode?: true
    status?: true
    cardType?: true
    cardBank?: true
    cardBrand?: true
    countryCode?: true
    accountName?: true
    cardBin?: true
    cardLast4?: true
    expMonth?: true
    expYear?: true
    interval?: true
    emailToken?: true
    startDate?: true
    endsAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: number
    amount: Decimal | null
    channel: string | null
    customersId: number | null
    customersCode: string | null
    storeId: string | null
    authorizationCode: string | null
    status: string | null
    cardType: string | null
    cardBank: string | null
    cardBrand: string | null
    countryCode: string | null
    accountName: string | null
    cardBin: number | null
    cardLast4: number | null
    expMonth: number | null
    expYear: number | null
    interval: string | null
    emailToken: string | null
    startDate: Date | null
    endsAt: Date | null
    cancelledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    channel?: boolean
    customersId?: boolean
    customersCode?: boolean
    storeId?: boolean
    authorizationCode?: boolean
    status?: boolean
    cardType?: boolean
    cardBank?: boolean
    cardBrand?: boolean
    countryCode?: boolean
    accountName?: boolean
    cardBin?: boolean
    cardLast4?: boolean
    expMonth?: boolean
    expYear?: boolean
    interval?: boolean
    emailToken?: boolean
    startDate?: boolean
    endsAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | Subscription$storeArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    channel?: boolean
    customersId?: boolean
    customersCode?: boolean
    storeId?: boolean
    authorizationCode?: boolean
    status?: boolean
    cardType?: boolean
    cardBank?: boolean
    cardBrand?: boolean
    countryCode?: boolean
    accountName?: boolean
    cardBin?: boolean
    cardLast4?: boolean
    expMonth?: boolean
    expYear?: boolean
    interval?: boolean
    emailToken?: boolean
    startDate?: boolean
    endsAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | Subscription$storeArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    channel?: boolean
    customersId?: boolean
    customersCode?: boolean
    storeId?: boolean
    authorizationCode?: boolean
    status?: boolean
    cardType?: boolean
    cardBank?: boolean
    cardBrand?: boolean
    countryCode?: boolean
    accountName?: boolean
    cardBin?: boolean
    cardLast4?: boolean
    expMonth?: boolean
    expYear?: boolean
    interval?: boolean
    emailToken?: boolean
    startDate?: boolean
    endsAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | Subscription$storeArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    amount?: boolean
    channel?: boolean
    customersId?: boolean
    customersCode?: boolean
    storeId?: boolean
    authorizationCode?: boolean
    status?: boolean
    cardType?: boolean
    cardBank?: boolean
    cardBrand?: boolean
    countryCode?: boolean
    accountName?: boolean
    cardBin?: boolean
    cardLast4?: boolean
    expMonth?: boolean
    expYear?: boolean
    interval?: boolean
    emailToken?: boolean
    startDate?: boolean
    endsAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "channel" | "customersId" | "customersCode" | "storeId" | "authorizationCode" | "status" | "cardType" | "cardBank" | "cardBrand" | "countryCode" | "accountName" | "cardBin" | "cardLast4" | "expMonth" | "expYear" | "interval" | "emailToken" | "startDate" | "endsAt" | "cancelledAt" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | Subscription$storeArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | Subscription$storeArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | Subscription$storeArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      store: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: Prisma.Decimal | null
      channel: string | null
      customersId: number | null
      customersCode: string | null
      storeId: string | null
      authorizationCode: string | null
      status: string | null
      cardType: string | null
      cardBank: string | null
      cardBrand: string | null
      countryCode: string | null
      accountName: string | null
      cardBin: number | null
      cardLast4: number | null
      expMonth: number | null
      expYear: number | null
      interval: string | null
      emailToken: string | null
      startDate: Date | null
      endsAt: Date | null
      cancelledAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends Subscription$storeArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$storeArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'Int'>
    readonly amount: FieldRef<"Subscription", 'Decimal'>
    readonly channel: FieldRef<"Subscription", 'String'>
    readonly customersId: FieldRef<"Subscription", 'Int'>
    readonly customersCode: FieldRef<"Subscription", 'String'>
    readonly storeId: FieldRef<"Subscription", 'String'>
    readonly authorizationCode: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly cardType: FieldRef<"Subscription", 'String'>
    readonly cardBank: FieldRef<"Subscription", 'String'>
    readonly cardBrand: FieldRef<"Subscription", 'String'>
    readonly countryCode: FieldRef<"Subscription", 'String'>
    readonly accountName: FieldRef<"Subscription", 'String'>
    readonly cardBin: FieldRef<"Subscription", 'Int'>
    readonly cardLast4: FieldRef<"Subscription", 'Int'>
    readonly expMonth: FieldRef<"Subscription", 'Int'>
    readonly expYear: FieldRef<"Subscription", 'Int'>
    readonly interval: FieldRef<"Subscription", 'String'>
    readonly emailToken: FieldRef<"Subscription", 'String'>
    readonly startDate: FieldRef<"Subscription", 'DateTime'>
    readonly endsAt: FieldRef<"Subscription", 'DateTime'>
    readonly cancelledAt: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.store
   */
  export type Subscription$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    id: number | null
    plansId: number | null
  }

  export type PlanSumAggregateOutputType = {
    id: number | null
    plansId: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: number | null
    plansName: string | null
    plansCode: string | null
    plansId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: number | null
    plansName: string | null
    plansCode: string | null
    plansId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    plansName: number
    plansCode: number
    plansId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    id?: true
    plansId?: true
  }

  export type PlanSumAggregateInputType = {
    id?: true
    plansId?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    plansName?: true
    plansCode?: true
    plansId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    plansName?: true
    plansCode?: true
    plansId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    plansName?: true
    plansCode?: true
    plansId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: number
    plansName: string
    plansCode: string
    plansId: number
    createdAt: Date
    updatedAt: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plansName?: boolean
    plansCode?: boolean
    plansId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plansName?: boolean
    plansCode?: boolean
    plansId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plansName?: boolean
    plansCode?: boolean
    plansId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    plansName?: boolean
    plansCode?: boolean
    plansId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plansName" | "plansCode" | "plansId" | "createdAt" | "updatedAt", ExtArgs["result"]["plan"]>

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      plansName: string
      plansCode: string
      plansId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {PlanUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'Int'>
    readonly plansName: FieldRef<"Plan", 'String'>
    readonly plansCode: FieldRef<"Plan", 'String'>
    readonly plansId: FieldRef<"Plan", 'Int'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan updateManyAndReturn
   */
  export type PlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to delete.
     */
    limit?: number
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    storeId: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    storeId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    storeId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    storeId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    storeId: string | null
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | Transaction$storeArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | Transaction$storeArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | Transaction$storeArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    storeId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeId" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | Transaction$storeArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | Transaction$storeArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | Transaction$storeArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      store: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string | null
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends Transaction$storeArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$storeArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly storeId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.store
   */
  export type Transaction$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: string | null
    name: string | null
    isDefaultLocation: boolean | null
    staffId: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isDefaultLocation: boolean | null
    staffId: string | null
    storeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    name: number
    isDefaultLocation: number
    staffId: number
    storeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseMinAggregateInputType = {
    id?: true
    name?: true
    isDefaultLocation?: true
    staffId?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    name?: true
    isDefaultLocation?: true
    staffId?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    name?: true
    isDefaultLocation?: true
    staffId?: true
    storeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouse to aggregate.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithAggregationInput | WarehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    id: string
    name: string
    isDefaultLocation: boolean | null
    staffId: string
    storeId: string
    createdAt: Date
    updatedAt: Date
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isDefaultLocation?: boolean
    staffId?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventory?: boolean | Warehouse$inventoryArgs<ExtArgs>
    inventoryItems?: boolean | Warehouse$inventoryItemsArgs<ExtArgs>
    staffAssigned?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isDefaultLocation?: boolean
    staffId?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staffAssigned?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isDefaultLocation?: boolean
    staffId?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staffAssigned?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectScalar = {
    id?: boolean
    name?: boolean
    isDefaultLocation?: boolean
    staffId?: boolean
    storeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isDefaultLocation" | "staffId" | "storeId" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouse"]>
  export type WarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | Warehouse$inventoryArgs<ExtArgs>
    inventoryItems?: boolean | Warehouse$inventoryItemsArgs<ExtArgs>
    staffAssigned?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffAssigned?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffAssigned?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $WarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouse"
    objects: {
      inventory: Prisma.$ProductPayload<ExtArgs>[]
      inventoryItems: Prisma.$InventoryPayload<ExtArgs>[]
      staffAssigned: Prisma.$UserPayload<ExtArgs>
      store: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isDefaultLocation: boolean | null
      staffId: string
      storeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type WarehouseGetPayload<S extends boolean | null | undefined | WarehouseDefaultArgs> = $Result.GetResult<Prisma.$WarehousePayload, S>

  type WarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface WarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouse'], meta: { name: 'Warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseFindUniqueArgs>(args: SelectSubset<T, WarehouseFindUniqueArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseFindFirstArgs>(args?: SelectSubset<T, WarehouseFindFirstArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseFindManyArgs>(args?: SelectSubset<T, WarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends WarehouseCreateArgs>(args: SelectSubset<T, WarehouseCreateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Warehouses.
     * @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseCreateManyArgs>(args?: SelectSubset<T, WarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouses and returns the data saved in the database.
     * @param {WarehouseCreateManyAndReturnArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends WarehouseDeleteArgs>(args: SelectSubset<T, WarehouseDeleteArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseUpdateArgs>(args: SelectSubset<T, WarehouseUpdateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseDeleteManyArgs>(args?: SelectSubset<T, WarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseUpdateManyArgs>(args: SelectSubset<T, WarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses and returns the data updated in the database.
     * @param {WarehouseUpdateManyAndReturnArgs} args - Arguments to update many Warehouses.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseUpsertArgs>(args: SelectSubset<T, WarehouseUpsertArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouse model
   */
  readonly fields: WarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventory<T extends Warehouse$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryItems<T extends Warehouse$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staffAssigned<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    store<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Warehouse model
   */
  interface WarehouseFieldRefs {
    readonly id: FieldRef<"Warehouse", 'String'>
    readonly name: FieldRef<"Warehouse", 'String'>
    readonly isDefaultLocation: FieldRef<"Warehouse", 'Boolean'>
    readonly staffId: FieldRef<"Warehouse", 'String'>
    readonly storeId: FieldRef<"Warehouse", 'String'>
    readonly createdAt: FieldRef<"Warehouse", 'DateTime'>
    readonly updatedAt: FieldRef<"Warehouse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findUniqueOrThrow
   */
  export type WarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findFirstOrThrow
   */
  export type WarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouse.
     */
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }

  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse createManyAndReturn
   */
  export type WarehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouse.
     */
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse updateManyAndReturn
   */
  export type WarehouseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     */
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     */
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }

  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter which Warehouse to delete.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to delete.
     */
    limit?: number
  }

  /**
   * Warehouse.inventory
   */
  export type Warehouse$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Warehouse.inventoryItems
   */
  export type Warehouse$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Warehouse without action
   */
  export type WarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventorySumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    productId: string | null
    warehouseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    productId: string | null
    warehouseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    quantity: number
    productId: number
    warehouseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    quantity?: true
  }

  export type InventorySumAggregateInputType = {
    quantity?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    quantity?: true
    productId?: true
    warehouseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    quantity?: true
    productId?: true
    warehouseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    quantity?: true
    productId?: true
    warehouseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    quantity: number
    productId: string
    warehouseId: string
    createdAt: Date
    updatedAt: Date
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    productId?: boolean
    warehouseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    productId?: boolean
    warehouseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    productId?: boolean
    warehouseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    quantity?: boolean
    productId?: boolean
    warehouseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "productId" | "warehouseId" | "createdAt" | "updatedAt", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quantity: number
      productId: string
      warehouseId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories and returns the data updated in the database.
     * @param {InventoryUpdateManyAndReturnArgs} args - Arguments to update many Inventories.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly quantity: FieldRef<"Inventory", 'Int'>
    readonly productId: FieldRef<"Inventory", 'String'>
    readonly warehouseId: FieldRef<"Inventory", 'String'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory updateManyAndReturn
   */
  export type InventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CartScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    customerId: 'customerId',
    orderId: 'orderId',
    totalAmount: 'totalAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const CartItemScalarFieldEnum: {
    id: 'id',
    cartId: 'cartId',
    productId: 'productId',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phoneNumber: 'phoneNumber',
    avatar: 'avatar',
    isGuest: 'isGuest',
    customerType: 'customerType',
    storeId: 'storeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const PurchaseHistoryScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    totalAmount: 'totalAmount',
    date: 'date',
    customerId: 'customerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseHistoryScalarFieldEnum = (typeof PurchaseHistoryScalarFieldEnum)[keyof typeof PurchaseHistoryScalarFieldEnum]


  export const CustomerGroupsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    storeId: 'storeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerGroupsScalarFieldEnum = (typeof CustomerGroupsScalarFieldEnum)[keyof typeof CustomerGroupsScalarFieldEnum]


  export const CustomerGroupMemberScalarFieldEnum: {
    customerId: 'customerId',
    customerGroupId: 'customerGroupId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerGroupMemberScalarFieldEnum = (typeof CustomerGroupMemberScalarFieldEnum)[keyof typeof CustomerGroupMemberScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    amount: 'amount',
    description: 'description',
    paymentMethod: 'paymentMethod',
    paymentStatus: 'paymentStatus',
    date: 'date',
    locationId: 'locationId',
    storeId: 'storeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const ExpenseCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    date: 'date',
    expenseId: 'expenseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseCategoryScalarFieldEnum = (typeof ExpenseCategoryScalarFieldEnum)[keyof typeof ExpenseCategoryScalarFieldEnum]


  export const FeatureFlagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    isEnabled: 'isEnabled',
    rollout: 'rollout',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureFlagScalarFieldEnum = (typeof FeatureFlagScalarFieldEnum)[keyof typeof FeatureFlagScalarFieldEnum]


  export const BankDetailsScalarFieldEnum: {
    id: 'id',
    bankName: 'bankName',
    bankCode: 'bankCode',
    accountName: 'accountName',
    accountNumber: 'accountNumber',
    storeId: 'storeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankDetailsScalarFieldEnum = (typeof BankDetailsScalarFieldEnum)[keyof typeof BankDetailsScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    balance: 'balance',
    storeId: 'storeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    invoiceNumber: 'invoiceNumber',
    title: 'title',
    customerEmail: 'customerEmail',
    description: 'description',
    status: 'status',
    downloadUrl: 'downloadUrl',
    paymentLink: 'paymentLink',
    qrCode: 'qrCode',
    amount: 'amount',
    total: 'total',
    tax: 'tax',
    dueDate: 'dueDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    country: 'country',
    region: 'region',
    city: 'city',
    description: 'description',
    storeId: 'storeId',
    isdefaultLocation: 'isdefaultLocation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    locationId: 'locationId',
    createdBy: 'createdBy',
    storeId: 'storeId',
    shippingMethodId: 'shippingMethodId',
    grandTotal: 'grandTotal',
    iscustomerAssigned: 'iscustomerAssigned',
    status: 'status',
    paymentStatus: 'paymentStatus',
    paymentMethod: 'paymentMethod',
    deliveryTrackingNumber: 'deliveryTrackingNumber',
    totalAmount: 'totalAmount',
    subtotalAmount: 'subtotalAmount',
    discountAmount: 'discountAmount',
    taxAmount: 'taxAmount',
    shippingFee: 'shippingFee',
    shippingZoneName: 'shippingZoneName',
    shippingAddress: 'shippingAddress',
    shippingStatus: 'shippingStatus',
    channel: 'channel',
    isposConfirmed: 'isposConfirmed',
    customerName: 'customerName',
    customerEmail: 'customerEmail',
    customerPhoneNumber: 'customerPhoneNumber',
    posConfirmedAt: 'posConfirmedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    price: 'price',
    orderId: 'orderId'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const POSScalarFieldEnum: {
    id: 'id',
    staffId: 'staffId',
    orderId: 'orderId',
    customerId: 'customerId',
    terminalId: 'terminalId',
    confirmed: 'confirmed',
    confirmedAt: 'confirmedAt'
  };

  export type POSScalarFieldEnum = (typeof POSScalarFieldEnum)[keyof typeof POSScalarFieldEnum]


  export const PointOfSaleScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    staffAssignedId: 'staffAssignedId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PointOfSaleScalarFieldEnum = (typeof PointOfSaleScalarFieldEnum)[keyof typeof PointOfSaleScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shortDescription: 'shortDescription',
    description: 'description',
    sku: 'sku',
    stock: 'stock',
    price: 'price',
    shippingWeight: 'shippingWeight',
    handleTime: 'handleTime',
    freeShipping: 'freeShipping',
    packaging: 'packaging',
    discountPrice: 'discountPrice',
    unitSold: 'unitSold',
    length: 'length',
    width: 'width',
    height: 'height',
    productSize: 'productSize',
    productStatus: 'productStatus',
    imageUrl: 'imageUrl',
    storeId: 'storeId',
    locationId: 'locationId',
    purchaseOrderId: 'purchaseOrderId',
    collectionId: 'collectionId',
    hasVariation: 'hasVariation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    warehouseId: 'warehouseId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    storeId: 'storeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductCollectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCollectionScalarFieldEnum = (typeof ProductCollectionScalarFieldEnum)[keyof typeof ProductCollectionScalarFieldEnum]


  export const ProductVariationScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    sku: 'sku',
    price: 'price',
    cost: 'cost',
    discountPrice: 'discountPrice',
    stock: 'stock',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVariationScalarFieldEnum = (typeof ProductVariationScalarFieldEnum)[keyof typeof ProductVariationScalarFieldEnum]


  export const ProductVariantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVariantScalarFieldEnum = (typeof ProductVariantScalarFieldEnum)[keyof typeof ProductVariantScalarFieldEnum]


  export const ProductVariantValueScalarFieldEnum: {
    id: 'id',
    variantId: 'variantId',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVariantValueScalarFieldEnum = (typeof ProductVariantValueScalarFieldEnum)[keyof typeof ProductVariantValueScalarFieldEnum]


  export const ProductVariationOptionScalarFieldEnum: {
    id: 'id',
    variationId: 'variationId',
    valueId: 'valueId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVariationOptionScalarFieldEnum = (typeof ProductVariationOptionScalarFieldEnum)[keyof typeof ProductVariationOptionScalarFieldEnum]


  export const FeaturedBrandsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeaturedBrandsScalarFieldEnum = (typeof FeaturedBrandsScalarFieldEnum)[keyof typeof FeaturedBrandsScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    supplierName: 'supplierName',
    email: 'email',
    phoneNumber: 'phoneNumber',
    personOfSupplier: 'personOfSupplier',
    location: 'location',
    storeId: 'storeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    status: 'status',
    downloadUrl: 'downloadUrl',
    toalCost: 'toalCost',
    storeSupplierId: 'storeSupplierId',
    storeId: 'storeId',
    deliveryDate: 'deliveryDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    email: 'email',
    phoneNumber: 'phoneNumber',
    emailVerified: 'emailVerified',
    image: 'image',
    role: 'role',
    banned: 'banned',
    banReason: 'banReason',
    banExpires: 'banExpires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    locationId: 'locationId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId',
    impersonatedBy: 'impersonatedBy',
    activeOrganizationId: 'activeOrganizationId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logo: 'logo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    metadata: 'metadata',
    businessName: 'businessName',
    businessType: 'businessType',
    storeBaseCurrency: 'storeBaseCurrency',
    banner: 'banner',
    phoneNumber: 'phoneNumber',
    email: 'email',
    website: 'website',
    description: 'description',
    country: 'country',
    address: 'address',
    state: 'state',
    region: 'region',
    zipCode: 'zipCode',
    city: 'city',
    status: 'status',
    storeTag: 'storeTag',
    whitelabel: 'whitelabel',
    facebook: 'facebook',
    instagram: 'instagram',
    tiktok: 'tiktok',
    twitter: 'twitter',
    linkedin: 'linkedin',
    currency: 'currency',
    storeUrl: 'storeUrl',
    storeApproval: 'storeApproval',
    modifyProductState: 'modifyProductState'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    email: 'email',
    role: 'role',
    status: 'status',
    expiresAt: 'expiresAt',
    inviterId: 'inviterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const SettlementScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    storeId: 'storeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettlementScalarFieldEnum = (typeof SettlementScalarFieldEnum)[keyof typeof SettlementScalarFieldEnum]


  export const ShippingScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    shippingMethodId: 'shippingMethodId',
    trackingNumber: 'trackingNumber',
    carrier: 'carrier',
    status: 'status',
    estimatedDelivery: 'estimatedDelivery',
    actualDelivery: 'actualDelivery',
    shippingAddress: 'shippingAddress',
    shippingZoneName: 'shippingZoneName',
    shippingFee: 'shippingFee',
    weight: 'weight',
    dimensions: 'dimensions',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShippingScalarFieldEnum = (typeof ShippingScalarFieldEnum)[keyof typeof ShippingScalarFieldEnum]


  export const ShippingMethodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    storeId: 'storeId',
    description: 'description',
    carrier: 'carrier',
    deliveryTime: 'deliveryTime',
    baseCost: 'baseCost',
    costCalculation: 'costCalculation',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShippingMethodScalarFieldEnum = (typeof ShippingMethodScalarFieldEnum)[keyof typeof ShippingMethodScalarFieldEnum]


  export const ShippingZoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    storeId: 'storeId',
    countries: 'countries',
    regions: 'regions',
    postalCodes: 'postalCodes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShippingZoneScalarFieldEnum = (typeof ShippingZoneScalarFieldEnum)[keyof typeof ShippingZoneScalarFieldEnum]


  export const ShippingAuditScalarFieldEnum: {
    id: 'id',
    shippingId: 'shippingId',
    action: 'action',
    details: 'details',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    metadata: 'metadata'
  };

  export type ShippingAuditScalarFieldEnum = (typeof ShippingAuditScalarFieldEnum)[keyof typeof ShippingAuditScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    channel: 'channel',
    customersId: 'customersId',
    customersCode: 'customersCode',
    storeId: 'storeId',
    authorizationCode: 'authorizationCode',
    status: 'status',
    cardType: 'cardType',
    cardBank: 'cardBank',
    cardBrand: 'cardBrand',
    countryCode: 'countryCode',
    accountName: 'accountName',
    cardBin: 'cardBin',
    cardLast4: 'cardLast4',
    expMonth: 'expMonth',
    expYear: 'expYear',
    interval: 'interval',
    emailToken: 'emailToken',
    startDate: 'startDate',
    endsAt: 'endsAt',
    cancelledAt: 'cancelledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    plansName: 'plansName',
    plansCode: 'plansCode',
    plansId: 'plansId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isDefaultLocation: 'isDefaultLocation',
    staffId: 'staffId',
    storeId: 'storeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    productId: 'productId',
    warehouseId: 'warehouseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CustomerType'
   */
  export type EnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType'>
    


  /**
   * Reference to a field of type 'CustomerType[]'
   */
  export type ListEnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'ProductStatus'
   */
  export type EnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus'>
    


  /**
   * Reference to a field of type 'ProductStatus[]'
   */
  export type ListEnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus[]'>
    


  /**
   * Reference to a field of type 'ShippingStatus'
   */
  export type EnumShippingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShippingStatus'>
    


  /**
   * Reference to a field of type 'ShippingStatus[]'
   */
  export type ListEnumShippingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShippingStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    id?: StringFilter<"Cart"> | string
    storeId?: StringFilter<"Cart"> | string
    customerId?: StringFilter<"Cart"> | string
    orderId?: StringFilter<"Cart"> | string
    totalAmount?: FloatFilter<"Cart"> | number
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    cartItems?: CartItemListRelationFilter
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cartItems?: CartItemOrderByRelationAggregateInput
    order?: OrderOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    storeId?: StringFilter<"Cart"> | string
    customerId?: StringFilter<"Cart"> | string
    totalAmount?: FloatFilter<"Cart"> | number
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    cartItems?: CartItemListRelationFilter
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id" | "orderId">

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartCountOrderByAggregateInput
    _avg?: CartAvgOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
    _sum?: CartSumOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cart"> | string
    storeId?: StringWithAggregatesFilter<"Cart"> | string
    customerId?: StringWithAggregatesFilter<"Cart"> | string
    orderId?: StringWithAggregatesFilter<"Cart"> | string
    totalAmount?: FloatWithAggregatesFilter<"Cart"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
  }

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    price?: FloatFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cart?: CartOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type CartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    price?: FloatFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartItemCountOrderByAggregateInput
    _avg?: CartItemAvgOrderByAggregateInput
    _max?: CartItemMaxOrderByAggregateInput
    _min?: CartItemMinOrderByAggregateInput
    _sum?: CartItemSumOrderByAggregateInput
  }

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    OR?: CartItemScalarWhereWithAggregatesInput[]
    NOT?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItem"> | string
    cartId?: StringWithAggregatesFilter<"CartItem"> | string
    productId?: StringWithAggregatesFilter<"CartItem"> | string
    quantity?: IntWithAggregatesFilter<"CartItem"> | number
    price?: FloatWithAggregatesFilter<"CartItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    avatar?: StringNullableFilter<"Customer"> | string | null
    isGuest?: BoolFilter<"Customer"> | boolean
    customerType?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    storeId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    orders?: OrderListRelationFilter
    carts?: CartListRelationFilter
    purchaseHistory?: PurchaseHistoryListRelationFilter
    pos?: POSListRelationFilter
    customerGroupMember?: CustomerGroupMemberListRelationFilter
    store?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    isGuest?: SortOrder
    customerType?: SortOrder
    storeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    carts?: CartOrderByRelationAggregateInput
    purchaseHistory?: PurchaseHistoryOrderByRelationAggregateInput
    pos?: POSOrderByRelationAggregateInput
    customerGroupMember?: CustomerGroupMemberOrderByRelationAggregateInput
    store?: OrganizationOrderByWithRelationInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    avatar?: StringNullableFilter<"Customer"> | string | null
    isGuest?: BoolFilter<"Customer"> | boolean
    customerType?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    storeId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    orders?: OrderListRelationFilter
    carts?: CartListRelationFilter
    purchaseHistory?: PurchaseHistoryListRelationFilter
    pos?: POSListRelationFilter
    customerGroupMember?: CustomerGroupMemberListRelationFilter
    store?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    isGuest?: SortOrder
    customerType?: SortOrder
    storeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    isGuest?: BoolWithAggregatesFilter<"Customer"> | boolean
    customerType?: EnumCustomerTypeWithAggregatesFilter<"Customer"> | $Enums.CustomerType
    storeId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type PurchaseHistoryWhereInput = {
    AND?: PurchaseHistoryWhereInput | PurchaseHistoryWhereInput[]
    OR?: PurchaseHistoryWhereInput[]
    NOT?: PurchaseHistoryWhereInput | PurchaseHistoryWhereInput[]
    id?: StringFilter<"PurchaseHistory"> | string
    orderId?: StringFilter<"PurchaseHistory"> | string
    totalAmount?: FloatFilter<"PurchaseHistory"> | number
    date?: DateTimeFilter<"PurchaseHistory"> | Date | string
    customerId?: StringFilter<"PurchaseHistory"> | string
    createdAt?: DateTimeFilter<"PurchaseHistory"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseHistory"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type PurchaseHistoryOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    totalAmount?: SortOrder
    date?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type PurchaseHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseHistoryWhereInput | PurchaseHistoryWhereInput[]
    OR?: PurchaseHistoryWhereInput[]
    NOT?: PurchaseHistoryWhereInput | PurchaseHistoryWhereInput[]
    orderId?: StringFilter<"PurchaseHistory"> | string
    totalAmount?: FloatFilter<"PurchaseHistory"> | number
    date?: DateTimeFilter<"PurchaseHistory"> | Date | string
    customerId?: StringFilter<"PurchaseHistory"> | string
    createdAt?: DateTimeFilter<"PurchaseHistory"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseHistory"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type PurchaseHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    totalAmount?: SortOrder
    date?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseHistoryCountOrderByAggregateInput
    _avg?: PurchaseHistoryAvgOrderByAggregateInput
    _max?: PurchaseHistoryMaxOrderByAggregateInput
    _min?: PurchaseHistoryMinOrderByAggregateInput
    _sum?: PurchaseHistorySumOrderByAggregateInput
  }

  export type PurchaseHistoryScalarWhereWithAggregatesInput = {
    AND?: PurchaseHistoryScalarWhereWithAggregatesInput | PurchaseHistoryScalarWhereWithAggregatesInput[]
    OR?: PurchaseHistoryScalarWhereWithAggregatesInput[]
    NOT?: PurchaseHistoryScalarWhereWithAggregatesInput | PurchaseHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseHistory"> | string
    orderId?: StringWithAggregatesFilter<"PurchaseHistory"> | string
    totalAmount?: FloatWithAggregatesFilter<"PurchaseHistory"> | number
    date?: DateTimeWithAggregatesFilter<"PurchaseHistory"> | Date | string
    customerId?: StringWithAggregatesFilter<"PurchaseHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseHistory"> | Date | string
  }

  export type CustomerGroupsWhereInput = {
    AND?: CustomerGroupsWhereInput | CustomerGroupsWhereInput[]
    OR?: CustomerGroupsWhereInput[]
    NOT?: CustomerGroupsWhereInput | CustomerGroupsWhereInput[]
    id?: StringFilter<"CustomerGroups"> | string
    name?: StringFilter<"CustomerGroups"> | string
    storeId?: StringFilter<"CustomerGroups"> | string
    createdAt?: DateTimeFilter<"CustomerGroups"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerGroups"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    customerGroupMember?: CustomerGroupMemberListRelationFilter
  }

  export type CustomerGroupsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: OrganizationOrderByWithRelationInput
    customerGroupMember?: CustomerGroupMemberOrderByRelationAggregateInput
  }

  export type CustomerGroupsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerGroupsWhereInput | CustomerGroupsWhereInput[]
    OR?: CustomerGroupsWhereInput[]
    NOT?: CustomerGroupsWhereInput | CustomerGroupsWhereInput[]
    name?: StringFilter<"CustomerGroups"> | string
    storeId?: StringFilter<"CustomerGroups"> | string
    createdAt?: DateTimeFilter<"CustomerGroups"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerGroups"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    customerGroupMember?: CustomerGroupMemberListRelationFilter
  }, "id">

  export type CustomerGroupsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerGroupsCountOrderByAggregateInput
    _max?: CustomerGroupsMaxOrderByAggregateInput
    _min?: CustomerGroupsMinOrderByAggregateInput
  }

  export type CustomerGroupsScalarWhereWithAggregatesInput = {
    AND?: CustomerGroupsScalarWhereWithAggregatesInput | CustomerGroupsScalarWhereWithAggregatesInput[]
    OR?: CustomerGroupsScalarWhereWithAggregatesInput[]
    NOT?: CustomerGroupsScalarWhereWithAggregatesInput | CustomerGroupsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerGroups"> | string
    name?: StringWithAggregatesFilter<"CustomerGroups"> | string
    storeId?: StringWithAggregatesFilter<"CustomerGroups"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomerGroups"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerGroups"> | Date | string
  }

  export type CustomerGroupMemberWhereInput = {
    AND?: CustomerGroupMemberWhereInput | CustomerGroupMemberWhereInput[]
    OR?: CustomerGroupMemberWhereInput[]
    NOT?: CustomerGroupMemberWhereInput | CustomerGroupMemberWhereInput[]
    customerId?: StringFilter<"CustomerGroupMember"> | string
    customerGroupId?: StringFilter<"CustomerGroupMember"> | string
    createdAt?: DateTimeFilter<"CustomerGroupMember"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerGroupMember"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    customerGroup?: XOR<CustomerGroupsScalarRelationFilter, CustomerGroupsWhereInput>
  }

  export type CustomerGroupMemberOrderByWithRelationInput = {
    customerId?: SortOrder
    customerGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    customerGroup?: CustomerGroupsOrderByWithRelationInput
  }

  export type CustomerGroupMemberWhereUniqueInput = Prisma.AtLeast<{
    customerId_customerGroupId?: CustomerGroupMemberCustomerIdCustomerGroupIdCompoundUniqueInput
    AND?: CustomerGroupMemberWhereInput | CustomerGroupMemberWhereInput[]
    OR?: CustomerGroupMemberWhereInput[]
    NOT?: CustomerGroupMemberWhereInput | CustomerGroupMemberWhereInput[]
    customerId?: StringFilter<"CustomerGroupMember"> | string
    customerGroupId?: StringFilter<"CustomerGroupMember"> | string
    createdAt?: DateTimeFilter<"CustomerGroupMember"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerGroupMember"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    customerGroup?: XOR<CustomerGroupsScalarRelationFilter, CustomerGroupsWhereInput>
  }, "customerId_customerGroupId">

  export type CustomerGroupMemberOrderByWithAggregationInput = {
    customerId?: SortOrder
    customerGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerGroupMemberCountOrderByAggregateInput
    _max?: CustomerGroupMemberMaxOrderByAggregateInput
    _min?: CustomerGroupMemberMinOrderByAggregateInput
  }

  export type CustomerGroupMemberScalarWhereWithAggregatesInput = {
    AND?: CustomerGroupMemberScalarWhereWithAggregatesInput | CustomerGroupMemberScalarWhereWithAggregatesInput[]
    OR?: CustomerGroupMemberScalarWhereWithAggregatesInput[]
    NOT?: CustomerGroupMemberScalarWhereWithAggregatesInput | CustomerGroupMemberScalarWhereWithAggregatesInput[]
    customerId?: StringWithAggregatesFilter<"CustomerGroupMember"> | string
    customerGroupId?: StringWithAggregatesFilter<"CustomerGroupMember"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomerGroupMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerGroupMember"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    name?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatNullableFilter<"Expense"> | number | null
    description?: StringNullableFilter<"Expense"> | string | null
    paymentMethod?: StringNullableFilter<"Expense"> | string | null
    paymentStatus?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeNullableFilter<"Expense"> | Date | string | null
    locationId?: StringFilter<"Expense"> | string
    storeId?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    expenseCategory?: ExpenseCategoryListRelationFilter
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    locationId?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expenseCategory?: ExpenseCategoryOrderByRelationAggregateInput
    store?: OrganizationOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    name?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatNullableFilter<"Expense"> | number | null
    description?: StringNullableFilter<"Expense"> | string | null
    paymentMethod?: StringNullableFilter<"Expense"> | string | null
    paymentStatus?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeNullableFilter<"Expense"> | Date | string | null
    locationId?: StringFilter<"Expense"> | string
    storeId?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    expenseCategory?: ExpenseCategoryListRelationFilter
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    locationId?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    name?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    amount?: FloatNullableWithAggregatesFilter<"Expense"> | number | null
    description?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    paymentStatus?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    locationId?: StringWithAggregatesFilter<"Expense"> | string
    storeId?: StringWithAggregatesFilter<"Expense"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type ExpenseCategoryWhereInput = {
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    id?: StringFilter<"ExpenseCategory"> | string
    name?: StringFilter<"ExpenseCategory"> | string
    description?: StringFilter<"ExpenseCategory"> | string
    date?: DateTimeFilter<"ExpenseCategory"> | Date | string
    expenseId?: StringFilter<"ExpenseCategory"> | string
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    expense?: XOR<ExpenseScalarRelationFilter, ExpenseWhereInput>
  }

  export type ExpenseCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    expenseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expense?: ExpenseOrderByWithRelationInput
  }

  export type ExpenseCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    expenseId?: string
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    name?: StringFilter<"ExpenseCategory"> | string
    description?: StringFilter<"ExpenseCategory"> | string
    date?: DateTimeFilter<"ExpenseCategory"> | Date | string
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    expense?: XOR<ExpenseScalarRelationFilter, ExpenseWhereInput>
  }, "id" | "expenseId">

  export type ExpenseCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    expenseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCategoryCountOrderByAggregateInput
    _max?: ExpenseCategoryMaxOrderByAggregateInput
    _min?: ExpenseCategoryMinOrderByAggregateInput
  }

  export type ExpenseCategoryScalarWhereWithAggregatesInput = {
    AND?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    OR?: ExpenseCategoryScalarWhereWithAggregatesInput[]
    NOT?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    name?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    description?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    date?: DateTimeWithAggregatesFilter<"ExpenseCategory"> | Date | string
    expenseId?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExpenseCategory"> | Date | string
  }

  export type FeatureFlagWhereInput = {
    AND?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    OR?: FeatureFlagWhereInput[]
    NOT?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    id?: StringFilter<"FeatureFlag"> | string
    name?: StringFilter<"FeatureFlag"> | string
    slug?: StringFilter<"FeatureFlag"> | string
    isEnabled?: BoolFilter<"FeatureFlag"> | boolean
    rollout?: IntFilter<"FeatureFlag"> | number
    description?: StringFilter<"FeatureFlag"> | string
    createdAt?: DateTimeFilter<"FeatureFlag"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureFlag"> | Date | string
  }

  export type FeatureFlagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isEnabled?: SortOrder
    rollout?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    OR?: FeatureFlagWhereInput[]
    NOT?: FeatureFlagWhereInput | FeatureFlagWhereInput[]
    name?: StringFilter<"FeatureFlag"> | string
    slug?: StringFilter<"FeatureFlag"> | string
    isEnabled?: BoolFilter<"FeatureFlag"> | boolean
    rollout?: IntFilter<"FeatureFlag"> | number
    description?: StringFilter<"FeatureFlag"> | string
    createdAt?: DateTimeFilter<"FeatureFlag"> | Date | string
    updatedAt?: DateTimeFilter<"FeatureFlag"> | Date | string
  }, "id">

  export type FeatureFlagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isEnabled?: SortOrder
    rollout?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureFlagCountOrderByAggregateInput
    _avg?: FeatureFlagAvgOrderByAggregateInput
    _max?: FeatureFlagMaxOrderByAggregateInput
    _min?: FeatureFlagMinOrderByAggregateInput
    _sum?: FeatureFlagSumOrderByAggregateInput
  }

  export type FeatureFlagScalarWhereWithAggregatesInput = {
    AND?: FeatureFlagScalarWhereWithAggregatesInput | FeatureFlagScalarWhereWithAggregatesInput[]
    OR?: FeatureFlagScalarWhereWithAggregatesInput[]
    NOT?: FeatureFlagScalarWhereWithAggregatesInput | FeatureFlagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeatureFlag"> | string
    name?: StringWithAggregatesFilter<"FeatureFlag"> | string
    slug?: StringWithAggregatesFilter<"FeatureFlag"> | string
    isEnabled?: BoolWithAggregatesFilter<"FeatureFlag"> | boolean
    rollout?: IntWithAggregatesFilter<"FeatureFlag"> | number
    description?: StringWithAggregatesFilter<"FeatureFlag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeatureFlag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeatureFlag"> | Date | string
  }

  export type BankDetailsWhereInput = {
    AND?: BankDetailsWhereInput | BankDetailsWhereInput[]
    OR?: BankDetailsWhereInput[]
    NOT?: BankDetailsWhereInput | BankDetailsWhereInput[]
    id?: StringFilter<"BankDetails"> | string
    bankName?: StringFilter<"BankDetails"> | string
    bankCode?: StringFilter<"BankDetails"> | string
    accountName?: StringFilter<"BankDetails"> | string
    accountNumber?: StringFilter<"BankDetails"> | string
    storeId?: StringFilter<"BankDetails"> | string
    createdAt?: DateTimeFilter<"BankDetails"> | Date | string
    updatedAt?: DateTimeFilter<"BankDetails"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type BankDetailsOrderByWithRelationInput = {
    id?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: OrganizationOrderByWithRelationInput
  }

  export type BankDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId?: string
    AND?: BankDetailsWhereInput | BankDetailsWhereInput[]
    OR?: BankDetailsWhereInput[]
    NOT?: BankDetailsWhereInput | BankDetailsWhereInput[]
    bankName?: StringFilter<"BankDetails"> | string
    bankCode?: StringFilter<"BankDetails"> | string
    accountName?: StringFilter<"BankDetails"> | string
    accountNumber?: StringFilter<"BankDetails"> | string
    createdAt?: DateTimeFilter<"BankDetails"> | Date | string
    updatedAt?: DateTimeFilter<"BankDetails"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "storeId">

  export type BankDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankDetailsCountOrderByAggregateInput
    _max?: BankDetailsMaxOrderByAggregateInput
    _min?: BankDetailsMinOrderByAggregateInput
  }

  export type BankDetailsScalarWhereWithAggregatesInput = {
    AND?: BankDetailsScalarWhereWithAggregatesInput | BankDetailsScalarWhereWithAggregatesInput[]
    OR?: BankDetailsScalarWhereWithAggregatesInput[]
    NOT?: BankDetailsScalarWhereWithAggregatesInput | BankDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankDetails"> | string
    bankName?: StringWithAggregatesFilter<"BankDetails"> | string
    bankCode?: StringWithAggregatesFilter<"BankDetails"> | string
    accountName?: StringWithAggregatesFilter<"BankDetails"> | string
    accountNumber?: StringWithAggregatesFilter<"BankDetails"> | string
    storeId?: StringWithAggregatesFilter<"BankDetails"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BankDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankDetails"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    balance?: DecimalFilter<"Wallet"> | Decimal | DecimalJsLike | number | string
    storeId?: StringFilter<"Wallet"> | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    balance?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: OrganizationOrderByWithRelationInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    balance?: DecimalFilter<"Wallet"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "storeId">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    balance?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    balance?: DecimalWithAggregatesFilter<"Wallet"> | Decimal | DecimalJsLike | number | string
    storeId?: StringWithAggregatesFilter<"Wallet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    storeId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    title?: StringFilter<"Invoice"> | string
    customerEmail?: StringFilter<"Invoice"> | string
    description?: StringNullableFilter<"Invoice"> | string | null
    status?: StringNullableFilter<"Invoice"> | string | null
    downloadUrl?: StringFilter<"Invoice"> | string
    paymentLink?: StringNullableFilter<"Invoice"> | string | null
    qrCode?: StringNullableFilter<"Invoice"> | string | null
    amount?: StringFilter<"Invoice"> | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    invoiceNumber?: SortOrder
    title?: SortOrder
    customerEmail?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    downloadUrl?: SortOrder
    paymentLink?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    amount?: SortOrder
    total?: SortOrder
    tax?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: OrganizationOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    storeId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    title?: StringFilter<"Invoice"> | string
    customerEmail?: StringFilter<"Invoice"> | string
    description?: StringNullableFilter<"Invoice"> | string | null
    status?: StringNullableFilter<"Invoice"> | string | null
    downloadUrl?: StringFilter<"Invoice"> | string
    paymentLink?: StringNullableFilter<"Invoice"> | string | null
    qrCode?: StringNullableFilter<"Invoice"> | string | null
    amount?: StringFilter<"Invoice"> | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    invoiceNumber?: SortOrder
    title?: SortOrder
    customerEmail?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    downloadUrl?: SortOrder
    paymentLink?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    amount?: SortOrder
    total?: SortOrder
    tax?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    storeId?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    title?: StringWithAggregatesFilter<"Invoice"> | string
    customerEmail?: StringWithAggregatesFilter<"Invoice"> | string
    description?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    status?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    downloadUrl?: StringWithAggregatesFilter<"Invoice"> | string
    paymentLink?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    qrCode?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    amount?: StringWithAggregatesFilter<"Invoice"> | string
    total?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    country?: StringNullableFilter<"Location"> | string | null
    region?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    description?: StringNullableFilter<"Location"> | string | null
    storeId?: StringFilter<"Location"> | string
    isdefaultLocation?: BoolNullableFilter<"Location"> | boolean | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    user?: UserListRelationFilter
    order?: OrderListRelationFilter
    product?: ProductListRelationFilter
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    storeId?: SortOrder
    isdefaultLocation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByRelationAggregateInput
    order?: OrderOrderByRelationAggregateInput
    product?: ProductOrderByRelationAggregateInput
    store?: OrganizationOrderByWithRelationInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    country?: StringNullableFilter<"Location"> | string | null
    region?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    description?: StringNullableFilter<"Location"> | string | null
    storeId?: StringFilter<"Location"> | string
    isdefaultLocation?: BoolNullableFilter<"Location"> | boolean | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    user?: UserListRelationFilter
    order?: OrderListRelationFilter
    product?: ProductListRelationFilter
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    storeId?: SortOrder
    isdefaultLocation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    address?: StringNullableWithAggregatesFilter<"Location"> | string | null
    country?: StringNullableWithAggregatesFilter<"Location"> | string | null
    region?: StringNullableWithAggregatesFilter<"Location"> | string | null
    city?: StringNullableWithAggregatesFilter<"Location"> | string | null
    description?: StringNullableWithAggregatesFilter<"Location"> | string | null
    storeId?: StringWithAggregatesFilter<"Location"> | string
    isdefaultLocation?: BoolNullableWithAggregatesFilter<"Location"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    customerId?: StringFilter<"Order"> | string
    locationId?: StringFilter<"Order"> | string
    createdBy?: StringNullableFilter<"Order"> | string | null
    storeId?: StringNullableFilter<"Order"> | string | null
    shippingMethodId?: StringNullableFilter<"Order"> | string | null
    grandTotal?: FloatFilter<"Order"> | number
    iscustomerAssigned?: BoolFilter<"Order"> | boolean
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"Order"> | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFilter<"Order"> | number
    totalAmount?: FloatFilter<"Order"> | number
    subtotalAmount?: FloatFilter<"Order"> | number
    discountAmount?: FloatNullableFilter<"Order"> | number | null
    taxAmount?: FloatFilter<"Order"> | number
    shippingFee?: FloatFilter<"Order"> | number
    shippingZoneName?: StringNullableFilter<"Order"> | string | null
    shippingAddress?: StringNullableFilter<"Order"> | string | null
    shippingStatus?: StringNullableFilter<"Order"> | string | null
    channel?: StringNullableFilter<"Order"> | string | null
    isposConfirmed?: BoolNullableFilter<"Order"> | boolean | null
    customerName?: StringFilter<"Order"> | string
    customerEmail?: StringFilter<"Order"> | string
    customerPhoneNumber?: StringFilter<"Order"> | string
    posConfirmedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderItems?: OrderItemListRelationFilter
    pos?: XOR<POSNullableScalarRelationFilter, POSWhereInput> | null
    cart?: XOR<CartNullableScalarRelationFilter, CartWhereInput> | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    store?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    locationId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    shippingMethodId?: SortOrderInput | SortOrder
    grandTotal?: SortOrder
    iscustomerAssigned?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    deliveryTrackingNumber?: SortOrder
    totalAmount?: SortOrder
    subtotalAmount?: SortOrder
    discountAmount?: SortOrderInput | SortOrder
    taxAmount?: SortOrder
    shippingFee?: SortOrder
    shippingZoneName?: SortOrderInput | SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    shippingStatus?: SortOrderInput | SortOrder
    channel?: SortOrderInput | SortOrder
    isposConfirmed?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhoneNumber?: SortOrder
    posConfirmedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    pos?: POSOrderByWithRelationInput
    cart?: CartOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    store?: OrganizationOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    customerId?: StringFilter<"Order"> | string
    locationId?: StringFilter<"Order"> | string
    createdBy?: StringNullableFilter<"Order"> | string | null
    storeId?: StringNullableFilter<"Order"> | string | null
    shippingMethodId?: StringNullableFilter<"Order"> | string | null
    grandTotal?: FloatFilter<"Order"> | number
    iscustomerAssigned?: BoolFilter<"Order"> | boolean
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"Order"> | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFilter<"Order"> | number
    totalAmount?: FloatFilter<"Order"> | number
    subtotalAmount?: FloatFilter<"Order"> | number
    discountAmount?: FloatNullableFilter<"Order"> | number | null
    taxAmount?: FloatFilter<"Order"> | number
    shippingFee?: FloatFilter<"Order"> | number
    shippingZoneName?: StringNullableFilter<"Order"> | string | null
    shippingAddress?: StringNullableFilter<"Order"> | string | null
    shippingStatus?: StringNullableFilter<"Order"> | string | null
    channel?: StringNullableFilter<"Order"> | string | null
    isposConfirmed?: BoolNullableFilter<"Order"> | boolean | null
    customerName?: StringFilter<"Order"> | string
    customerEmail?: StringFilter<"Order"> | string
    customerPhoneNumber?: StringFilter<"Order"> | string
    posConfirmedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    orderItems?: OrderItemListRelationFilter
    pos?: XOR<POSNullableScalarRelationFilter, POSWhereInput> | null
    cart?: XOR<CartNullableScalarRelationFilter, CartWhereInput> | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    store?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    locationId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    shippingMethodId?: SortOrderInput | SortOrder
    grandTotal?: SortOrder
    iscustomerAssigned?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    deliveryTrackingNumber?: SortOrder
    totalAmount?: SortOrder
    subtotalAmount?: SortOrder
    discountAmount?: SortOrderInput | SortOrder
    taxAmount?: SortOrder
    shippingFee?: SortOrder
    shippingZoneName?: SortOrderInput | SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    shippingStatus?: SortOrderInput | SortOrder
    channel?: SortOrderInput | SortOrder
    isposConfirmed?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhoneNumber?: SortOrder
    posConfirmedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    customerId?: StringWithAggregatesFilter<"Order"> | string
    locationId?: StringWithAggregatesFilter<"Order"> | string
    createdBy?: StringNullableWithAggregatesFilter<"Order"> | string | null
    storeId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippingMethodId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    grandTotal?: FloatWithAggregatesFilter<"Order"> | number
    iscustomerAssigned?: BoolWithAggregatesFilter<"Order"> | boolean
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Order"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Order"> | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntWithAggregatesFilter<"Order"> | number
    totalAmount?: FloatWithAggregatesFilter<"Order"> | number
    subtotalAmount?: FloatWithAggregatesFilter<"Order"> | number
    discountAmount?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    taxAmount?: FloatWithAggregatesFilter<"Order"> | number
    shippingFee?: FloatWithAggregatesFilter<"Order"> | number
    shippingZoneName?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippingAddress?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippingStatus?: StringNullableWithAggregatesFilter<"Order"> | string | null
    channel?: StringNullableWithAggregatesFilter<"Order"> | string | null
    isposConfirmed?: BoolNullableWithAggregatesFilter<"Order"> | boolean | null
    customerName?: StringWithAggregatesFilter<"Order"> | string
    customerEmail?: StringWithAggregatesFilter<"Order"> | string
    customerPhoneNumber?: StringWithAggregatesFilter<"Order"> | string
    posConfirmedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    orderId?: StringFilter<"OrderItem"> | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    orderId?: StringFilter<"OrderItem"> | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: FloatWithAggregatesFilter<"OrderItem"> | number
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
  }

  export type POSWhereInput = {
    AND?: POSWhereInput | POSWhereInput[]
    OR?: POSWhereInput[]
    NOT?: POSWhereInput | POSWhereInput[]
    id?: StringFilter<"POS"> | string
    staffId?: StringFilter<"POS"> | string
    orderId?: StringFilter<"POS"> | string
    customerId?: StringFilter<"POS"> | string
    terminalId?: StringFilter<"POS"> | string
    confirmed?: BoolFilter<"POS"> | boolean
    confirmedAt?: DateTimeNullableFilter<"POS"> | Date | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    staff?: XOR<UserScalarRelationFilter, UserWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type POSOrderByWithRelationInput = {
    id?: SortOrder
    staffId?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    terminalId?: SortOrder
    confirmed?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    staff?: UserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type POSWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: POSWhereInput | POSWhereInput[]
    OR?: POSWhereInput[]
    NOT?: POSWhereInput | POSWhereInput[]
    staffId?: StringFilter<"POS"> | string
    customerId?: StringFilter<"POS"> | string
    terminalId?: StringFilter<"POS"> | string
    confirmed?: BoolFilter<"POS"> | boolean
    confirmedAt?: DateTimeNullableFilter<"POS"> | Date | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    staff?: XOR<UserScalarRelationFilter, UserWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id" | "orderId">

  export type POSOrderByWithAggregationInput = {
    id?: SortOrder
    staffId?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    terminalId?: SortOrder
    confirmed?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    _count?: POSCountOrderByAggregateInput
    _max?: POSMaxOrderByAggregateInput
    _min?: POSMinOrderByAggregateInput
  }

  export type POSScalarWhereWithAggregatesInput = {
    AND?: POSScalarWhereWithAggregatesInput | POSScalarWhereWithAggregatesInput[]
    OR?: POSScalarWhereWithAggregatesInput[]
    NOT?: POSScalarWhereWithAggregatesInput | POSScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"POS"> | string
    staffId?: StringWithAggregatesFilter<"POS"> | string
    orderId?: StringWithAggregatesFilter<"POS"> | string
    customerId?: StringWithAggregatesFilter<"POS"> | string
    terminalId?: StringWithAggregatesFilter<"POS"> | string
    confirmed?: BoolWithAggregatesFilter<"POS"> | boolean
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"POS"> | Date | string | null
  }

  export type PointOfSaleWhereInput = {
    AND?: PointOfSaleWhereInput | PointOfSaleWhereInput[]
    OR?: PointOfSaleWhereInput[]
    NOT?: PointOfSaleWhereInput | PointOfSaleWhereInput[]
    id?: StringFilter<"PointOfSale"> | string
    storeId?: StringFilter<"PointOfSale"> | string
    staffAssignedId?: StringFilter<"PointOfSale"> | string
    createdAt?: DateTimeFilter<"PointOfSale"> | Date | string
    updatedAt?: DateTimeFilter<"PointOfSale"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    staffAssigned?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PointOfSaleOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    staffAssignedId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: OrganizationOrderByWithRelationInput
    staffAssigned?: UserOrderByWithRelationInput
  }

  export type PointOfSaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId?: string
    staffAssignedId?: string
    AND?: PointOfSaleWhereInput | PointOfSaleWhereInput[]
    OR?: PointOfSaleWhereInput[]
    NOT?: PointOfSaleWhereInput | PointOfSaleWhereInput[]
    createdAt?: DateTimeFilter<"PointOfSale"> | Date | string
    updatedAt?: DateTimeFilter<"PointOfSale"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    staffAssigned?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "storeId" | "staffAssignedId">

  export type PointOfSaleOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    staffAssignedId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PointOfSaleCountOrderByAggregateInput
    _max?: PointOfSaleMaxOrderByAggregateInput
    _min?: PointOfSaleMinOrderByAggregateInput
  }

  export type PointOfSaleScalarWhereWithAggregatesInput = {
    AND?: PointOfSaleScalarWhereWithAggregatesInput | PointOfSaleScalarWhereWithAggregatesInput[]
    OR?: PointOfSaleScalarWhereWithAggregatesInput[]
    NOT?: PointOfSaleScalarWhereWithAggregatesInput | PointOfSaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PointOfSale"> | string
    storeId?: StringWithAggregatesFilter<"PointOfSale"> | string
    staffAssignedId?: StringWithAggregatesFilter<"PointOfSale"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PointOfSale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PointOfSale"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    shortDescription?: StringNullableFilter<"Product"> | string | null
    description?: StringNullableFilter<"Product"> | string | null
    sku?: StringNullableFilter<"Product"> | string | null
    stock?: IntNullableFilter<"Product"> | number | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    shippingWeight?: StringNullableFilter<"Product"> | string | null
    handleTime?: StringNullableFilter<"Product"> | string | null
    freeShipping?: BoolNullableFilter<"Product"> | boolean | null
    packaging?: StringNullableFilter<"Product"> | string | null
    discountPrice?: StringNullableFilter<"Product"> | string | null
    unitSold?: StringNullableFilter<"Product"> | string | null
    length?: FloatNullableFilter<"Product"> | number | null
    width?: FloatNullableFilter<"Product"> | number | null
    height?: FloatNullableFilter<"Product"> | number | null
    productSize?: StringNullableFilter<"Product"> | string | null
    productStatus?: EnumProductStatusNullableFilter<"Product"> | $Enums.ProductStatus | null
    imageUrl?: StringNullableListFilter<"Product">
    storeId?: StringFilter<"Product"> | string
    locationId?: StringNullableFilter<"Product"> | string | null
    purchaseOrderId?: StringNullableFilter<"Product"> | string | null
    collectionId?: StringNullableFilter<"Product"> | string | null
    hasVariation?: BoolNullableFilter<"Product"> | boolean | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    warehouseId?: StringNullableFilter<"Product"> | string | null
    featuredBrands?: FeaturedBrandsListRelationFilter
    cartItems?: CartItemListRelationFilter
    productVariation?: ProductVariationListRelationFilter
    productCategory?: ProductCategoryListRelationFilter
    inventoryItems?: InventoryListRelationFilter
    collection?: XOR<ProductCollectionNullableScalarRelationFilter, ProductCollectionWhereInput> | null
    purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    price?: SortOrder
    shippingWeight?: SortOrderInput | SortOrder
    handleTime?: SortOrderInput | SortOrder
    freeShipping?: SortOrderInput | SortOrder
    packaging?: SortOrderInput | SortOrder
    discountPrice?: SortOrderInput | SortOrder
    unitSold?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    productSize?: SortOrderInput | SortOrder
    productStatus?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    storeId?: SortOrder
    locationId?: SortOrderInput | SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    collectionId?: SortOrderInput | SortOrder
    hasVariation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouseId?: SortOrderInput | SortOrder
    featuredBrands?: FeaturedBrandsOrderByRelationAggregateInput
    cartItems?: CartItemOrderByRelationAggregateInput
    productVariation?: ProductVariationOrderByRelationAggregateInput
    productCategory?: ProductCategoryOrderByRelationAggregateInput
    inventoryItems?: InventoryOrderByRelationAggregateInput
    collection?: ProductCollectionOrderByWithRelationInput
    purchase?: PurchaseOrderByWithRelationInput
    store?: OrganizationOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    shortDescription?: StringNullableFilter<"Product"> | string | null
    description?: StringNullableFilter<"Product"> | string | null
    stock?: IntNullableFilter<"Product"> | number | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    shippingWeight?: StringNullableFilter<"Product"> | string | null
    handleTime?: StringNullableFilter<"Product"> | string | null
    freeShipping?: BoolNullableFilter<"Product"> | boolean | null
    packaging?: StringNullableFilter<"Product"> | string | null
    discountPrice?: StringNullableFilter<"Product"> | string | null
    unitSold?: StringNullableFilter<"Product"> | string | null
    length?: FloatNullableFilter<"Product"> | number | null
    width?: FloatNullableFilter<"Product"> | number | null
    height?: FloatNullableFilter<"Product"> | number | null
    productSize?: StringNullableFilter<"Product"> | string | null
    productStatus?: EnumProductStatusNullableFilter<"Product"> | $Enums.ProductStatus | null
    imageUrl?: StringNullableListFilter<"Product">
    storeId?: StringFilter<"Product"> | string
    locationId?: StringNullableFilter<"Product"> | string | null
    purchaseOrderId?: StringNullableFilter<"Product"> | string | null
    collectionId?: StringNullableFilter<"Product"> | string | null
    hasVariation?: BoolNullableFilter<"Product"> | boolean | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    warehouseId?: StringNullableFilter<"Product"> | string | null
    featuredBrands?: FeaturedBrandsListRelationFilter
    cartItems?: CartItemListRelationFilter
    productVariation?: ProductVariationListRelationFilter
    productCategory?: ProductCategoryListRelationFilter
    inventoryItems?: InventoryListRelationFilter
    collection?: XOR<ProductCollectionNullableScalarRelationFilter, ProductCollectionWhereInput> | null
    purchase?: XOR<PurchaseNullableScalarRelationFilter, PurchaseWhereInput> | null
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }, "id" | "sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    price?: SortOrder
    shippingWeight?: SortOrderInput | SortOrder
    handleTime?: SortOrderInput | SortOrder
    freeShipping?: SortOrderInput | SortOrder
    packaging?: SortOrderInput | SortOrder
    discountPrice?: SortOrderInput | SortOrder
    unitSold?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    productSize?: SortOrderInput | SortOrder
    productStatus?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    storeId?: SortOrder
    locationId?: SortOrderInput | SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    collectionId?: SortOrderInput | SortOrder
    hasVariation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouseId?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    shortDescription?: StringNullableWithAggregatesFilter<"Product"> | string | null
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sku?: StringNullableWithAggregatesFilter<"Product"> | string | null
    stock?: IntNullableWithAggregatesFilter<"Product"> | number | null
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    shippingWeight?: StringNullableWithAggregatesFilter<"Product"> | string | null
    handleTime?: StringNullableWithAggregatesFilter<"Product"> | string | null
    freeShipping?: BoolNullableWithAggregatesFilter<"Product"> | boolean | null
    packaging?: StringNullableWithAggregatesFilter<"Product"> | string | null
    discountPrice?: StringNullableWithAggregatesFilter<"Product"> | string | null
    unitSold?: StringNullableWithAggregatesFilter<"Product"> | string | null
    length?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    width?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    height?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    productSize?: StringNullableWithAggregatesFilter<"Product"> | string | null
    productStatus?: EnumProductStatusNullableWithAggregatesFilter<"Product"> | $Enums.ProductStatus | null
    imageUrl?: StringNullableListFilter<"Product">
    storeId?: StringWithAggregatesFilter<"Product"> | string
    locationId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    purchaseOrderId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    collectionId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    hasVariation?: BoolNullableWithAggregatesFilter<"Product"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    warehouseId?: StringNullableWithAggregatesFilter<"Product"> | string | null
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    name?: StringNullableFilter<"ProductCategory"> | string | null
    description?: StringNullableFilter<"ProductCategory"> | string | null
    storeId?: StringFilter<"ProductCategory"> | string
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    product?: ProductListRelationFilter
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByRelationAggregateInput
    store?: OrganizationOrderByWithRelationInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    name?: StringNullableFilter<"ProductCategory"> | string | null
    description?: StringNullableFilter<"ProductCategory"> | string | null
    storeId?: StringFilter<"ProductCategory"> | string
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    product?: ProductListRelationFilter
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCategory"> | string
    name?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    description?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    storeId?: StringWithAggregatesFilter<"ProductCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
  }

  export type ProductCollectionWhereInput = {
    AND?: ProductCollectionWhereInput | ProductCollectionWhereInput[]
    OR?: ProductCollectionWhereInput[]
    NOT?: ProductCollectionWhereInput | ProductCollectionWhereInput[]
    id?: StringFilter<"ProductCollection"> | string
    name?: StringFilter<"ProductCollection"> | string
    description?: StringNullableFilter<"ProductCollection"> | string | null
    createdAt?: DateTimeFilter<"ProductCollection"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCollection"> | Date | string
    products?: ProductListRelationFilter
  }

  export type ProductCollectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type ProductCollectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductCollectionWhereInput | ProductCollectionWhereInput[]
    OR?: ProductCollectionWhereInput[]
    NOT?: ProductCollectionWhereInput | ProductCollectionWhereInput[]
    name?: StringFilter<"ProductCollection"> | string
    description?: StringNullableFilter<"ProductCollection"> | string | null
    createdAt?: DateTimeFilter<"ProductCollection"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCollection"> | Date | string
    products?: ProductListRelationFilter
  }, "id">

  export type ProductCollectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCollectionCountOrderByAggregateInput
    _max?: ProductCollectionMaxOrderByAggregateInput
    _min?: ProductCollectionMinOrderByAggregateInput
  }

  export type ProductCollectionScalarWhereWithAggregatesInput = {
    AND?: ProductCollectionScalarWhereWithAggregatesInput | ProductCollectionScalarWhereWithAggregatesInput[]
    OR?: ProductCollectionScalarWhereWithAggregatesInput[]
    NOT?: ProductCollectionScalarWhereWithAggregatesInput | ProductCollectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCollection"> | string
    name?: StringWithAggregatesFilter<"ProductCollection"> | string
    description?: StringNullableWithAggregatesFilter<"ProductCollection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductCollection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductCollection"> | Date | string
  }

  export type ProductVariationWhereInput = {
    AND?: ProductVariationWhereInput | ProductVariationWhereInput[]
    OR?: ProductVariationWhereInput[]
    NOT?: ProductVariationWhereInput | ProductVariationWhereInput[]
    id?: StringFilter<"ProductVariation"> | string
    productId?: StringFilter<"ProductVariation"> | string
    sku?: StringFilter<"ProductVariation"> | string
    price?: FloatFilter<"ProductVariation"> | number
    cost?: FloatNullableFilter<"ProductVariation"> | number | null
    discountPrice?: FloatNullableFilter<"ProductVariation"> | number | null
    stock?: IntFilter<"ProductVariation"> | number
    imageUrl?: StringNullableFilter<"ProductVariation"> | string | null
    createdAt?: DateTimeFilter<"ProductVariation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariation"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    options?: ProductVariationOptionListRelationFilter
  }

  export type ProductVariationOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    cost?: SortOrderInput | SortOrder
    discountPrice?: SortOrderInput | SortOrder
    stock?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    options?: ProductVariationOptionOrderByRelationAggregateInput
  }

  export type ProductVariationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ProductVariationWhereInput | ProductVariationWhereInput[]
    OR?: ProductVariationWhereInput[]
    NOT?: ProductVariationWhereInput | ProductVariationWhereInput[]
    productId?: StringFilter<"ProductVariation"> | string
    price?: FloatFilter<"ProductVariation"> | number
    cost?: FloatNullableFilter<"ProductVariation"> | number | null
    discountPrice?: FloatNullableFilter<"ProductVariation"> | number | null
    stock?: IntFilter<"ProductVariation"> | number
    imageUrl?: StringNullableFilter<"ProductVariation"> | string | null
    createdAt?: DateTimeFilter<"ProductVariation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariation"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    options?: ProductVariationOptionListRelationFilter
  }, "id" | "sku">

  export type ProductVariationOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    cost?: SortOrderInput | SortOrder
    discountPrice?: SortOrderInput | SortOrder
    stock?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVariationCountOrderByAggregateInput
    _avg?: ProductVariationAvgOrderByAggregateInput
    _max?: ProductVariationMaxOrderByAggregateInput
    _min?: ProductVariationMinOrderByAggregateInput
    _sum?: ProductVariationSumOrderByAggregateInput
  }

  export type ProductVariationScalarWhereWithAggregatesInput = {
    AND?: ProductVariationScalarWhereWithAggregatesInput | ProductVariationScalarWhereWithAggregatesInput[]
    OR?: ProductVariationScalarWhereWithAggregatesInput[]
    NOT?: ProductVariationScalarWhereWithAggregatesInput | ProductVariationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductVariation"> | string
    productId?: StringWithAggregatesFilter<"ProductVariation"> | string
    sku?: StringWithAggregatesFilter<"ProductVariation"> | string
    price?: FloatWithAggregatesFilter<"ProductVariation"> | number
    cost?: FloatNullableWithAggregatesFilter<"ProductVariation"> | number | null
    discountPrice?: FloatNullableWithAggregatesFilter<"ProductVariation"> | number | null
    stock?: IntWithAggregatesFilter<"ProductVariation"> | number
    imageUrl?: StringNullableWithAggregatesFilter<"ProductVariation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariation"> | Date | string
  }

  export type ProductVariantWhereInput = {
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    name?: StringFilter<"ProductVariant"> | string
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    values?: ProductVariantValueListRelationFilter
  }

  export type ProductVariantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    values?: ProductVariantValueOrderByRelationAggregateInput
  }

  export type ProductVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    name?: StringFilter<"ProductVariant"> | string
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    values?: ProductVariantValueListRelationFilter
  }, "id">

  export type ProductVariantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVariantCountOrderByAggregateInput
    _max?: ProductVariantMaxOrderByAggregateInput
    _min?: ProductVariantMinOrderByAggregateInput
  }

  export type ProductVariantScalarWhereWithAggregatesInput = {
    AND?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    OR?: ProductVariantScalarWhereWithAggregatesInput[]
    NOT?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductVariant"> | string
    name?: StringWithAggregatesFilter<"ProductVariant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
  }

  export type ProductVariantValueWhereInput = {
    AND?: ProductVariantValueWhereInput | ProductVariantValueWhereInput[]
    OR?: ProductVariantValueWhereInput[]
    NOT?: ProductVariantValueWhereInput | ProductVariantValueWhereInput[]
    id?: StringFilter<"ProductVariantValue"> | string
    variantId?: StringFilter<"ProductVariantValue"> | string
    value?: StringFilter<"ProductVariantValue"> | string
    createdAt?: DateTimeFilter<"ProductVariantValue"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariantValue"> | Date | string
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
    options?: ProductVariationOptionListRelationFilter
  }

  export type ProductVariantValueOrderByWithRelationInput = {
    id?: SortOrder
    variantId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variant?: ProductVariantOrderByWithRelationInput
    options?: ProductVariationOptionOrderByRelationAggregateInput
  }

  export type ProductVariantValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductVariantValueWhereInput | ProductVariantValueWhereInput[]
    OR?: ProductVariantValueWhereInput[]
    NOT?: ProductVariantValueWhereInput | ProductVariantValueWhereInput[]
    variantId?: StringFilter<"ProductVariantValue"> | string
    value?: StringFilter<"ProductVariantValue"> | string
    createdAt?: DateTimeFilter<"ProductVariantValue"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariantValue"> | Date | string
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
    options?: ProductVariationOptionListRelationFilter
  }, "id">

  export type ProductVariantValueOrderByWithAggregationInput = {
    id?: SortOrder
    variantId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVariantValueCountOrderByAggregateInput
    _max?: ProductVariantValueMaxOrderByAggregateInput
    _min?: ProductVariantValueMinOrderByAggregateInput
  }

  export type ProductVariantValueScalarWhereWithAggregatesInput = {
    AND?: ProductVariantValueScalarWhereWithAggregatesInput | ProductVariantValueScalarWhereWithAggregatesInput[]
    OR?: ProductVariantValueScalarWhereWithAggregatesInput[]
    NOT?: ProductVariantValueScalarWhereWithAggregatesInput | ProductVariantValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductVariantValue"> | string
    variantId?: StringWithAggregatesFilter<"ProductVariantValue"> | string
    value?: StringWithAggregatesFilter<"ProductVariantValue"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariantValue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariantValue"> | Date | string
  }

  export type ProductVariationOptionWhereInput = {
    AND?: ProductVariationOptionWhereInput | ProductVariationOptionWhereInput[]
    OR?: ProductVariationOptionWhereInput[]
    NOT?: ProductVariationOptionWhereInput | ProductVariationOptionWhereInput[]
    id?: StringFilter<"ProductVariationOption"> | string
    variationId?: StringFilter<"ProductVariationOption"> | string
    valueId?: StringFilter<"ProductVariationOption"> | string
    createdAt?: DateTimeFilter<"ProductVariationOption"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariationOption"> | Date | string
    variation?: XOR<ProductVariationScalarRelationFilter, ProductVariationWhereInput>
    value?: XOR<ProductVariantValueScalarRelationFilter, ProductVariantValueWhereInput>
  }

  export type ProductVariationOptionOrderByWithRelationInput = {
    id?: SortOrder
    variationId?: SortOrder
    valueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variation?: ProductVariationOrderByWithRelationInput
    value?: ProductVariantValueOrderByWithRelationInput
  }

  export type ProductVariationOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    variationId_valueId?: ProductVariationOptionVariationIdValueIdCompoundUniqueInput
    AND?: ProductVariationOptionWhereInput | ProductVariationOptionWhereInput[]
    OR?: ProductVariationOptionWhereInput[]
    NOT?: ProductVariationOptionWhereInput | ProductVariationOptionWhereInput[]
    variationId?: StringFilter<"ProductVariationOption"> | string
    valueId?: StringFilter<"ProductVariationOption"> | string
    createdAt?: DateTimeFilter<"ProductVariationOption"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariationOption"> | Date | string
    variation?: XOR<ProductVariationScalarRelationFilter, ProductVariationWhereInput>
    value?: XOR<ProductVariantValueScalarRelationFilter, ProductVariantValueWhereInput>
  }, "id" | "variationId_valueId">

  export type ProductVariationOptionOrderByWithAggregationInput = {
    id?: SortOrder
    variationId?: SortOrder
    valueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVariationOptionCountOrderByAggregateInput
    _max?: ProductVariationOptionMaxOrderByAggregateInput
    _min?: ProductVariationOptionMinOrderByAggregateInput
  }

  export type ProductVariationOptionScalarWhereWithAggregatesInput = {
    AND?: ProductVariationOptionScalarWhereWithAggregatesInput | ProductVariationOptionScalarWhereWithAggregatesInput[]
    OR?: ProductVariationOptionScalarWhereWithAggregatesInput[]
    NOT?: ProductVariationOptionScalarWhereWithAggregatesInput | ProductVariationOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductVariationOption"> | string
    variationId?: StringWithAggregatesFilter<"ProductVariationOption"> | string
    valueId?: StringWithAggregatesFilter<"ProductVariationOption"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariationOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariationOption"> | Date | string
  }

  export type FeaturedBrandsWhereInput = {
    AND?: FeaturedBrandsWhereInput | FeaturedBrandsWhereInput[]
    OR?: FeaturedBrandsWhereInput[]
    NOT?: FeaturedBrandsWhereInput | FeaturedBrandsWhereInput[]
    id?: StringFilter<"FeaturedBrands"> | string
    name?: StringFilter<"FeaturedBrands"> | string
    productId?: StringFilter<"FeaturedBrands"> | string
    createdAt?: DateTimeFilter<"FeaturedBrands"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedBrands"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type FeaturedBrandsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type FeaturedBrandsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeaturedBrandsWhereInput | FeaturedBrandsWhereInput[]
    OR?: FeaturedBrandsWhereInput[]
    NOT?: FeaturedBrandsWhereInput | FeaturedBrandsWhereInput[]
    name?: StringFilter<"FeaturedBrands"> | string
    productId?: StringFilter<"FeaturedBrands"> | string
    createdAt?: DateTimeFilter<"FeaturedBrands"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedBrands"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type FeaturedBrandsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeaturedBrandsCountOrderByAggregateInput
    _max?: FeaturedBrandsMaxOrderByAggregateInput
    _min?: FeaturedBrandsMinOrderByAggregateInput
  }

  export type FeaturedBrandsScalarWhereWithAggregatesInput = {
    AND?: FeaturedBrandsScalarWhereWithAggregatesInput | FeaturedBrandsScalarWhereWithAggregatesInput[]
    OR?: FeaturedBrandsScalarWhereWithAggregatesInput[]
    NOT?: FeaturedBrandsScalarWhereWithAggregatesInput | FeaturedBrandsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeaturedBrands"> | string
    name?: StringWithAggregatesFilter<"FeaturedBrands"> | string
    productId?: StringWithAggregatesFilter<"FeaturedBrands"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeaturedBrands"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeaturedBrands"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    supplierName?: StringFilter<"Supplier"> | string
    email?: StringFilter<"Supplier"> | string
    phoneNumber?: StringFilter<"Supplier"> | string
    personOfSupplier?: StringFilter<"Supplier"> | string
    location?: StringFilter<"Supplier"> | string
    storeId?: StringFilter<"Supplier"> | string
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    purchase?: PurchaseListRelationFilter
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    supplierName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    personOfSupplier?: SortOrder
    location?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchase?: PurchaseOrderByRelationAggregateInput
    store?: OrganizationOrderByWithRelationInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    supplierName?: StringFilter<"Supplier"> | string
    email?: StringFilter<"Supplier"> | string
    phoneNumber?: StringFilter<"Supplier"> | string
    personOfSupplier?: StringFilter<"Supplier"> | string
    location?: StringFilter<"Supplier"> | string
    storeId?: StringFilter<"Supplier"> | string
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    purchase?: PurchaseListRelationFilter
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    supplierName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    personOfSupplier?: SortOrder
    location?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    supplierName?: StringWithAggregatesFilter<"Supplier"> | string
    email?: StringWithAggregatesFilter<"Supplier"> | string
    phoneNumber?: StringWithAggregatesFilter<"Supplier"> | string
    personOfSupplier?: StringWithAggregatesFilter<"Supplier"> | string
    location?: StringWithAggregatesFilter<"Supplier"> | string
    storeId?: StringWithAggregatesFilter<"Supplier"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    status?: StringFilter<"Purchase"> | string
    downloadUrl?: StringFilter<"Purchase"> | string
    toalCost?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    storeSupplierId?: StringFilter<"Purchase"> | string
    storeId?: StringFilter<"Purchase"> | string
    deliveryDate?: DateTimeFilter<"Purchase"> | Date | string
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    storeSupplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    products?: ProductListRelationFilter
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrder
    toalCost?: SortOrder
    storeSupplierId?: SortOrder
    storeId?: SortOrder
    deliveryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeSupplier?: SupplierOrderByWithRelationInput
    store?: OrganizationOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    status?: StringFilter<"Purchase"> | string
    downloadUrl?: StringFilter<"Purchase"> | string
    toalCost?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    storeSupplierId?: StringFilter<"Purchase"> | string
    storeId?: StringFilter<"Purchase"> | string
    deliveryDate?: DateTimeFilter<"Purchase"> | Date | string
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    storeSupplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    products?: ProductListRelationFilter
  }, "id">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrder
    toalCost?: SortOrder
    storeSupplierId?: SortOrder
    storeId?: SortOrder
    deliveryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    status?: StringWithAggregatesFilter<"Purchase"> | string
    downloadUrl?: StringWithAggregatesFilter<"Purchase"> | string
    toalCost?: DecimalWithAggregatesFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    storeSupplierId?: StringWithAggregatesFilter<"Purchase"> | string
    storeId?: StringWithAggregatesFilter<"Purchase"> | string
    deliveryDate?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    middleName?: StringNullableFilter<"User"> | string | null
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    image?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    locationId?: StringNullableFilter<"User"> | string | null
    members?: MemberListRelationFilter
    invitations?: InvitationListRelationFilter
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    PointOfSale?: XOR<PointOfSaleNullableScalarRelationFilter, PointOfSaleWhereInput> | null
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    POS?: POSListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrderInput | SortOrder
    members?: MemberOrderByRelationAggregateInput
    invitations?: InvitationOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    location?: LocationOrderByWithRelationInput
    PointOfSale?: PointOfSaleOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    POS?: POSOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    middleName?: StringNullableFilter<"User"> | string | null
    lastName?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    image?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    locationId?: StringNullableFilter<"User"> | string | null
    members?: MemberListRelationFilter
    invitations?: InvitationListRelationFilter
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    PointOfSale?: XOR<PointOfSaleNullableScalarRelationFilter, PointOfSaleWhereInput> | null
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    POS?: POSListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringWithAggregatesFilter<"User"> | string
    middleName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringNullableWithAggregatesFilter<"User"> | string | null
    banned?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    banReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    banExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    locationId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
    activeOrganizationId?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrderInput | SortOrder
    activeOrganizationId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
    activeOrganizationId?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrderInput | SortOrder
    activeOrganizationId?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
    impersonatedBy?: StringNullableWithAggregatesFilter<"Session"> | string | null
    activeOrganizationId?: StringNullableWithAggregatesFilter<"Session"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    slug?: StringNullableFilter<"Organization"> | string | null
    logo?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    metadata?: StringNullableFilter<"Organization"> | string | null
    businessName?: StringNullableFilter<"Organization"> | string | null
    businessType?: StringNullableFilter<"Organization"> | string | null
    storeBaseCurrency?: StringNullableFilter<"Organization"> | string | null
    banner?: StringNullableFilter<"Organization"> | string | null
    phoneNumber?: StringNullableFilter<"Organization"> | string | null
    email?: StringNullableFilter<"Organization"> | string | null
    website?: StringNullableFilter<"Organization"> | string | null
    description?: StringNullableFilter<"Organization"> | string | null
    country?: StringNullableFilter<"Organization"> | string | null
    address?: StringNullableFilter<"Organization"> | string | null
    state?: StringNullableFilter<"Organization"> | string | null
    region?: StringNullableFilter<"Organization"> | string | null
    zipCode?: StringNullableFilter<"Organization"> | string | null
    city?: StringNullableFilter<"Organization"> | string | null
    status?: StringNullableFilter<"Organization"> | string | null
    storeTag?: StringNullableFilter<"Organization"> | string | null
    whitelabel?: StringNullableFilter<"Organization"> | string | null
    facebook?: StringNullableFilter<"Organization"> | string | null
    instagram?: StringNullableFilter<"Organization"> | string | null
    tiktok?: StringNullableFilter<"Organization"> | string | null
    twitter?: StringNullableFilter<"Organization"> | string | null
    linkedin?: StringNullableFilter<"Organization"> | string | null
    currency?: StringNullableFilter<"Organization"> | string | null
    storeUrl?: StringNullableFilter<"Organization"> | string | null
    storeApproval?: BoolNullableFilter<"Organization"> | boolean | null
    modifyProductState?: BoolNullableFilter<"Organization"> | boolean | null
    members?: MemberListRelationFilter
    invitations?: InvitationListRelationFilter
    bankDetails?: XOR<BankDetailsNullableScalarRelationFilter, BankDetailsWhereInput> | null
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    location?: LocationListRelationFilter
    order?: OrderListRelationFilter
    customer?: CustomerListRelationFilter
    customerGroups?: CustomerGroupsListRelationFilter
    expense?: ExpenseListRelationFilter
    invoice?: InvoiceListRelationFilter
    pointOfSale?: XOR<PointOfSaleNullableScalarRelationFilter, PointOfSaleWhereInput> | null
    product?: ProductListRelationFilter
    supplier?: SupplierListRelationFilter
    purchase?: PurchaseListRelationFilter
    settlements?: SettlementListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    transaction?: TransactionListRelationFilter
    warehouse?: WarehouseListRelationFilter
    ShippingMethod?: ShippingMethodListRelationFilter
    ShippingZone?: ShippingZoneListRelationFilter
    productCategory?: ProductCategoryListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    businessType?: SortOrderInput | SortOrder
    storeBaseCurrency?: SortOrderInput | SortOrder
    banner?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    storeTag?: SortOrderInput | SortOrder
    whitelabel?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    tiktok?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    storeUrl?: SortOrderInput | SortOrder
    storeApproval?: SortOrderInput | SortOrder
    modifyProductState?: SortOrderInput | SortOrder
    members?: MemberOrderByRelationAggregateInput
    invitations?: InvitationOrderByRelationAggregateInput
    bankDetails?: BankDetailsOrderByWithRelationInput
    wallet?: WalletOrderByWithRelationInput
    location?: LocationOrderByRelationAggregateInput
    order?: OrderOrderByRelationAggregateInput
    customer?: CustomerOrderByRelationAggregateInput
    customerGroups?: CustomerGroupsOrderByRelationAggregateInput
    expense?: ExpenseOrderByRelationAggregateInput
    invoice?: InvoiceOrderByRelationAggregateInput
    pointOfSale?: PointOfSaleOrderByWithRelationInput
    product?: ProductOrderByRelationAggregateInput
    supplier?: SupplierOrderByRelationAggregateInput
    purchase?: PurchaseOrderByRelationAggregateInput
    settlements?: SettlementOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    transaction?: TransactionOrderByRelationAggregateInput
    warehouse?: WarehouseOrderByRelationAggregateInput
    ShippingMethod?: ShippingMethodOrderByRelationAggregateInput
    ShippingZone?: ShippingZoneOrderByRelationAggregateInput
    productCategory?: ProductCategoryOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    logo?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    metadata?: StringNullableFilter<"Organization"> | string | null
    businessName?: StringNullableFilter<"Organization"> | string | null
    businessType?: StringNullableFilter<"Organization"> | string | null
    storeBaseCurrency?: StringNullableFilter<"Organization"> | string | null
    banner?: StringNullableFilter<"Organization"> | string | null
    phoneNumber?: StringNullableFilter<"Organization"> | string | null
    email?: StringNullableFilter<"Organization"> | string | null
    website?: StringNullableFilter<"Organization"> | string | null
    description?: StringNullableFilter<"Organization"> | string | null
    country?: StringNullableFilter<"Organization"> | string | null
    address?: StringNullableFilter<"Organization"> | string | null
    state?: StringNullableFilter<"Organization"> | string | null
    region?: StringNullableFilter<"Organization"> | string | null
    zipCode?: StringNullableFilter<"Organization"> | string | null
    city?: StringNullableFilter<"Organization"> | string | null
    status?: StringNullableFilter<"Organization"> | string | null
    storeTag?: StringNullableFilter<"Organization"> | string | null
    whitelabel?: StringNullableFilter<"Organization"> | string | null
    facebook?: StringNullableFilter<"Organization"> | string | null
    instagram?: StringNullableFilter<"Organization"> | string | null
    tiktok?: StringNullableFilter<"Organization"> | string | null
    twitter?: StringNullableFilter<"Organization"> | string | null
    linkedin?: StringNullableFilter<"Organization"> | string | null
    currency?: StringNullableFilter<"Organization"> | string | null
    storeUrl?: StringNullableFilter<"Organization"> | string | null
    storeApproval?: BoolNullableFilter<"Organization"> | boolean | null
    modifyProductState?: BoolNullableFilter<"Organization"> | boolean | null
    members?: MemberListRelationFilter
    invitations?: InvitationListRelationFilter
    bankDetails?: XOR<BankDetailsNullableScalarRelationFilter, BankDetailsWhereInput> | null
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    location?: LocationListRelationFilter
    order?: OrderListRelationFilter
    customer?: CustomerListRelationFilter
    customerGroups?: CustomerGroupsListRelationFilter
    expense?: ExpenseListRelationFilter
    invoice?: InvoiceListRelationFilter
    pointOfSale?: XOR<PointOfSaleNullableScalarRelationFilter, PointOfSaleWhereInput> | null
    product?: ProductListRelationFilter
    supplier?: SupplierListRelationFilter
    purchase?: PurchaseListRelationFilter
    settlements?: SettlementListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    transaction?: TransactionListRelationFilter
    warehouse?: WarehouseListRelationFilter
    ShippingMethod?: ShippingMethodListRelationFilter
    ShippingZone?: ShippingZoneListRelationFilter
    productCategory?: ProductCategoryListRelationFilter
  }, "id" | "slug">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    businessType?: SortOrderInput | SortOrder
    storeBaseCurrency?: SortOrderInput | SortOrder
    banner?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    storeTag?: SortOrderInput | SortOrder
    whitelabel?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    tiktok?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    storeUrl?: SortOrderInput | SortOrder
    storeApproval?: SortOrderInput | SortOrder
    modifyProductState?: SortOrderInput | SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    metadata?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    businessName?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    businessType?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    storeBaseCurrency?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    banner?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    email?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    website?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    description?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    country?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    address?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    state?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    region?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    city?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    status?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    storeTag?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    whitelabel?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    tiktok?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    linkedin?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    currency?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    storeUrl?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    storeApproval?: BoolNullableWithAggregatesFilter<"Organization"> | boolean | null
    modifyProductState?: BoolNullableWithAggregatesFilter<"Organization"> | boolean | null
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: StringFilter<"Member"> | string
    organizationId?: StringFilter<"Member"> | string
    userId?: StringFilter<"Member"> | string
    role?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    organizationId?: StringFilter<"Member"> | string
    userId?: StringFilter<"Member"> | string
    role?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Member"> | string
    organizationId?: StringWithAggregatesFilter<"Member"> | string
    userId?: StringWithAggregatesFilter<"Member"> | string
    role?: StringWithAggregatesFilter<"Member"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    id?: StringFilter<"Invitation"> | string
    organizationId?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    role?: StringNullableFilter<"Invitation"> | string | null
    status?: StringFilter<"Invitation"> | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    inviterId?: StringFilter<"Invitation"> | string
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    updatedAt?: DateTimeFilter<"Invitation"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    organizationId?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    role?: StringNullableFilter<"Invitation"> | string | null
    status?: StringFilter<"Invitation"> | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    inviterId?: StringFilter<"Invitation"> | string
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    updatedAt?: DateTimeFilter<"Invitation"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitation"> | string
    organizationId?: StringWithAggregatesFilter<"Invitation"> | string
    email?: StringWithAggregatesFilter<"Invitation"> | string
    role?: StringNullableWithAggregatesFilter<"Invitation"> | string | null
    status?: StringWithAggregatesFilter<"Invitation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    inviterId?: StringWithAggregatesFilter<"Invitation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
  }

  export type SettlementWhereInput = {
    AND?: SettlementWhereInput | SettlementWhereInput[]
    OR?: SettlementWhereInput[]
    NOT?: SettlementWhereInput | SettlementWhereInput[]
    id?: StringFilter<"Settlement"> | string
    amount?: DecimalFilter<"Settlement"> | Decimal | DecimalJsLike | number | string
    storeId?: StringFilter<"Settlement"> | string
    createdAt?: DateTimeFilter<"Settlement"> | Date | string
    updatedAt?: DateTimeFilter<"Settlement"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type SettlementOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: OrganizationOrderByWithRelationInput
  }

  export type SettlementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettlementWhereInput | SettlementWhereInput[]
    OR?: SettlementWhereInput[]
    NOT?: SettlementWhereInput | SettlementWhereInput[]
    amount?: DecimalFilter<"Settlement"> | Decimal | DecimalJsLike | number | string
    storeId?: StringFilter<"Settlement"> | string
    createdAt?: DateTimeFilter<"Settlement"> | Date | string
    updatedAt?: DateTimeFilter<"Settlement"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type SettlementOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettlementCountOrderByAggregateInput
    _avg?: SettlementAvgOrderByAggregateInput
    _max?: SettlementMaxOrderByAggregateInput
    _min?: SettlementMinOrderByAggregateInput
    _sum?: SettlementSumOrderByAggregateInput
  }

  export type SettlementScalarWhereWithAggregatesInput = {
    AND?: SettlementScalarWhereWithAggregatesInput | SettlementScalarWhereWithAggregatesInput[]
    OR?: SettlementScalarWhereWithAggregatesInput[]
    NOT?: SettlementScalarWhereWithAggregatesInput | SettlementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Settlement"> | string
    amount?: DecimalWithAggregatesFilter<"Settlement"> | Decimal | DecimalJsLike | number | string
    storeId?: StringWithAggregatesFilter<"Settlement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Settlement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Settlement"> | Date | string
  }

  export type ShippingWhereInput = {
    AND?: ShippingWhereInput | ShippingWhereInput[]
    OR?: ShippingWhereInput[]
    NOT?: ShippingWhereInput | ShippingWhereInput[]
    id?: StringFilter<"Shipping"> | string
    orderId?: StringFilter<"Shipping"> | string
    shippingMethodId?: StringFilter<"Shipping"> | string
    trackingNumber?: StringNullableFilter<"Shipping"> | string | null
    carrier?: StringNullableFilter<"Shipping"> | string | null
    status?: EnumShippingStatusFilter<"Shipping"> | $Enums.ShippingStatus
    estimatedDelivery?: DateTimeNullableFilter<"Shipping"> | Date | string | null
    actualDelivery?: DateTimeNullableFilter<"Shipping"> | Date | string | null
    shippingAddress?: StringFilter<"Shipping"> | string
    shippingZoneName?: StringNullableFilter<"Shipping"> | string | null
    shippingFee?: DecimalFilter<"Shipping"> | Decimal | DecimalJsLike | number | string
    weight?: FloatNullableFilter<"Shipping"> | number | null
    dimensions?: StringNullableFilter<"Shipping"> | string | null
    notes?: StringNullableFilter<"Shipping"> | string | null
    createdAt?: DateTimeFilter<"Shipping"> | Date | string
    updatedAt?: DateTimeFilter<"Shipping"> | Date | string
    shippingMethod?: XOR<ShippingMethodScalarRelationFilter, ShippingMethodWhereInput>
    auditLogs?: ShippingAuditListRelationFilter
  }

  export type ShippingOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    shippingMethodId?: SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    status?: SortOrder
    estimatedDelivery?: SortOrderInput | SortOrder
    actualDelivery?: SortOrderInput | SortOrder
    shippingAddress?: SortOrder
    shippingZoneName?: SortOrderInput | SortOrder
    shippingFee?: SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shippingMethod?: ShippingMethodOrderByWithRelationInput
    auditLogs?: ShippingAuditOrderByRelationAggregateInput
  }

  export type ShippingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShippingWhereInput | ShippingWhereInput[]
    OR?: ShippingWhereInput[]
    NOT?: ShippingWhereInput | ShippingWhereInput[]
    orderId?: StringFilter<"Shipping"> | string
    shippingMethodId?: StringFilter<"Shipping"> | string
    trackingNumber?: StringNullableFilter<"Shipping"> | string | null
    carrier?: StringNullableFilter<"Shipping"> | string | null
    status?: EnumShippingStatusFilter<"Shipping"> | $Enums.ShippingStatus
    estimatedDelivery?: DateTimeNullableFilter<"Shipping"> | Date | string | null
    actualDelivery?: DateTimeNullableFilter<"Shipping"> | Date | string | null
    shippingAddress?: StringFilter<"Shipping"> | string
    shippingZoneName?: StringNullableFilter<"Shipping"> | string | null
    shippingFee?: DecimalFilter<"Shipping"> | Decimal | DecimalJsLike | number | string
    weight?: FloatNullableFilter<"Shipping"> | number | null
    dimensions?: StringNullableFilter<"Shipping"> | string | null
    notes?: StringNullableFilter<"Shipping"> | string | null
    createdAt?: DateTimeFilter<"Shipping"> | Date | string
    updatedAt?: DateTimeFilter<"Shipping"> | Date | string
    shippingMethod?: XOR<ShippingMethodScalarRelationFilter, ShippingMethodWhereInput>
    auditLogs?: ShippingAuditListRelationFilter
  }, "id">

  export type ShippingOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    shippingMethodId?: SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    status?: SortOrder
    estimatedDelivery?: SortOrderInput | SortOrder
    actualDelivery?: SortOrderInput | SortOrder
    shippingAddress?: SortOrder
    shippingZoneName?: SortOrderInput | SortOrder
    shippingFee?: SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShippingCountOrderByAggregateInput
    _avg?: ShippingAvgOrderByAggregateInput
    _max?: ShippingMaxOrderByAggregateInput
    _min?: ShippingMinOrderByAggregateInput
    _sum?: ShippingSumOrderByAggregateInput
  }

  export type ShippingScalarWhereWithAggregatesInput = {
    AND?: ShippingScalarWhereWithAggregatesInput | ShippingScalarWhereWithAggregatesInput[]
    OR?: ShippingScalarWhereWithAggregatesInput[]
    NOT?: ShippingScalarWhereWithAggregatesInput | ShippingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shipping"> | string
    orderId?: StringWithAggregatesFilter<"Shipping"> | string
    shippingMethodId?: StringWithAggregatesFilter<"Shipping"> | string
    trackingNumber?: StringNullableWithAggregatesFilter<"Shipping"> | string | null
    carrier?: StringNullableWithAggregatesFilter<"Shipping"> | string | null
    status?: EnumShippingStatusWithAggregatesFilter<"Shipping"> | $Enums.ShippingStatus
    estimatedDelivery?: DateTimeNullableWithAggregatesFilter<"Shipping"> | Date | string | null
    actualDelivery?: DateTimeNullableWithAggregatesFilter<"Shipping"> | Date | string | null
    shippingAddress?: StringWithAggregatesFilter<"Shipping"> | string
    shippingZoneName?: StringNullableWithAggregatesFilter<"Shipping"> | string | null
    shippingFee?: DecimalWithAggregatesFilter<"Shipping"> | Decimal | DecimalJsLike | number | string
    weight?: FloatNullableWithAggregatesFilter<"Shipping"> | number | null
    dimensions?: StringNullableWithAggregatesFilter<"Shipping"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Shipping"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Shipping"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shipping"> | Date | string
  }

  export type ShippingMethodWhereInput = {
    AND?: ShippingMethodWhereInput | ShippingMethodWhereInput[]
    OR?: ShippingMethodWhereInput[]
    NOT?: ShippingMethodWhereInput | ShippingMethodWhereInput[]
    id?: StringFilter<"ShippingMethod"> | string
    name?: StringFilter<"ShippingMethod"> | string
    storeId?: StringFilter<"ShippingMethod"> | string
    description?: StringNullableFilter<"ShippingMethod"> | string | null
    carrier?: StringNullableFilter<"ShippingMethod"> | string | null
    deliveryTime?: StringFilter<"ShippingMethod"> | string
    baseCost?: FloatFilter<"ShippingMethod"> | number
    costCalculation?: StringNullableFilter<"ShippingMethod"> | string | null
    isActive?: BoolFilter<"ShippingMethod"> | boolean
    createdAt?: DateTimeFilter<"ShippingMethod"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingMethod"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    shippingZones?: ShippingZoneListRelationFilter
    Shipping?: ShippingListRelationFilter
  }

  export type ShippingMethodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    description?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    deliveryTime?: SortOrder
    baseCost?: SortOrder
    costCalculation?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: OrganizationOrderByWithRelationInput
    shippingZones?: ShippingZoneOrderByRelationAggregateInput
    Shipping?: ShippingOrderByRelationAggregateInput
  }

  export type ShippingMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShippingMethodWhereInput | ShippingMethodWhereInput[]
    OR?: ShippingMethodWhereInput[]
    NOT?: ShippingMethodWhereInput | ShippingMethodWhereInput[]
    name?: StringFilter<"ShippingMethod"> | string
    storeId?: StringFilter<"ShippingMethod"> | string
    description?: StringNullableFilter<"ShippingMethod"> | string | null
    carrier?: StringNullableFilter<"ShippingMethod"> | string | null
    deliveryTime?: StringFilter<"ShippingMethod"> | string
    baseCost?: FloatFilter<"ShippingMethod"> | number
    costCalculation?: StringNullableFilter<"ShippingMethod"> | string | null
    isActive?: BoolFilter<"ShippingMethod"> | boolean
    createdAt?: DateTimeFilter<"ShippingMethod"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingMethod"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    shippingZones?: ShippingZoneListRelationFilter
    Shipping?: ShippingListRelationFilter
  }, "id">

  export type ShippingMethodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    description?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    deliveryTime?: SortOrder
    baseCost?: SortOrder
    costCalculation?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShippingMethodCountOrderByAggregateInput
    _avg?: ShippingMethodAvgOrderByAggregateInput
    _max?: ShippingMethodMaxOrderByAggregateInput
    _min?: ShippingMethodMinOrderByAggregateInput
    _sum?: ShippingMethodSumOrderByAggregateInput
  }

  export type ShippingMethodScalarWhereWithAggregatesInput = {
    AND?: ShippingMethodScalarWhereWithAggregatesInput | ShippingMethodScalarWhereWithAggregatesInput[]
    OR?: ShippingMethodScalarWhereWithAggregatesInput[]
    NOT?: ShippingMethodScalarWhereWithAggregatesInput | ShippingMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShippingMethod"> | string
    name?: StringWithAggregatesFilter<"ShippingMethod"> | string
    storeId?: StringWithAggregatesFilter<"ShippingMethod"> | string
    description?: StringNullableWithAggregatesFilter<"ShippingMethod"> | string | null
    carrier?: StringNullableWithAggregatesFilter<"ShippingMethod"> | string | null
    deliveryTime?: StringWithAggregatesFilter<"ShippingMethod"> | string
    baseCost?: FloatWithAggregatesFilter<"ShippingMethod"> | number
    costCalculation?: StringNullableWithAggregatesFilter<"ShippingMethod"> | string | null
    isActive?: BoolWithAggregatesFilter<"ShippingMethod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ShippingMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShippingMethod"> | Date | string
  }

  export type ShippingZoneWhereInput = {
    AND?: ShippingZoneWhereInput | ShippingZoneWhereInput[]
    OR?: ShippingZoneWhereInput[]
    NOT?: ShippingZoneWhereInput | ShippingZoneWhereInput[]
    id?: StringFilter<"ShippingZone"> | string
    name?: StringFilter<"ShippingZone"> | string
    storeId?: StringFilter<"ShippingZone"> | string
    countries?: StringNullableListFilter<"ShippingZone">
    regions?: StringNullableListFilter<"ShippingZone">
    postalCodes?: StringNullableListFilter<"ShippingZone">
    createdAt?: DateTimeFilter<"ShippingZone"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingZone"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    shippingMethods?: ShippingMethodListRelationFilter
  }

  export type ShippingZoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    countries?: SortOrder
    regions?: SortOrder
    postalCodes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: OrganizationOrderByWithRelationInput
    shippingMethods?: ShippingMethodOrderByRelationAggregateInput
  }

  export type ShippingZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShippingZoneWhereInput | ShippingZoneWhereInput[]
    OR?: ShippingZoneWhereInput[]
    NOT?: ShippingZoneWhereInput | ShippingZoneWhereInput[]
    name?: StringFilter<"ShippingZone"> | string
    storeId?: StringFilter<"ShippingZone"> | string
    countries?: StringNullableListFilter<"ShippingZone">
    regions?: StringNullableListFilter<"ShippingZone">
    postalCodes?: StringNullableListFilter<"ShippingZone">
    createdAt?: DateTimeFilter<"ShippingZone"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingZone"> | Date | string
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    shippingMethods?: ShippingMethodListRelationFilter
  }, "id">

  export type ShippingZoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    countries?: SortOrder
    regions?: SortOrder
    postalCodes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShippingZoneCountOrderByAggregateInput
    _max?: ShippingZoneMaxOrderByAggregateInput
    _min?: ShippingZoneMinOrderByAggregateInput
  }

  export type ShippingZoneScalarWhereWithAggregatesInput = {
    AND?: ShippingZoneScalarWhereWithAggregatesInput | ShippingZoneScalarWhereWithAggregatesInput[]
    OR?: ShippingZoneScalarWhereWithAggregatesInput[]
    NOT?: ShippingZoneScalarWhereWithAggregatesInput | ShippingZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShippingZone"> | string
    name?: StringWithAggregatesFilter<"ShippingZone"> | string
    storeId?: StringWithAggregatesFilter<"ShippingZone"> | string
    countries?: StringNullableListFilter<"ShippingZone">
    regions?: StringNullableListFilter<"ShippingZone">
    postalCodes?: StringNullableListFilter<"ShippingZone">
    createdAt?: DateTimeWithAggregatesFilter<"ShippingZone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShippingZone"> | Date | string
  }

  export type ShippingAuditWhereInput = {
    AND?: ShippingAuditWhereInput | ShippingAuditWhereInput[]
    OR?: ShippingAuditWhereInput[]
    NOT?: ShippingAuditWhereInput | ShippingAuditWhereInput[]
    id?: StringFilter<"ShippingAudit"> | string
    shippingId?: StringFilter<"ShippingAudit"> | string
    action?: StringFilter<"ShippingAudit"> | string
    details?: StringNullableFilter<"ShippingAudit"> | string | null
    createdAt?: DateTimeFilter<"ShippingAudit"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingAudit"> | Date | string
    userId?: StringNullableFilter<"ShippingAudit"> | string | null
    metadata?: JsonNullableFilter<"ShippingAudit">
    shipping?: XOR<ShippingScalarRelationFilter, ShippingWhereInput>
  }

  export type ShippingAuditOrderByWithRelationInput = {
    id?: SortOrder
    shippingId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    shipping?: ShippingOrderByWithRelationInput
  }

  export type ShippingAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShippingAuditWhereInput | ShippingAuditWhereInput[]
    OR?: ShippingAuditWhereInput[]
    NOT?: ShippingAuditWhereInput | ShippingAuditWhereInput[]
    shippingId?: StringFilter<"ShippingAudit"> | string
    action?: StringFilter<"ShippingAudit"> | string
    details?: StringNullableFilter<"ShippingAudit"> | string | null
    createdAt?: DateTimeFilter<"ShippingAudit"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingAudit"> | Date | string
    userId?: StringNullableFilter<"ShippingAudit"> | string | null
    metadata?: JsonNullableFilter<"ShippingAudit">
    shipping?: XOR<ShippingScalarRelationFilter, ShippingWhereInput>
  }, "id">

  export type ShippingAuditOrderByWithAggregationInput = {
    id?: SortOrder
    shippingId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ShippingAuditCountOrderByAggregateInput
    _max?: ShippingAuditMaxOrderByAggregateInput
    _min?: ShippingAuditMinOrderByAggregateInput
  }

  export type ShippingAuditScalarWhereWithAggregatesInput = {
    AND?: ShippingAuditScalarWhereWithAggregatesInput | ShippingAuditScalarWhereWithAggregatesInput[]
    OR?: ShippingAuditScalarWhereWithAggregatesInput[]
    NOT?: ShippingAuditScalarWhereWithAggregatesInput | ShippingAuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShippingAudit"> | string
    shippingId?: StringWithAggregatesFilter<"ShippingAudit"> | string
    action?: StringWithAggregatesFilter<"ShippingAudit"> | string
    details?: StringNullableWithAggregatesFilter<"ShippingAudit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShippingAudit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShippingAudit"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"ShippingAudit"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ShippingAudit">
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: IntFilter<"Subscription"> | number
    amount?: DecimalNullableFilter<"Subscription"> | Decimal | DecimalJsLike | number | string | null
    channel?: StringNullableFilter<"Subscription"> | string | null
    customersId?: IntNullableFilter<"Subscription"> | number | null
    customersCode?: StringNullableFilter<"Subscription"> | string | null
    storeId?: StringNullableFilter<"Subscription"> | string | null
    authorizationCode?: StringNullableFilter<"Subscription"> | string | null
    status?: StringNullableFilter<"Subscription"> | string | null
    cardType?: StringNullableFilter<"Subscription"> | string | null
    cardBank?: StringNullableFilter<"Subscription"> | string | null
    cardBrand?: StringNullableFilter<"Subscription"> | string | null
    countryCode?: StringNullableFilter<"Subscription"> | string | null
    accountName?: StringNullableFilter<"Subscription"> | string | null
    cardBin?: IntNullableFilter<"Subscription"> | number | null
    cardLast4?: IntNullableFilter<"Subscription"> | number | null
    expMonth?: IntNullableFilter<"Subscription"> | number | null
    expYear?: IntNullableFilter<"Subscription"> | number | null
    interval?: StringNullableFilter<"Subscription"> | string | null
    emailToken?: StringNullableFilter<"Subscription"> | string | null
    startDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    store?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrderInput | SortOrder
    channel?: SortOrderInput | SortOrder
    customersId?: SortOrderInput | SortOrder
    customersCode?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    authorizationCode?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    cardType?: SortOrderInput | SortOrder
    cardBank?: SortOrderInput | SortOrder
    cardBrand?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    cardBin?: SortOrderInput | SortOrder
    cardLast4?: SortOrderInput | SortOrder
    expMonth?: SortOrderInput | SortOrder
    expYear?: SortOrderInput | SortOrder
    interval?: SortOrderInput | SortOrder
    emailToken?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: OrganizationOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    storeId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    amount?: DecimalNullableFilter<"Subscription"> | Decimal | DecimalJsLike | number | string | null
    channel?: StringNullableFilter<"Subscription"> | string | null
    customersId?: IntNullableFilter<"Subscription"> | number | null
    customersCode?: StringNullableFilter<"Subscription"> | string | null
    authorizationCode?: StringNullableFilter<"Subscription"> | string | null
    status?: StringNullableFilter<"Subscription"> | string | null
    cardType?: StringNullableFilter<"Subscription"> | string | null
    cardBank?: StringNullableFilter<"Subscription"> | string | null
    cardBrand?: StringNullableFilter<"Subscription"> | string | null
    countryCode?: StringNullableFilter<"Subscription"> | string | null
    accountName?: StringNullableFilter<"Subscription"> | string | null
    cardBin?: IntNullableFilter<"Subscription"> | number | null
    cardLast4?: IntNullableFilter<"Subscription"> | number | null
    expMonth?: IntNullableFilter<"Subscription"> | number | null
    expYear?: IntNullableFilter<"Subscription"> | number | null
    interval?: StringNullableFilter<"Subscription"> | string | null
    emailToken?: StringNullableFilter<"Subscription"> | string | null
    startDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    store?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }, "id" | "storeId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrderInput | SortOrder
    channel?: SortOrderInput | SortOrder
    customersId?: SortOrderInput | SortOrder
    customersCode?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    authorizationCode?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    cardType?: SortOrderInput | SortOrder
    cardBank?: SortOrderInput | SortOrder
    cardBrand?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    cardBin?: SortOrderInput | SortOrder
    cardLast4?: SortOrderInput | SortOrder
    expMonth?: SortOrderInput | SortOrder
    expYear?: SortOrderInput | SortOrder
    interval?: SortOrderInput | SortOrder
    emailToken?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subscription"> | number
    amount?: DecimalNullableWithAggregatesFilter<"Subscription"> | Decimal | DecimalJsLike | number | string | null
    channel?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    customersId?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    customersCode?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    storeId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    authorizationCode?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    status?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    cardType?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    cardBank?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    cardBrand?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    countryCode?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    accountName?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    cardBin?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    cardLast4?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    expMonth?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    expYear?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    interval?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    emailToken?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    endsAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: IntFilter<"Plan"> | number
    plansName?: StringFilter<"Plan"> | string
    plansCode?: StringFilter<"Plan"> | string
    plansId?: IntFilter<"Plan"> | number
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    plansName?: SortOrder
    plansCode?: SortOrder
    plansId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    plansName?: StringFilter<"Plan"> | string
    plansCode?: StringFilter<"Plan"> | string
    plansId?: IntFilter<"Plan"> | number
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    plansName?: SortOrder
    plansCode?: SortOrder
    plansId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Plan"> | number
    plansName?: StringWithAggregatesFilter<"Plan"> | string
    plansCode?: StringWithAggregatesFilter<"Plan"> | string
    plansId?: IntWithAggregatesFilter<"Plan"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    storeId?: StringNullableFilter<"Transaction"> | string | null
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    store?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrderInput | SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: OrganizationOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    storeId?: StringNullableFilter<"Transaction"> | string | null
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    store?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrderInput | SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    storeId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type WarehouseWhereInput = {
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    id?: StringFilter<"Warehouse"> | string
    name?: StringFilter<"Warehouse"> | string
    isDefaultLocation?: BoolNullableFilter<"Warehouse"> | boolean | null
    staffId?: StringFilter<"Warehouse"> | string
    storeId?: StringFilter<"Warehouse"> | string
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    inventory?: ProductListRelationFilter
    inventoryItems?: InventoryListRelationFilter
    staffAssigned?: XOR<UserScalarRelationFilter, UserWhereInput>
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type WarehouseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isDefaultLocation?: SortOrderInput | SortOrder
    staffId?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventory?: ProductOrderByRelationAggregateInput
    inventoryItems?: InventoryOrderByRelationAggregateInput
    staffAssigned?: UserOrderByWithRelationInput
    store?: OrganizationOrderByWithRelationInput
  }

  export type WarehouseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    staffId?: string
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    name?: StringFilter<"Warehouse"> | string
    isDefaultLocation?: BoolNullableFilter<"Warehouse"> | boolean | null
    storeId?: StringFilter<"Warehouse"> | string
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    inventory?: ProductListRelationFilter
    inventoryItems?: InventoryListRelationFilter
    staffAssigned?: XOR<UserScalarRelationFilter, UserWhereInput>
    store?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "staffId">

  export type WarehouseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isDefaultLocation?: SortOrderInput | SortOrder
    staffId?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    OR?: WarehouseScalarWhereWithAggregatesInput[]
    NOT?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Warehouse"> | string
    name?: StringWithAggregatesFilter<"Warehouse"> | string
    isDefaultLocation?: BoolNullableWithAggregatesFilter<"Warehouse"> | boolean | null
    staffId?: StringWithAggregatesFilter<"Warehouse"> | string
    storeId?: StringWithAggregatesFilter<"Warehouse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    quantity?: IntFilter<"Inventory"> | number
    productId?: StringFilter<"Inventory"> | string
    warehouseId?: StringFilter<"Inventory"> | string
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    quantity?: IntFilter<"Inventory"> | number
    productId?: StringFilter<"Inventory"> | string
    warehouseId?: StringFilter<"Inventory"> | string
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }, "id">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    quantity?: IntWithAggregatesFilter<"Inventory"> | number
    productId?: StringWithAggregatesFilter<"Inventory"> | string
    warehouseId?: StringWithAggregatesFilter<"Inventory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
  }

  export type CartCreateInput = {
    id?: string
    storeId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutCartInput
    order: OrderCreateNestedOneWithoutCartInput
    customer: CustomerCreateNestedOneWithoutCartsInput
  }

  export type CartUncheckedCreateInput = {
    id?: string
    storeId: string
    customerId: string
    orderId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutCartNestedInput
    order?: OrderUpdateOneRequiredWithoutCartNestedInput
    customer?: CustomerUpdateOneRequiredWithoutCartsNestedInput
  }

  export type CartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartCreateManyInput = {
    id?: string
    storeId: string
    customerId: string
    orderId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateInput = {
    id?: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutCartItemsInput
    product: ProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateInput = {
    id?: string
    cartId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutCartItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyInput = {
    id?: string
    cartId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutCustomerInput
    pos?: POSCreateNestedManyWithoutCustomerInput
    customerGroupMember?: CustomerGroupMemberCreateNestedManyWithoutCustomerInput
    store?: OrganizationCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutCustomerInput
    pos?: POSUncheckedCreateNestedManyWithoutCustomerInput
    customerGroupMember?: CustomerGroupMemberUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutCustomerNestedInput
    pos?: POSUpdateManyWithoutCustomerNestedInput
    customerGroupMember?: CustomerGroupMemberUpdateManyWithoutCustomerNestedInput
    store?: OrganizationUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    pos?: POSUncheckedUpdateManyWithoutCustomerNestedInput
    customerGroupMember?: CustomerGroupMemberUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryCreateInput = {
    id?: string
    orderId: string
    totalAmount: number
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutPurchaseHistoryInput
  }

  export type PurchaseHistoryUncheckedCreateInput = {
    id?: string
    orderId: string
    totalAmount: number
    date: Date | string
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutPurchaseHistoryNestedInput
  }

  export type PurchaseHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryCreateManyInput = {
    id?: string
    orderId: string
    totalAmount: number
    date: Date | string
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutCustomerGroupsInput
    customerGroupMember?: CustomerGroupMemberCreateNestedManyWithoutCustomerGroupInput
  }

  export type CustomerGroupsUncheckedCreateInput = {
    id?: string
    name: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerGroupMember?: CustomerGroupMemberUncheckedCreateNestedManyWithoutCustomerGroupInput
  }

  export type CustomerGroupsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutCustomerGroupsNestedInput
    customerGroupMember?: CustomerGroupMemberUpdateManyWithoutCustomerGroupNestedInput
  }

  export type CustomerGroupsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerGroupMember?: CustomerGroupMemberUncheckedUpdateManyWithoutCustomerGroupNestedInput
  }

  export type CustomerGroupsCreateManyInput = {
    id?: string
    name: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerGroupsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupMemberCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCustomerGroupMemberInput
    customerGroup: CustomerGroupsCreateNestedOneWithoutCustomerGroupMemberInput
  }

  export type CustomerGroupMemberUncheckedCreateInput = {
    customerId: string
    customerGroupId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerGroupMemberUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCustomerGroupMemberNestedInput
    customerGroup?: CustomerGroupsUpdateOneRequiredWithoutCustomerGroupMemberNestedInput
  }

  export type CustomerGroupMemberUncheckedUpdateInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerGroupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupMemberCreateManyInput = {
    customerId: string
    customerGroupId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerGroupMemberUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupMemberUncheckedUpdateManyInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerGroupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    id?: string
    name?: string | null
    amount?: number | null
    description?: string | null
    paymentMethod?: string | null
    paymentStatus?: string | null
    date?: Date | string | null
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expenseCategory?: ExpenseCategoryCreateNestedManyWithoutExpenseInput
    store: OrganizationCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    name?: string | null
    amount?: number | null
    description?: string | null
    paymentMethod?: string | null
    paymentStatus?: string | null
    date?: Date | string | null
    locationId: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expenseCategory?: ExpenseCategoryUncheckedCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenseCategory?: ExpenseCategoryUpdateManyWithoutExpenseNestedInput
    store?: OrganizationUpdateOneRequiredWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenseCategory?: ExpenseCategoryUncheckedUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseCreateManyInput = {
    id?: string
    name?: string | null
    amount?: number | null
    description?: string | null
    paymentMethod?: string | null
    paymentStatus?: string | null
    date?: Date | string | null
    locationId: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryCreateInput = {
    id?: string
    name: string
    description: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    expense: ExpenseCreateNestedOneWithoutExpenseCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    date: Date | string
    expenseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expense?: ExpenseUpdateOneRequiredWithoutExpenseCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    expenseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryCreateManyInput = {
    id?: string
    name: string
    description: string
    date: Date | string
    expenseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    expenseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagCreateInput = {
    id?: string
    name: string
    slug: string
    isEnabled: boolean
    rollout: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    isEnabled: boolean
    rollout: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rollout?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rollout?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagCreateManyInput = {
    id?: string
    name: string
    slug: string
    isEnabled: boolean
    rollout: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureFlagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rollout?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureFlagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    rollout?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailsCreateInput = {
    id?: string
    bankName: string
    bankCode: string
    accountName: string
    accountNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutBankDetailsInput
  }

  export type BankDetailsUncheckedCreateInput = {
    id?: string
    bankName: string
    bankCode: string
    accountName: string
    accountNumber: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutBankDetailsNestedInput
  }

  export type BankDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailsCreateManyInput = {
    id?: string
    bankName: string
    bankCode: string
    accountName: string
    accountNumber: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    balance: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    balance: Decimal | DecimalJsLike | number | string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateManyInput = {
    id?: string
    balance: Decimal | DecimalJsLike | number | string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    title: string
    customerEmail: string
    description?: string | null
    status?: string | null
    downloadUrl: string
    paymentLink?: string | null
    qrCode?: string | null
    amount: string
    total?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    storeId: string
    invoiceNumber: string
    title: string
    customerEmail: string
    description?: string | null
    status?: string | null
    downloadUrl: string
    paymentLink?: string | null
    qrCode?: string | null
    amount: string
    total?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: StringFieldUpdateOperationsInput | string
    paymentLink?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: StringFieldUpdateOperationsInput | string
    paymentLink?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    storeId: string
    invoiceNumber: string
    title: string
    customerEmail: string
    description?: string | null
    status?: string | null
    downloadUrl: string
    paymentLink?: string | null
    qrCode?: string | null
    amount: string
    total?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: StringFieldUpdateOperationsInput | string
    paymentLink?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: StringFieldUpdateOperationsInput | string
    paymentLink?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    address?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    description?: string | null
    isdefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedManyWithoutLocationInput
    order?: OrderCreateNestedManyWithoutLocationInput
    product?: ProductCreateNestedManyWithoutLocationInput
    store: OrganizationCreateNestedOneWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    description?: string | null
    storeId: string
    isdefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedManyWithoutLocationInput
    order?: OrderUncheckedCreateNestedManyWithoutLocationInput
    product?: ProductUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateManyWithoutLocationNestedInput
    order?: OrderUpdateManyWithoutLocationNestedInput
    product?: ProductUpdateManyWithoutLocationNestedInput
    store?: OrganizationUpdateOneRequiredWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateManyWithoutLocationNestedInput
    order?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    product?: ProductUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    description?: string | null
    storeId: string
    isdefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    createdBy?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    pos?: POSCreateNestedOneWithoutOrderInput
    cart?: CartCreateNestedOneWithoutOrderInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    location?: LocationCreateNestedOneWithoutOrderInput
    store?: OrganizationCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    customerId: string
    locationId: string
    createdBy?: string | null
    storeId?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    pos?: POSUncheckedCreateNestedOneWithoutOrderInput
    cart?: CartUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    pos?: POSUpdateOneWithoutOrderNestedInput
    cart?: CartUpdateOneWithoutOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    location?: LocationUpdateOneWithoutOrderNestedInput
    store?: OrganizationUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    pos?: POSUncheckedUpdateOneWithoutOrderNestedInput
    cart?: CartUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    customerId: string
    locationId: string
    createdBy?: string | null
    storeId?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity: number
    price: number
    order: OrderCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    quantity: number
    price: number
    orderId: string
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    orderId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemCreateManyInput = {
    id?: string
    quantity: number
    price: number
    orderId: string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    orderId?: StringFieldUpdateOperationsInput | string
  }

  export type POSCreateInput = {
    id?: string
    terminalId: string
    confirmed?: boolean
    confirmedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutPosInput
    staff: UserCreateNestedOneWithoutPOSInput
    order: OrderCreateNestedOneWithoutPosInput
  }

  export type POSUncheckedCreateInput = {
    id?: string
    staffId: string
    orderId: string
    customerId: string
    terminalId: string
    confirmed?: boolean
    confirmedAt?: Date | string | null
  }

  export type POSUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutPosNestedInput
    staff?: UserUpdateOneRequiredWithoutPOSNestedInput
    order?: OrderUpdateOneRequiredWithoutPosNestedInput
  }

  export type POSUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type POSCreateManyInput = {
    id?: string
    staffId: string
    orderId: string
    customerId: string
    terminalId: string
    confirmed?: boolean
    confirmedAt?: Date | string | null
  }

  export type POSUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type POSUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PointOfSaleCreateInput = {
    id?: string
    createdAt: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutPointOfSaleInput
    staffAssigned: UserCreateNestedOneWithoutPointOfSaleInput
  }

  export type PointOfSaleUncheckedCreateInput = {
    id?: string
    storeId: string
    staffAssignedId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type PointOfSaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutPointOfSaleNestedInput
    staffAssigned?: UserUpdateOneRequiredWithoutPointOfSaleNestedInput
  }

  export type PointOfSaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    staffAssignedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointOfSaleCreateManyInput = {
    id?: string
    storeId: string
    staffAssignedId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type PointOfSaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointOfSaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    staffAssignedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredBrands?: FeaturedBrandsCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    collection?: ProductCollectionCreateNestedOneWithoutProductsInput
    purchase?: PurchaseCreateNestedOneWithoutProductsInput
    store: OrganizationCreateNestedOneWithoutProductInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryInput
    location?: LocationCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
    featuredBrands?: FeaturedBrandsUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredBrands?: FeaturedBrandsUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    collection?: ProductCollectionUpdateOneWithoutProductsNestedInput
    purchase?: PurchaseUpdateOneWithoutProductsNestedInput
    store?: OrganizationUpdateOneRequiredWithoutProductNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryNestedInput
    location?: LocationUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredBrands?: FeaturedBrandsUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCategoryCreateInput = {
    id?: string
    name?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedManyWithoutProductCategoryInput
    store: OrganizationCreateNestedOneWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: string
    name?: string | null
    description?: string | null
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutProductCategoryNestedInput
    store?: OrganizationUpdateOneRequiredWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: string
    name?: string | null
    description?: string | null
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCollectionCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCollectionInput
  }

  export type ProductCollectionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type ProductCollectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCollectionNestedInput
  }

  export type ProductCollectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type ProductCollectionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCollectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCollectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationCreateInput = {
    id?: string
    sku: string
    price: number
    cost?: number | null
    discountPrice?: number | null
    stock?: number
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductVariationInput
    options?: ProductVariationOptionCreateNestedManyWithoutVariationInput
  }

  export type ProductVariationUncheckedCreateInput = {
    id?: string
    productId: string
    sku: string
    price: number
    cost?: number | null
    discountPrice?: number | null
    stock?: number
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ProductVariationOptionUncheckedCreateNestedManyWithoutVariationInput
  }

  export type ProductVariationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductVariationNestedInput
    options?: ProductVariationOptionUpdateManyWithoutVariationNestedInput
  }

  export type ProductVariationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ProductVariationOptionUncheckedUpdateManyWithoutVariationNestedInput
  }

  export type ProductVariationCreateManyInput = {
    id?: string
    productId: string
    sku: string
    price: number
    cost?: number | null
    discountPrice?: number | null
    stock?: number
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: ProductVariantValueCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: ProductVariantValueUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: ProductVariantValueUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: ProductVariantValueUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantValueCreateInput = {
    id?: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    variant: ProductVariantCreateNestedOneWithoutValuesInput
    options?: ProductVariationOptionCreateNestedManyWithoutValueInput
  }

  export type ProductVariantValueUncheckedCreateInput = {
    id?: string
    variantId: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ProductVariationOptionUncheckedCreateNestedManyWithoutValueInput
  }

  export type ProductVariantValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: ProductVariantUpdateOneRequiredWithoutValuesNestedInput
    options?: ProductVariationOptionUpdateManyWithoutValueNestedInput
  }

  export type ProductVariantValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ProductVariationOptionUncheckedUpdateManyWithoutValueNestedInput
  }

  export type ProductVariantValueCreateManyInput = {
    id?: string
    variantId: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationOptionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: ProductVariationCreateNestedOneWithoutOptionsInput
    value: ProductVariantValueCreateNestedOneWithoutOptionsInput
  }

  export type ProductVariationOptionUncheckedCreateInput = {
    id?: string
    variationId: string
    valueId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: ProductVariationUpdateOneRequiredWithoutOptionsNestedInput
    value?: ProductVariantValueUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type ProductVariationOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    valueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationOptionCreateManyInput = {
    id?: string
    variationId: string
    valueId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    valueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedBrandsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutFeaturedBrandsInput
  }

  export type FeaturedBrandsUncheckedCreateInput = {
    id?: string
    name: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedBrandsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutFeaturedBrandsNestedInput
  }

  export type FeaturedBrandsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedBrandsCreateManyInput = {
    id?: string
    name: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedBrandsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedBrandsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    supplierName: string
    email: string
    phoneNumber: string
    personOfSupplier: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase?: PurchaseCreateNestedManyWithoutStoreSupplierInput
    store: OrganizationCreateNestedOneWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    supplierName: string
    email: string
    phoneNumber: string
    personOfSupplier: string
    location: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personOfSupplier?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateManyWithoutStoreSupplierNestedInput
    store?: OrganizationUpdateOneRequiredWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personOfSupplier?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    supplierName: string
    email: string
    phoneNumber: string
    personOfSupplier: string
    location: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personOfSupplier?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personOfSupplier?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateInput = {
    id?: string
    status: string
    downloadUrl: string
    toalCost: Decimal | DecimalJsLike | number | string
    deliveryDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeSupplier: SupplierCreateNestedOneWithoutPurchaseInput
    store: OrganizationCreateNestedOneWithoutPurchaseInput
    products?: ProductCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    status: string
    downloadUrl: string
    toalCost: Decimal | DecimalJsLike | number | string
    storeSupplierId: string
    storeId: string
    deliveryDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    toalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeSupplier?: SupplierUpdateOneRequiredWithoutPurchaseNestedInput
    store?: OrganizationUpdateOneRequiredWithoutPurchaseNestedInput
    products?: ProductUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    toalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    storeSupplierId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseCreateManyInput = {
    id?: string
    status: string
    downloadUrl: string
    toalCost: Decimal | DecimalJsLike | number | string
    storeSupplierId: string
    storeId: string
    deliveryDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    toalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    toalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    storeSupplierId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    PointOfSale?: PointOfSaleCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseCreateNestedOneWithoutStaffAssignedInput
    POS?: POSCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    PointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseUncheckedCreateNestedOneWithoutStaffAssignedInput
    POS?: POSUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    PointOfSale?: PointOfSaleUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    PointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUncheckedUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
    activeOrganizationId?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
    impersonatedBy?: string | null
    activeOrganizationId?: string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
    impersonatedBy?: string | null
    activeOrganizationId?: string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganizationCreateInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationCreateManyInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MemberCreateInput = {
    id: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateInput = {
    id: string
    organizationId: string
    userId: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateManyInput = {
    id: string
    organizationId: string
    userId: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateInput = {
    id: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutInvitationsInput
    user: UserCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateInput = {
    id: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutInvitationsNestedInput
    user?: UserUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateManyInput = {
    id: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutSettlementsInput
  }

  export type SettlementUncheckedCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutSettlementsNestedInput
  }

  export type SettlementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementCreateManyInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingCreateInput = {
    id?: string
    orderId: string
    trackingNumber?: string | null
    carrier?: string | null
    status?: $Enums.ShippingStatus
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    shippingAddress: string
    shippingZoneName?: string | null
    shippingFee?: Decimal | DecimalJsLike | number | string
    weight?: number | null
    dimensions?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shippingMethod: ShippingMethodCreateNestedOneWithoutShippingInput
    auditLogs?: ShippingAuditCreateNestedManyWithoutShippingInput
  }

  export type ShippingUncheckedCreateInput = {
    id?: string
    orderId: string
    shippingMethodId: string
    trackingNumber?: string | null
    carrier?: string | null
    status?: $Enums.ShippingStatus
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    shippingAddress: string
    shippingZoneName?: string | null
    shippingFee?: Decimal | DecimalJsLike | number | string
    weight?: number | null
    dimensions?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: ShippingAuditUncheckedCreateNestedManyWithoutShippingInput
  }

  export type ShippingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShippingStatusFieldUpdateOperationsInput | $Enums.ShippingStatus
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: StringFieldUpdateOperationsInput | string
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippingMethod?: ShippingMethodUpdateOneRequiredWithoutShippingNestedInput
    auditLogs?: ShippingAuditUpdateManyWithoutShippingNestedInput
  }

  export type ShippingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    shippingMethodId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShippingStatusFieldUpdateOperationsInput | $Enums.ShippingStatus
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: StringFieldUpdateOperationsInput | string
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: ShippingAuditUncheckedUpdateManyWithoutShippingNestedInput
  }

  export type ShippingCreateManyInput = {
    id?: string
    orderId: string
    shippingMethodId: string
    trackingNumber?: string | null
    carrier?: string | null
    status?: $Enums.ShippingStatus
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    shippingAddress: string
    shippingZoneName?: string | null
    shippingFee?: Decimal | DecimalJsLike | number | string
    weight?: number | null
    dimensions?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShippingStatusFieldUpdateOperationsInput | $Enums.ShippingStatus
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: StringFieldUpdateOperationsInput | string
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    shippingMethodId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShippingStatusFieldUpdateOperationsInput | $Enums.ShippingStatus
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: StringFieldUpdateOperationsInput | string
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingMethodCreateInput = {
    id?: string
    name: string
    description?: string | null
    carrier?: string | null
    deliveryTime: string
    baseCost: number
    costCalculation?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutShippingMethodInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutShippingMethodsInput
    Shipping?: ShippingCreateNestedManyWithoutShippingMethodInput
  }

  export type ShippingMethodUncheckedCreateInput = {
    id?: string
    name: string
    storeId: string
    description?: string | null
    carrier?: string | null
    deliveryTime: string
    baseCost: number
    costCalculation?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shippingZones?: ShippingZoneUncheckedCreateNestedManyWithoutShippingMethodsInput
    Shipping?: ShippingUncheckedCreateNestedManyWithoutShippingMethodInput
  }

  export type ShippingMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    costCalculation?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutShippingMethodNestedInput
    shippingZones?: ShippingZoneUpdateManyWithoutShippingMethodsNestedInput
    Shipping?: ShippingUpdateManyWithoutShippingMethodNestedInput
  }

  export type ShippingMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    costCalculation?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippingZones?: ShippingZoneUncheckedUpdateManyWithoutShippingMethodsNestedInput
    Shipping?: ShippingUncheckedUpdateManyWithoutShippingMethodNestedInput
  }

  export type ShippingMethodCreateManyInput = {
    id?: string
    name: string
    storeId: string
    description?: string | null
    carrier?: string | null
    deliveryTime: string
    baseCost: number
    costCalculation?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    costCalculation?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    costCalculation?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingZoneCreateInput = {
    id?: string
    name: string
    countries?: ShippingZoneCreatecountriesInput | string[]
    regions?: ShippingZoneCreateregionsInput | string[]
    postalCodes?: ShippingZoneCreatepostalCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutShippingZoneInput
    shippingMethods?: ShippingMethodCreateNestedManyWithoutShippingZonesInput
  }

  export type ShippingZoneUncheckedCreateInput = {
    id?: string
    name: string
    storeId: string
    countries?: ShippingZoneCreatecountriesInput | string[]
    regions?: ShippingZoneCreateregionsInput | string[]
    postalCodes?: ShippingZoneCreatepostalCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    shippingMethods?: ShippingMethodUncheckedCreateNestedManyWithoutShippingZonesInput
  }

  export type ShippingZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countries?: ShippingZoneUpdatecountriesInput | string[]
    regions?: ShippingZoneUpdateregionsInput | string[]
    postalCodes?: ShippingZoneUpdatepostalCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutShippingZoneNestedInput
    shippingMethods?: ShippingMethodUpdateManyWithoutShippingZonesNestedInput
  }

  export type ShippingZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    countries?: ShippingZoneUpdatecountriesInput | string[]
    regions?: ShippingZoneUpdateregionsInput | string[]
    postalCodes?: ShippingZoneUpdatepostalCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippingMethods?: ShippingMethodUncheckedUpdateManyWithoutShippingZonesNestedInput
  }

  export type ShippingZoneCreateManyInput = {
    id?: string
    name: string
    storeId: string
    countries?: ShippingZoneCreatecountriesInput | string[]
    regions?: ShippingZoneCreateregionsInput | string[]
    postalCodes?: ShippingZoneCreatepostalCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countries?: ShippingZoneUpdatecountriesInput | string[]
    regions?: ShippingZoneUpdateregionsInput | string[]
    postalCodes?: ShippingZoneUpdatepostalCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    countries?: ShippingZoneUpdatecountriesInput | string[]
    regions?: ShippingZoneUpdateregionsInput | string[]
    postalCodes?: ShippingZoneUpdatepostalCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingAuditCreateInput = {
    id?: string
    action: string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    shipping: ShippingCreateNestedOneWithoutAuditLogsInput
  }

  export type ShippingAuditUncheckedCreateInput = {
    id?: string
    shippingId: string
    action: string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShippingAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    shipping?: ShippingUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type ShippingAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shippingId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShippingAuditCreateManyInput = {
    id?: string
    shippingId: string
    action: string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShippingAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShippingAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shippingId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubscriptionCreateInput = {
    amount?: Decimal | DecimalJsLike | number | string | null
    channel?: string | null
    customersId?: number | null
    customersCode?: string | null
    authorizationCode?: string | null
    status?: string | null
    cardType?: string | null
    cardBank?: string | null
    cardBrand?: string | null
    countryCode?: string | null
    accountName?: string | null
    cardBin?: number | null
    cardLast4?: number | null
    expMonth?: number | null
    expYear?: number | null
    interval?: string | null
    emailToken?: string | null
    startDate?: Date | string | null
    endsAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: OrganizationCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: number
    amount?: Decimal | DecimalJsLike | number | string | null
    channel?: string | null
    customersId?: number | null
    customersCode?: string | null
    storeId?: string | null
    authorizationCode?: string | null
    status?: string | null
    cardType?: string | null
    cardBank?: string | null
    cardBrand?: string | null
    countryCode?: string | null
    accountName?: string | null
    cardBin?: number | null
    cardLast4?: number | null
    expMonth?: number | null
    expYear?: number | null
    interval?: string | null
    emailToken?: string | null
    startDate?: Date | string | null
    endsAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    customersCode?: NullableStringFieldUpdateOperationsInput | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardBank?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBin?: NullableIntFieldUpdateOperationsInput | number | null
    cardLast4?: NullableIntFieldUpdateOperationsInput | number | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableStringFieldUpdateOperationsInput | string | null
    emailToken?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    customersCode?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardBank?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBin?: NullableIntFieldUpdateOperationsInput | number | null
    cardLast4?: NullableIntFieldUpdateOperationsInput | number | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableStringFieldUpdateOperationsInput | string | null
    emailToken?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: number
    amount?: Decimal | DecimalJsLike | number | string | null
    channel?: string | null
    customersId?: number | null
    customersCode?: string | null
    storeId?: string | null
    authorizationCode?: string | null
    status?: string | null
    cardType?: string | null
    cardBank?: string | null
    cardBrand?: string | null
    countryCode?: string | null
    accountName?: string | null
    cardBin?: number | null
    cardLast4?: number | null
    expMonth?: number | null
    expYear?: number | null
    interval?: string | null
    emailToken?: string | null
    startDate?: Date | string | null
    endsAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    customersCode?: NullableStringFieldUpdateOperationsInput | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardBank?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBin?: NullableIntFieldUpdateOperationsInput | number | null
    cardLast4?: NullableIntFieldUpdateOperationsInput | number | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableStringFieldUpdateOperationsInput | string | null
    emailToken?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    customersCode?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardBank?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBin?: NullableIntFieldUpdateOperationsInput | number | null
    cardLast4?: NullableIntFieldUpdateOperationsInput | number | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableStringFieldUpdateOperationsInput | string | null
    emailToken?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    plansName: string
    plansCode: string
    plansId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUncheckedCreateInput = {
    id?: number
    plansName: string
    plansCode: string
    plansId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUpdateInput = {
    plansName?: StringFieldUpdateOperationsInput | string
    plansCode?: StringFieldUpdateOperationsInput | string
    plansId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plansName?: StringFieldUpdateOperationsInput | string
    plansCode?: StringFieldUpdateOperationsInput | string
    plansId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateManyInput = {
    id?: number
    plansName: string
    plansCode: string
    plansId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    plansName?: StringFieldUpdateOperationsInput | string
    plansCode?: StringFieldUpdateOperationsInput | string
    plansId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plansName?: StringFieldUpdateOperationsInput | string
    plansCode?: StringFieldUpdateOperationsInput | string
    plansId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: OrganizationCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    storeId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    storeId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseCreateInput = {
    id?: string
    name: string
    isDefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryCreateNestedManyWithoutWarehouseInput
    staffAssigned: UserCreateNestedOneWithoutWarehouseInput
    store: OrganizationCreateNestedOneWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateInput = {
    id?: string
    name: string
    isDefaultLocation?: boolean | null
    staffId: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryUpdateManyWithoutWarehouseNestedInput
    staffAssigned?: UserUpdateOneRequiredWithoutWarehouseNestedInput
    store?: OrganizationUpdateOneRequiredWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    staffId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseCreateManyInput = {
    id?: string
    name: string
    isDefaultLocation?: boolean | null
    staffId: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    staffId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateInput = {
    id?: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    warehouse: WarehouseCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    quantity?: number
    productId: string
    warehouseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateManyInput = {
    id?: string
    quantity?: number
    productId: string
    warehouseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput
    some?: CartItemWhereInput
    none?: CartItemWhereInput
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CartScalarRelationFilter = {
    is?: CartWhereInput
    isNot?: CartWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type CartListRelationFilter = {
    every?: CartWhereInput
    some?: CartWhereInput
    none?: CartWhereInput
  }

  export type PurchaseHistoryListRelationFilter = {
    every?: PurchaseHistoryWhereInput
    some?: PurchaseHistoryWhereInput
    none?: PurchaseHistoryWhereInput
  }

  export type POSListRelationFilter = {
    every?: POSWhereInput
    some?: POSWhereInput
    none?: POSWhereInput
  }

  export type CustomerGroupMemberListRelationFilter = {
    every?: CustomerGroupMemberWhereInput
    some?: CustomerGroupMemberWhereInput
    none?: CustomerGroupMemberWhereInput
  }

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerGroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    avatar?: SortOrder
    isGuest?: SortOrder
    customerType?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    avatar?: SortOrder
    isGuest?: SortOrder
    customerType?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    avatar?: SortOrder
    isGuest?: SortOrder
    customerType?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type PurchaseHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    totalAmount?: SortOrder
    date?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseHistoryAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type PurchaseHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    totalAmount?: SortOrder
    date?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    totalAmount?: SortOrder
    date?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseHistorySumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type CustomerGroupsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerGroupsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerGroupsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerGroupsScalarRelationFilter = {
    is?: CustomerGroupsWhereInput
    isNot?: CustomerGroupsWhereInput
  }

  export type CustomerGroupMemberCustomerIdCustomerGroupIdCompoundUniqueInput = {
    customerId: string
    customerGroupId: string
  }

  export type CustomerGroupMemberCountOrderByAggregateInput = {
    customerId?: SortOrder
    customerGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerGroupMemberMaxOrderByAggregateInput = {
    customerId?: SortOrder
    customerGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerGroupMemberMinOrderByAggregateInput = {
    customerId?: SortOrder
    customerGroupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ExpenseCategoryListRelationFilter = {
    every?: ExpenseCategoryWhereInput
    some?: ExpenseCategoryWhereInput
    none?: ExpenseCategoryWhereInput
  }

  export type ExpenseCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    date?: SortOrder
    locationId?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    date?: SortOrder
    locationId?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    date?: SortOrder
    locationId?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ExpenseScalarRelationFilter = {
    is?: ExpenseWhereInput
    isNot?: ExpenseWhereInput
  }

  export type ExpenseCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    expenseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    expenseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
    expenseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isEnabled?: SortOrder
    rollout?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagAvgOrderByAggregateInput = {
    rollout?: SortOrder
  }

  export type FeatureFlagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isEnabled?: SortOrder
    rollout?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isEnabled?: SortOrder
    rollout?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureFlagSumOrderByAggregateInput = {
    rollout?: SortOrder
  }

  export type BankDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    invoiceNumber?: SortOrder
    title?: SortOrder
    customerEmail?: SortOrder
    description?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrder
    paymentLink?: SortOrder
    qrCode?: SortOrder
    amount?: SortOrder
    total?: SortOrder
    tax?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    total?: SortOrder
    tax?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    invoiceNumber?: SortOrder
    title?: SortOrder
    customerEmail?: SortOrder
    description?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrder
    paymentLink?: SortOrder
    qrCode?: SortOrder
    amount?: SortOrder
    total?: SortOrder
    tax?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    invoiceNumber?: SortOrder
    title?: SortOrder
    customerEmail?: SortOrder
    description?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrder
    paymentLink?: SortOrder
    qrCode?: SortOrder
    amount?: SortOrder
    total?: SortOrder
    tax?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    total?: SortOrder
    tax?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    description?: SortOrder
    storeId?: SortOrder
    isdefaultLocation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    description?: SortOrder
    storeId?: SortOrder
    isdefaultLocation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    description?: SortOrder
    storeId?: SortOrder
    isdefaultLocation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type POSNullableScalarRelationFilter = {
    is?: POSWhereInput | null
    isNot?: POSWhereInput | null
  }

  export type CartNullableScalarRelationFilter = {
    is?: CartWhereInput | null
    isNot?: CartWhereInput | null
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    locationId?: SortOrder
    createdBy?: SortOrder
    storeId?: SortOrder
    shippingMethodId?: SortOrder
    grandTotal?: SortOrder
    iscustomerAssigned?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    deliveryTrackingNumber?: SortOrder
    totalAmount?: SortOrder
    subtotalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    shippingFee?: SortOrder
    shippingZoneName?: SortOrder
    shippingAddress?: SortOrder
    shippingStatus?: SortOrder
    channel?: SortOrder
    isposConfirmed?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhoneNumber?: SortOrder
    posConfirmedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    grandTotal?: SortOrder
    deliveryTrackingNumber?: SortOrder
    totalAmount?: SortOrder
    subtotalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    shippingFee?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    locationId?: SortOrder
    createdBy?: SortOrder
    storeId?: SortOrder
    shippingMethodId?: SortOrder
    grandTotal?: SortOrder
    iscustomerAssigned?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    deliveryTrackingNumber?: SortOrder
    totalAmount?: SortOrder
    subtotalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    shippingFee?: SortOrder
    shippingZoneName?: SortOrder
    shippingAddress?: SortOrder
    shippingStatus?: SortOrder
    channel?: SortOrder
    isposConfirmed?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhoneNumber?: SortOrder
    posConfirmedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    locationId?: SortOrder
    createdBy?: SortOrder
    storeId?: SortOrder
    shippingMethodId?: SortOrder
    grandTotal?: SortOrder
    iscustomerAssigned?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    deliveryTrackingNumber?: SortOrder
    totalAmount?: SortOrder
    subtotalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    shippingFee?: SortOrder
    shippingZoneName?: SortOrder
    shippingAddress?: SortOrder
    shippingStatus?: SortOrder
    channel?: SortOrder
    isposConfirmed?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhoneNumber?: SortOrder
    posConfirmedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    grandTotal?: SortOrder
    deliveryTrackingNumber?: SortOrder
    totalAmount?: SortOrder
    subtotalAmount?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    shippingFee?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    orderId?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type POSCountOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    terminalId?: SortOrder
    confirmed?: SortOrder
    confirmedAt?: SortOrder
  }

  export type POSMaxOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    terminalId?: SortOrder
    confirmed?: SortOrder
    confirmedAt?: SortOrder
  }

  export type POSMinOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    terminalId?: SortOrder
    confirmed?: SortOrder
    confirmedAt?: SortOrder
  }

  export type PointOfSaleCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    staffAssignedId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointOfSaleMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    staffAssignedId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointOfSaleMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    staffAssignedId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumProductStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProductStatusNullableFilter<$PrismaModel> | $Enums.ProductStatus | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FeaturedBrandsListRelationFilter = {
    every?: FeaturedBrandsWhereInput
    some?: FeaturedBrandsWhereInput
    none?: FeaturedBrandsWhereInput
  }

  export type ProductVariationListRelationFilter = {
    every?: ProductVariationWhereInput
    some?: ProductVariationWhereInput
    none?: ProductVariationWhereInput
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type ProductCollectionNullableScalarRelationFilter = {
    is?: ProductCollectionWhereInput | null
    isNot?: ProductCollectionWhereInput | null
  }

  export type PurchaseNullableScalarRelationFilter = {
    is?: PurchaseWhereInput | null
    isNot?: PurchaseWhereInput | null
  }

  export type WarehouseNullableScalarRelationFilter = {
    is?: WarehouseWhereInput | null
    isNot?: WarehouseWhereInput | null
  }

  export type FeaturedBrandsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductVariationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    shippingWeight?: SortOrder
    handleTime?: SortOrder
    freeShipping?: SortOrder
    packaging?: SortOrder
    discountPrice?: SortOrder
    unitSold?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    productSize?: SortOrder
    productStatus?: SortOrder
    imageUrl?: SortOrder
    storeId?: SortOrder
    locationId?: SortOrder
    purchaseOrderId?: SortOrder
    collectionId?: SortOrder
    hasVariation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouseId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    stock?: SortOrder
    price?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    shippingWeight?: SortOrder
    handleTime?: SortOrder
    freeShipping?: SortOrder
    packaging?: SortOrder
    discountPrice?: SortOrder
    unitSold?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    productSize?: SortOrder
    productStatus?: SortOrder
    storeId?: SortOrder
    locationId?: SortOrder
    purchaseOrderId?: SortOrder
    collectionId?: SortOrder
    hasVariation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouseId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    shippingWeight?: SortOrder
    handleTime?: SortOrder
    freeShipping?: SortOrder
    packaging?: SortOrder
    discountPrice?: SortOrder
    unitSold?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    productSize?: SortOrder
    productStatus?: SortOrder
    storeId?: SortOrder
    locationId?: SortOrder
    purchaseOrderId?: SortOrder
    collectionId?: SortOrder
    hasVariation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouseId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    stock?: SortOrder
    price?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumProductStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProductStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProductStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumProductStatusNullableFilter<$PrismaModel>
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCollectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCollectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCollectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariationOptionListRelationFilter = {
    every?: ProductVariationOptionWhereInput
    some?: ProductVariationOptionWhereInput
    none?: ProductVariationOptionWhereInput
  }

  export type ProductVariationOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductVariationCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    discountPrice?: SortOrder
    stock?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariationAvgOrderByAggregateInput = {
    price?: SortOrder
    cost?: SortOrder
    discountPrice?: SortOrder
    stock?: SortOrder
  }

  export type ProductVariationMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    discountPrice?: SortOrder
    stock?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariationMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    discountPrice?: SortOrder
    stock?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariationSumOrderByAggregateInput = {
    price?: SortOrder
    cost?: SortOrder
    discountPrice?: SortOrder
    stock?: SortOrder
  }

  export type ProductVariantValueListRelationFilter = {
    every?: ProductVariantValueWhereInput
    some?: ProductVariantValueWhereInput
    none?: ProductVariantValueWhereInput
  }

  export type ProductVariantValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductVariantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantScalarRelationFilter = {
    is?: ProductVariantWhereInput
    isNot?: ProductVariantWhereInput
  }

  export type ProductVariantValueCountOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantValueMaxOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantValueMinOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariationScalarRelationFilter = {
    is?: ProductVariationWhereInput
    isNot?: ProductVariationWhereInput
  }

  export type ProductVariantValueScalarRelationFilter = {
    is?: ProductVariantValueWhereInput
    isNot?: ProductVariantValueWhereInput
  }

  export type ProductVariationOptionVariationIdValueIdCompoundUniqueInput = {
    variationId: string
    valueId: string
  }

  export type ProductVariationOptionCountOrderByAggregateInput = {
    id?: SortOrder
    variationId?: SortOrder
    valueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariationOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    variationId?: SortOrder
    valueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariationOptionMinOrderByAggregateInput = {
    id?: SortOrder
    variationId?: SortOrder
    valueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedBrandsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedBrandsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedBrandsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    supplierName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    personOfSupplier?: SortOrder
    location?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    personOfSupplier?: SortOrder
    location?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    supplierName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    personOfSupplier?: SortOrder
    location?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrder
    toalCost?: SortOrder
    storeSupplierId?: SortOrder
    storeId?: SortOrder
    deliveryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    toalCost?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrder
    toalCost?: SortOrder
    storeSupplierId?: SortOrder
    storeId?: SortOrder
    deliveryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrder
    toalCost?: SortOrder
    storeSupplierId?: SortOrder
    storeId?: SortOrder
    deliveryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    toalCost?: SortOrder
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type PointOfSaleNullableScalarRelationFilter = {
    is?: PointOfSaleWhereInput | null
    isNot?: PointOfSaleWhereInput | null
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrder
    activeOrganizationId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrder
    activeOrganizationId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrder
    activeOrganizationId?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailsNullableScalarRelationFilter = {
    is?: BankDetailsWhereInput | null
    isNot?: BankDetailsWhereInput | null
  }

  export type WalletNullableScalarRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type CustomerGroupsListRelationFilter = {
    every?: CustomerGroupsWhereInput
    some?: CustomerGroupsWhereInput
    none?: CustomerGroupsWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type SettlementListRelationFilter = {
    every?: SettlementWhereInput
    some?: SettlementWhereInput
    none?: SettlementWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type WarehouseListRelationFilter = {
    every?: WarehouseWhereInput
    some?: WarehouseWhereInput
    none?: WarehouseWhereInput
  }

  export type ShippingMethodListRelationFilter = {
    every?: ShippingMethodWhereInput
    some?: ShippingMethodWhereInput
    none?: ShippingMethodWhereInput
  }

  export type ShippingZoneListRelationFilter = {
    every?: ShippingZoneWhereInput
    some?: ShippingZoneWhereInput
    none?: ShippingZoneWhereInput
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerGroupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShippingMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShippingZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
    businessName?: SortOrder
    businessType?: SortOrder
    storeBaseCurrency?: SortOrder
    banner?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    website?: SortOrder
    description?: SortOrder
    country?: SortOrder
    address?: SortOrder
    state?: SortOrder
    region?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    status?: SortOrder
    storeTag?: SortOrder
    whitelabel?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    tiktok?: SortOrder
    twitter?: SortOrder
    linkedin?: SortOrder
    currency?: SortOrder
    storeUrl?: SortOrder
    storeApproval?: SortOrder
    modifyProductState?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
    businessName?: SortOrder
    businessType?: SortOrder
    storeBaseCurrency?: SortOrder
    banner?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    website?: SortOrder
    description?: SortOrder
    country?: SortOrder
    address?: SortOrder
    state?: SortOrder
    region?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    status?: SortOrder
    storeTag?: SortOrder
    whitelabel?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    tiktok?: SortOrder
    twitter?: SortOrder
    linkedin?: SortOrder
    currency?: SortOrder
    storeUrl?: SortOrder
    storeApproval?: SortOrder
    modifyProductState?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
    businessName?: SortOrder
    businessType?: SortOrder
    storeBaseCurrency?: SortOrder
    banner?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    website?: SortOrder
    description?: SortOrder
    country?: SortOrder
    address?: SortOrder
    state?: SortOrder
    region?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    status?: SortOrder
    storeTag?: SortOrder
    whitelabel?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    tiktok?: SortOrder
    twitter?: SortOrder
    linkedin?: SortOrder
    currency?: SortOrder
    storeUrl?: SortOrder
    storeApproval?: SortOrder
    modifyProductState?: SortOrder
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettlementCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettlementAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SettlementMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettlementMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettlementSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumShippingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingStatus | EnumShippingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingStatus[] | ListEnumShippingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShippingStatus[] | ListEnumShippingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShippingStatusFilter<$PrismaModel> | $Enums.ShippingStatus
  }

  export type ShippingMethodScalarRelationFilter = {
    is?: ShippingMethodWhereInput
    isNot?: ShippingMethodWhereInput
  }

  export type ShippingAuditListRelationFilter = {
    every?: ShippingAuditWhereInput
    some?: ShippingAuditWhereInput
    none?: ShippingAuditWhereInput
  }

  export type ShippingAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShippingCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    shippingMethodId?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    status?: SortOrder
    estimatedDelivery?: SortOrder
    actualDelivery?: SortOrder
    shippingAddress?: SortOrder
    shippingZoneName?: SortOrder
    shippingFee?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingAvgOrderByAggregateInput = {
    shippingFee?: SortOrder
    weight?: SortOrder
  }

  export type ShippingMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    shippingMethodId?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    status?: SortOrder
    estimatedDelivery?: SortOrder
    actualDelivery?: SortOrder
    shippingAddress?: SortOrder
    shippingZoneName?: SortOrder
    shippingFee?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    shippingMethodId?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    status?: SortOrder
    estimatedDelivery?: SortOrder
    actualDelivery?: SortOrder
    shippingAddress?: SortOrder
    shippingZoneName?: SortOrder
    shippingFee?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingSumOrderByAggregateInput = {
    shippingFee?: SortOrder
    weight?: SortOrder
  }

  export type EnumShippingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingStatus | EnumShippingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingStatus[] | ListEnumShippingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShippingStatus[] | ListEnumShippingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShippingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShippingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShippingStatusFilter<$PrismaModel>
    _max?: NestedEnumShippingStatusFilter<$PrismaModel>
  }

  export type ShippingListRelationFilter = {
    every?: ShippingWhereInput
    some?: ShippingWhereInput
    none?: ShippingWhereInput
  }

  export type ShippingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShippingMethodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    description?: SortOrder
    carrier?: SortOrder
    deliveryTime?: SortOrder
    baseCost?: SortOrder
    costCalculation?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingMethodAvgOrderByAggregateInput = {
    baseCost?: SortOrder
  }

  export type ShippingMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    description?: SortOrder
    carrier?: SortOrder
    deliveryTime?: SortOrder
    baseCost?: SortOrder
    costCalculation?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingMethodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    description?: SortOrder
    carrier?: SortOrder
    deliveryTime?: SortOrder
    baseCost?: SortOrder
    costCalculation?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingMethodSumOrderByAggregateInput = {
    baseCost?: SortOrder
  }

  export type ShippingZoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    countries?: SortOrder
    regions?: SortOrder
    postalCodes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingZoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ShippingScalarRelationFilter = {
    is?: ShippingWhereInput
    isNot?: ShippingWhereInput
  }

  export type ShippingAuditCountOrderByAggregateInput = {
    id?: SortOrder
    shippingId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    metadata?: SortOrder
  }

  export type ShippingAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    shippingId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ShippingAuditMinOrderByAggregateInput = {
    id?: SortOrder
    shippingId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    customersId?: SortOrder
    customersCode?: SortOrder
    storeId?: SortOrder
    authorizationCode?: SortOrder
    status?: SortOrder
    cardType?: SortOrder
    cardBank?: SortOrder
    cardBrand?: SortOrder
    countryCode?: SortOrder
    accountName?: SortOrder
    cardBin?: SortOrder
    cardLast4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    interval?: SortOrder
    emailToken?: SortOrder
    startDate?: SortOrder
    endsAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    customersId?: SortOrder
    cardBin?: SortOrder
    cardLast4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    customersId?: SortOrder
    customersCode?: SortOrder
    storeId?: SortOrder
    authorizationCode?: SortOrder
    status?: SortOrder
    cardType?: SortOrder
    cardBank?: SortOrder
    cardBrand?: SortOrder
    countryCode?: SortOrder
    accountName?: SortOrder
    cardBin?: SortOrder
    cardLast4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    interval?: SortOrder
    emailToken?: SortOrder
    startDate?: SortOrder
    endsAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    channel?: SortOrder
    customersId?: SortOrder
    customersCode?: SortOrder
    storeId?: SortOrder
    authorizationCode?: SortOrder
    status?: SortOrder
    cardType?: SortOrder
    cardBank?: SortOrder
    cardBrand?: SortOrder
    countryCode?: SortOrder
    accountName?: SortOrder
    cardBin?: SortOrder
    cardLast4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
    interval?: SortOrder
    emailToken?: SortOrder
    startDate?: SortOrder
    endsAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    customersId?: SortOrder
    cardBin?: SortOrder
    cardLast4?: SortOrder
    expMonth?: SortOrder
    expYear?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    plansName?: SortOrder
    plansCode?: SortOrder
    plansId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    id?: SortOrder
    plansId?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    plansName?: SortOrder
    plansCode?: SortOrder
    plansId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    plansName?: SortOrder
    plansCode?: SortOrder
    plansId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    id?: SortOrder
    plansId?: SortOrder
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WarehouseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDefaultLocation?: SortOrder
    staffId?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDefaultLocation?: SortOrder
    staffId?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDefaultLocation?: SortOrder
    staffId?: SortOrder
    storeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseScalarRelationFilter = {
    is?: WarehouseWhereInput
    isNot?: WarehouseWhereInput
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CartItemCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type OrderCreateNestedOneWithoutCartInput = {
    create?: XOR<OrderCreateWithoutCartInput, OrderUncheckedCreateWithoutCartInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCartInput
    connect?: OrderWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutCartsInput = {
    create?: XOR<CustomerCreateWithoutCartsInput, CustomerUncheckedCreateWithoutCartsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCartsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CartItemUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CartItemUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type OrderUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<OrderCreateWithoutCartInput, OrderUncheckedCreateWithoutCartInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCartInput
    upsert?: OrderUpsertWithoutCartInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutCartInput, OrderUpdateWithoutCartInput>, OrderUncheckedUpdateWithoutCartInput>
  }

  export type CustomerUpdateOneRequiredWithoutCartsNestedInput = {
    create?: XOR<CustomerCreateWithoutCartsInput, CustomerUncheckedCreateWithoutCartsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCartsInput
    upsert?: CustomerUpsertWithoutCartsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCartsInput, CustomerUpdateWithoutCartsInput>, CustomerUncheckedUpdateWithoutCartsInput>
  }

  export type CartItemUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<CartCreateWithoutCartItemsInput, CartUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutCartItemsInput
    connect?: CartWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CartUpdateOneRequiredWithoutCartItemsNestedInput = {
    create?: XOR<CartCreateWithoutCartItemsInput, CartUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutCartItemsInput
    upsert?: CartUpsertWithoutCartItemsInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutCartItemsInput, CartUpdateWithoutCartItemsInput>, CartUncheckedUpdateWithoutCartItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutCartItemsNestedInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    upsert?: ProductUpsertWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCartItemsInput, ProductUpdateWithoutCartItemsInput>, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CartCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput> | CartCreateWithoutCustomerInput[] | CartUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CartCreateOrConnectWithoutCustomerInput | CartCreateOrConnectWithoutCustomerInput[]
    createMany?: CartCreateManyCustomerInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type PurchaseHistoryCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PurchaseHistoryCreateWithoutCustomerInput, PurchaseHistoryUncheckedCreateWithoutCustomerInput> | PurchaseHistoryCreateWithoutCustomerInput[] | PurchaseHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutCustomerInput | PurchaseHistoryCreateOrConnectWithoutCustomerInput[]
    createMany?: PurchaseHistoryCreateManyCustomerInputEnvelope
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
  }

  export type POSCreateNestedManyWithoutCustomerInput = {
    create?: XOR<POSCreateWithoutCustomerInput, POSUncheckedCreateWithoutCustomerInput> | POSCreateWithoutCustomerInput[] | POSUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: POSCreateOrConnectWithoutCustomerInput | POSCreateOrConnectWithoutCustomerInput[]
    createMany?: POSCreateManyCustomerInputEnvelope
    connect?: POSWhereUniqueInput | POSWhereUniqueInput[]
  }

  export type CustomerGroupMemberCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerGroupMemberCreateWithoutCustomerInput, CustomerGroupMemberUncheckedCreateWithoutCustomerInput> | CustomerGroupMemberCreateWithoutCustomerInput[] | CustomerGroupMemberUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerGroupMemberCreateOrConnectWithoutCustomerInput | CustomerGroupMemberCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerGroupMemberCreateManyCustomerInputEnvelope
    connect?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutCustomerInput = {
    create?: XOR<OrganizationCreateWithoutCustomerInput, OrganizationUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCustomerInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CartUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput> | CartCreateWithoutCustomerInput[] | CartUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CartCreateOrConnectWithoutCustomerInput | CartCreateOrConnectWithoutCustomerInput[]
    createMany?: CartCreateManyCustomerInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type PurchaseHistoryUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PurchaseHistoryCreateWithoutCustomerInput, PurchaseHistoryUncheckedCreateWithoutCustomerInput> | PurchaseHistoryCreateWithoutCustomerInput[] | PurchaseHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutCustomerInput | PurchaseHistoryCreateOrConnectWithoutCustomerInput[]
    createMany?: PurchaseHistoryCreateManyCustomerInputEnvelope
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
  }

  export type POSUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<POSCreateWithoutCustomerInput, POSUncheckedCreateWithoutCustomerInput> | POSCreateWithoutCustomerInput[] | POSUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: POSCreateOrConnectWithoutCustomerInput | POSCreateOrConnectWithoutCustomerInput[]
    createMany?: POSCreateManyCustomerInputEnvelope
    connect?: POSWhereUniqueInput | POSWhereUniqueInput[]
  }

  export type CustomerGroupMemberUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerGroupMemberCreateWithoutCustomerInput, CustomerGroupMemberUncheckedCreateWithoutCustomerInput> | CustomerGroupMemberCreateWithoutCustomerInput[] | CustomerGroupMemberUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerGroupMemberCreateOrConnectWithoutCustomerInput | CustomerGroupMemberCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerGroupMemberCreateManyCustomerInputEnvelope
    connect?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumCustomerTypeFieldUpdateOperationsInput = {
    set?: $Enums.CustomerType
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CartUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput> | CartCreateWithoutCustomerInput[] | CartUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CartCreateOrConnectWithoutCustomerInput | CartCreateOrConnectWithoutCustomerInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutCustomerInput | CartUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CartCreateManyCustomerInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutCustomerInput | CartUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CartUpdateManyWithWhereWithoutCustomerInput | CartUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type PurchaseHistoryUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PurchaseHistoryCreateWithoutCustomerInput, PurchaseHistoryUncheckedCreateWithoutCustomerInput> | PurchaseHistoryCreateWithoutCustomerInput[] | PurchaseHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutCustomerInput | PurchaseHistoryCreateOrConnectWithoutCustomerInput[]
    upsert?: PurchaseHistoryUpsertWithWhereUniqueWithoutCustomerInput | PurchaseHistoryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PurchaseHistoryCreateManyCustomerInputEnvelope
    set?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    disconnect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    delete?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    update?: PurchaseHistoryUpdateWithWhereUniqueWithoutCustomerInput | PurchaseHistoryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PurchaseHistoryUpdateManyWithWhereWithoutCustomerInput | PurchaseHistoryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
  }

  export type POSUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<POSCreateWithoutCustomerInput, POSUncheckedCreateWithoutCustomerInput> | POSCreateWithoutCustomerInput[] | POSUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: POSCreateOrConnectWithoutCustomerInput | POSCreateOrConnectWithoutCustomerInput[]
    upsert?: POSUpsertWithWhereUniqueWithoutCustomerInput | POSUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: POSCreateManyCustomerInputEnvelope
    set?: POSWhereUniqueInput | POSWhereUniqueInput[]
    disconnect?: POSWhereUniqueInput | POSWhereUniqueInput[]
    delete?: POSWhereUniqueInput | POSWhereUniqueInput[]
    connect?: POSWhereUniqueInput | POSWhereUniqueInput[]
    update?: POSUpdateWithWhereUniqueWithoutCustomerInput | POSUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: POSUpdateManyWithWhereWithoutCustomerInput | POSUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: POSScalarWhereInput | POSScalarWhereInput[]
  }

  export type CustomerGroupMemberUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerGroupMemberCreateWithoutCustomerInput, CustomerGroupMemberUncheckedCreateWithoutCustomerInput> | CustomerGroupMemberCreateWithoutCustomerInput[] | CustomerGroupMemberUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerGroupMemberCreateOrConnectWithoutCustomerInput | CustomerGroupMemberCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerGroupMemberUpsertWithWhereUniqueWithoutCustomerInput | CustomerGroupMemberUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerGroupMemberCreateManyCustomerInputEnvelope
    set?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    disconnect?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    delete?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    connect?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    update?: CustomerGroupMemberUpdateWithWhereUniqueWithoutCustomerInput | CustomerGroupMemberUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerGroupMemberUpdateManyWithWhereWithoutCustomerInput | CustomerGroupMemberUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerGroupMemberScalarWhereInput | CustomerGroupMemberScalarWhereInput[]
  }

  export type OrganizationUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<OrganizationCreateWithoutCustomerInput, OrganizationUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCustomerInput
    upsert?: OrganizationUpsertWithoutCustomerInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutCustomerInput, OrganizationUpdateWithoutCustomerInput>, OrganizationUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CartUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput> | CartCreateWithoutCustomerInput[] | CartUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CartCreateOrConnectWithoutCustomerInput | CartCreateOrConnectWithoutCustomerInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutCustomerInput | CartUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CartCreateManyCustomerInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutCustomerInput | CartUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CartUpdateManyWithWhereWithoutCustomerInput | CartUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type PurchaseHistoryUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PurchaseHistoryCreateWithoutCustomerInput, PurchaseHistoryUncheckedCreateWithoutCustomerInput> | PurchaseHistoryCreateWithoutCustomerInput[] | PurchaseHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutCustomerInput | PurchaseHistoryCreateOrConnectWithoutCustomerInput[]
    upsert?: PurchaseHistoryUpsertWithWhereUniqueWithoutCustomerInput | PurchaseHistoryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PurchaseHistoryCreateManyCustomerInputEnvelope
    set?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    disconnect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    delete?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    update?: PurchaseHistoryUpdateWithWhereUniqueWithoutCustomerInput | PurchaseHistoryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PurchaseHistoryUpdateManyWithWhereWithoutCustomerInput | PurchaseHistoryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
  }

  export type POSUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<POSCreateWithoutCustomerInput, POSUncheckedCreateWithoutCustomerInput> | POSCreateWithoutCustomerInput[] | POSUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: POSCreateOrConnectWithoutCustomerInput | POSCreateOrConnectWithoutCustomerInput[]
    upsert?: POSUpsertWithWhereUniqueWithoutCustomerInput | POSUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: POSCreateManyCustomerInputEnvelope
    set?: POSWhereUniqueInput | POSWhereUniqueInput[]
    disconnect?: POSWhereUniqueInput | POSWhereUniqueInput[]
    delete?: POSWhereUniqueInput | POSWhereUniqueInput[]
    connect?: POSWhereUniqueInput | POSWhereUniqueInput[]
    update?: POSUpdateWithWhereUniqueWithoutCustomerInput | POSUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: POSUpdateManyWithWhereWithoutCustomerInput | POSUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: POSScalarWhereInput | POSScalarWhereInput[]
  }

  export type CustomerGroupMemberUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerGroupMemberCreateWithoutCustomerInput, CustomerGroupMemberUncheckedCreateWithoutCustomerInput> | CustomerGroupMemberCreateWithoutCustomerInput[] | CustomerGroupMemberUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerGroupMemberCreateOrConnectWithoutCustomerInput | CustomerGroupMemberCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerGroupMemberUpsertWithWhereUniqueWithoutCustomerInput | CustomerGroupMemberUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerGroupMemberCreateManyCustomerInputEnvelope
    set?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    disconnect?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    delete?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    connect?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    update?: CustomerGroupMemberUpdateWithWhereUniqueWithoutCustomerInput | CustomerGroupMemberUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerGroupMemberUpdateManyWithWhereWithoutCustomerInput | CustomerGroupMemberUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerGroupMemberScalarWhereInput | CustomerGroupMemberScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutPurchaseHistoryInput = {
    create?: XOR<CustomerCreateWithoutPurchaseHistoryInput, CustomerUncheckedCreateWithoutPurchaseHistoryInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPurchaseHistoryInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutPurchaseHistoryNestedInput = {
    create?: XOR<CustomerCreateWithoutPurchaseHistoryInput, CustomerUncheckedCreateWithoutPurchaseHistoryInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPurchaseHistoryInput
    upsert?: CustomerUpsertWithoutPurchaseHistoryInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPurchaseHistoryInput, CustomerUpdateWithoutPurchaseHistoryInput>, CustomerUncheckedUpdateWithoutPurchaseHistoryInput>
  }

  export type OrganizationCreateNestedOneWithoutCustomerGroupsInput = {
    create?: XOR<OrganizationCreateWithoutCustomerGroupsInput, OrganizationUncheckedCreateWithoutCustomerGroupsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCustomerGroupsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CustomerGroupMemberCreateNestedManyWithoutCustomerGroupInput = {
    create?: XOR<CustomerGroupMemberCreateWithoutCustomerGroupInput, CustomerGroupMemberUncheckedCreateWithoutCustomerGroupInput> | CustomerGroupMemberCreateWithoutCustomerGroupInput[] | CustomerGroupMemberUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: CustomerGroupMemberCreateOrConnectWithoutCustomerGroupInput | CustomerGroupMemberCreateOrConnectWithoutCustomerGroupInput[]
    createMany?: CustomerGroupMemberCreateManyCustomerGroupInputEnvelope
    connect?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
  }

  export type CustomerGroupMemberUncheckedCreateNestedManyWithoutCustomerGroupInput = {
    create?: XOR<CustomerGroupMemberCreateWithoutCustomerGroupInput, CustomerGroupMemberUncheckedCreateWithoutCustomerGroupInput> | CustomerGroupMemberCreateWithoutCustomerGroupInput[] | CustomerGroupMemberUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: CustomerGroupMemberCreateOrConnectWithoutCustomerGroupInput | CustomerGroupMemberCreateOrConnectWithoutCustomerGroupInput[]
    createMany?: CustomerGroupMemberCreateManyCustomerGroupInputEnvelope
    connect?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutCustomerGroupsNestedInput = {
    create?: XOR<OrganizationCreateWithoutCustomerGroupsInput, OrganizationUncheckedCreateWithoutCustomerGroupsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCustomerGroupsInput
    upsert?: OrganizationUpsertWithoutCustomerGroupsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutCustomerGroupsInput, OrganizationUpdateWithoutCustomerGroupsInput>, OrganizationUncheckedUpdateWithoutCustomerGroupsInput>
  }

  export type CustomerGroupMemberUpdateManyWithoutCustomerGroupNestedInput = {
    create?: XOR<CustomerGroupMemberCreateWithoutCustomerGroupInput, CustomerGroupMemberUncheckedCreateWithoutCustomerGroupInput> | CustomerGroupMemberCreateWithoutCustomerGroupInput[] | CustomerGroupMemberUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: CustomerGroupMemberCreateOrConnectWithoutCustomerGroupInput | CustomerGroupMemberCreateOrConnectWithoutCustomerGroupInput[]
    upsert?: CustomerGroupMemberUpsertWithWhereUniqueWithoutCustomerGroupInput | CustomerGroupMemberUpsertWithWhereUniqueWithoutCustomerGroupInput[]
    createMany?: CustomerGroupMemberCreateManyCustomerGroupInputEnvelope
    set?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    disconnect?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    delete?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    connect?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    update?: CustomerGroupMemberUpdateWithWhereUniqueWithoutCustomerGroupInput | CustomerGroupMemberUpdateWithWhereUniqueWithoutCustomerGroupInput[]
    updateMany?: CustomerGroupMemberUpdateManyWithWhereWithoutCustomerGroupInput | CustomerGroupMemberUpdateManyWithWhereWithoutCustomerGroupInput[]
    deleteMany?: CustomerGroupMemberScalarWhereInput | CustomerGroupMemberScalarWhereInput[]
  }

  export type CustomerGroupMemberUncheckedUpdateManyWithoutCustomerGroupNestedInput = {
    create?: XOR<CustomerGroupMemberCreateWithoutCustomerGroupInput, CustomerGroupMemberUncheckedCreateWithoutCustomerGroupInput> | CustomerGroupMemberCreateWithoutCustomerGroupInput[] | CustomerGroupMemberUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: CustomerGroupMemberCreateOrConnectWithoutCustomerGroupInput | CustomerGroupMemberCreateOrConnectWithoutCustomerGroupInput[]
    upsert?: CustomerGroupMemberUpsertWithWhereUniqueWithoutCustomerGroupInput | CustomerGroupMemberUpsertWithWhereUniqueWithoutCustomerGroupInput[]
    createMany?: CustomerGroupMemberCreateManyCustomerGroupInputEnvelope
    set?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    disconnect?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    delete?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    connect?: CustomerGroupMemberWhereUniqueInput | CustomerGroupMemberWhereUniqueInput[]
    update?: CustomerGroupMemberUpdateWithWhereUniqueWithoutCustomerGroupInput | CustomerGroupMemberUpdateWithWhereUniqueWithoutCustomerGroupInput[]
    updateMany?: CustomerGroupMemberUpdateManyWithWhereWithoutCustomerGroupInput | CustomerGroupMemberUpdateManyWithWhereWithoutCustomerGroupInput[]
    deleteMany?: CustomerGroupMemberScalarWhereInput | CustomerGroupMemberScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutCustomerGroupMemberInput = {
    create?: XOR<CustomerCreateWithoutCustomerGroupMemberInput, CustomerUncheckedCreateWithoutCustomerGroupMemberInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerGroupMemberInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerGroupsCreateNestedOneWithoutCustomerGroupMemberInput = {
    create?: XOR<CustomerGroupsCreateWithoutCustomerGroupMemberInput, CustomerGroupsUncheckedCreateWithoutCustomerGroupMemberInput>
    connectOrCreate?: CustomerGroupsCreateOrConnectWithoutCustomerGroupMemberInput
    connect?: CustomerGroupsWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCustomerGroupMemberNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerGroupMemberInput, CustomerUncheckedCreateWithoutCustomerGroupMemberInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerGroupMemberInput
    upsert?: CustomerUpsertWithoutCustomerGroupMemberInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerGroupMemberInput, CustomerUpdateWithoutCustomerGroupMemberInput>, CustomerUncheckedUpdateWithoutCustomerGroupMemberInput>
  }

  export type CustomerGroupsUpdateOneRequiredWithoutCustomerGroupMemberNestedInput = {
    create?: XOR<CustomerGroupsCreateWithoutCustomerGroupMemberInput, CustomerGroupsUncheckedCreateWithoutCustomerGroupMemberInput>
    connectOrCreate?: CustomerGroupsCreateOrConnectWithoutCustomerGroupMemberInput
    upsert?: CustomerGroupsUpsertWithoutCustomerGroupMemberInput
    connect?: CustomerGroupsWhereUniqueInput
    update?: XOR<XOR<CustomerGroupsUpdateToOneWithWhereWithoutCustomerGroupMemberInput, CustomerGroupsUpdateWithoutCustomerGroupMemberInput>, CustomerGroupsUncheckedUpdateWithoutCustomerGroupMemberInput>
  }

  export type ExpenseCategoryCreateNestedManyWithoutExpenseInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpenseInput, ExpenseCategoryUncheckedCreateWithoutExpenseInput> | ExpenseCategoryCreateWithoutExpenseInput[] | ExpenseCategoryUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpenseInput | ExpenseCategoryCreateOrConnectWithoutExpenseInput[]
    createMany?: ExpenseCategoryCreateManyExpenseInputEnvelope
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutExpenseInput = {
    create?: XOR<OrganizationCreateWithoutExpenseInput, OrganizationUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutExpenseInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ExpenseCategoryUncheckedCreateNestedManyWithoutExpenseInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpenseInput, ExpenseCategoryUncheckedCreateWithoutExpenseInput> | ExpenseCategoryCreateWithoutExpenseInput[] | ExpenseCategoryUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpenseInput | ExpenseCategoryCreateOrConnectWithoutExpenseInput[]
    createMany?: ExpenseCategoryCreateManyExpenseInputEnvelope
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ExpenseCategoryUpdateManyWithoutExpenseNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpenseInput, ExpenseCategoryUncheckedCreateWithoutExpenseInput> | ExpenseCategoryCreateWithoutExpenseInput[] | ExpenseCategoryUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpenseInput | ExpenseCategoryCreateOrConnectWithoutExpenseInput[]
    upsert?: ExpenseCategoryUpsertWithWhereUniqueWithoutExpenseInput | ExpenseCategoryUpsertWithWhereUniqueWithoutExpenseInput[]
    createMany?: ExpenseCategoryCreateManyExpenseInputEnvelope
    set?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    disconnect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    delete?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    update?: ExpenseCategoryUpdateWithWhereUniqueWithoutExpenseInput | ExpenseCategoryUpdateWithWhereUniqueWithoutExpenseInput[]
    updateMany?: ExpenseCategoryUpdateManyWithWhereWithoutExpenseInput | ExpenseCategoryUpdateManyWithWhereWithoutExpenseInput[]
    deleteMany?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutExpenseNestedInput = {
    create?: XOR<OrganizationCreateWithoutExpenseInput, OrganizationUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutExpenseInput
    upsert?: OrganizationUpsertWithoutExpenseInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutExpenseInput, OrganizationUpdateWithoutExpenseInput>, OrganizationUncheckedUpdateWithoutExpenseInput>
  }

  export type ExpenseCategoryUncheckedUpdateManyWithoutExpenseNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpenseInput, ExpenseCategoryUncheckedCreateWithoutExpenseInput> | ExpenseCategoryCreateWithoutExpenseInput[] | ExpenseCategoryUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpenseInput | ExpenseCategoryCreateOrConnectWithoutExpenseInput[]
    upsert?: ExpenseCategoryUpsertWithWhereUniqueWithoutExpenseInput | ExpenseCategoryUpsertWithWhereUniqueWithoutExpenseInput[]
    createMany?: ExpenseCategoryCreateManyExpenseInputEnvelope
    set?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    disconnect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    delete?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    update?: ExpenseCategoryUpdateWithWhereUniqueWithoutExpenseInput | ExpenseCategoryUpdateWithWhereUniqueWithoutExpenseInput[]
    updateMany?: ExpenseCategoryUpdateManyWithWhereWithoutExpenseInput | ExpenseCategoryUpdateManyWithWhereWithoutExpenseInput[]
    deleteMany?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
  }

  export type ExpenseCreateNestedOneWithoutExpenseCategoryInput = {
    create?: XOR<ExpenseCreateWithoutExpenseCategoryInput, ExpenseUncheckedCreateWithoutExpenseCategoryInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutExpenseCategoryInput
    connect?: ExpenseWhereUniqueInput
  }

  export type ExpenseUpdateOneRequiredWithoutExpenseCategoryNestedInput = {
    create?: XOR<ExpenseCreateWithoutExpenseCategoryInput, ExpenseUncheckedCreateWithoutExpenseCategoryInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutExpenseCategoryInput
    upsert?: ExpenseUpsertWithoutExpenseCategoryInput
    connect?: ExpenseWhereUniqueInput
    update?: XOR<XOR<ExpenseUpdateToOneWithWhereWithoutExpenseCategoryInput, ExpenseUpdateWithoutExpenseCategoryInput>, ExpenseUncheckedUpdateWithoutExpenseCategoryInput>
  }

  export type OrganizationCreateNestedOneWithoutBankDetailsInput = {
    create?: XOR<OrganizationCreateWithoutBankDetailsInput, OrganizationUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutBankDetailsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutBankDetailsNestedInput = {
    create?: XOR<OrganizationCreateWithoutBankDetailsInput, OrganizationUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutBankDetailsInput
    upsert?: OrganizationUpsertWithoutBankDetailsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutBankDetailsInput, OrganizationUpdateWithoutBankDetailsInput>, OrganizationUncheckedUpdateWithoutBankDetailsInput>
  }

  export type OrganizationCreateNestedOneWithoutWalletInput = {
    create?: XOR<OrganizationCreateWithoutWalletInput, OrganizationUncheckedCreateWithoutWalletInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutWalletInput
    connect?: OrganizationWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type OrganizationUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<OrganizationCreateWithoutWalletInput, OrganizationUncheckedCreateWithoutWalletInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutWalletInput
    upsert?: OrganizationUpsertWithoutWalletInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutWalletInput, OrganizationUpdateWithoutWalletInput>, OrganizationUncheckedUpdateWithoutWalletInput>
  }

  export type OrganizationCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<OrganizationCreateWithoutInvoiceInput, OrganizationUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvoiceInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<OrganizationCreateWithoutInvoiceInput, OrganizationUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvoiceInput
    upsert?: OrganizationUpsertWithoutInvoiceInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutInvoiceInput, OrganizationUpdateWithoutInvoiceInput>, OrganizationUncheckedUpdateWithoutInvoiceInput>
  }

  export type UserCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutLocationInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutLocationInput = {
    create?: XOR<ProductCreateWithoutLocationInput, ProductUncheckedCreateWithoutLocationInput> | ProductCreateWithoutLocationInput[] | ProductUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLocationInput | ProductCreateOrConnectWithoutLocationInput[]
    createMany?: ProductCreateManyLocationInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutLocationInput = {
    create?: XOR<OrganizationCreateWithoutLocationInput, OrganizationUncheckedCreateWithoutLocationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLocationInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ProductCreateWithoutLocationInput, ProductUncheckedCreateWithoutLocationInput> | ProductCreateWithoutLocationInput[] | ProductUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLocationInput | ProductCreateOrConnectWithoutLocationInput[]
    createMany?: ProductCreateManyLocationInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLocationInput | UserUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLocationInput | UserUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLocationInput | UserUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutLocationNestedInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutLocationInput | OrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutLocationInput | OrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutLocationInput | OrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ProductCreateWithoutLocationInput, ProductUncheckedCreateWithoutLocationInput> | ProductCreateWithoutLocationInput[] | ProductUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLocationInput | ProductCreateOrConnectWithoutLocationInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutLocationInput | ProductUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ProductCreateManyLocationInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutLocationInput | ProductUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutLocationInput | ProductUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutLocationNestedInput = {
    create?: XOR<OrganizationCreateWithoutLocationInput, OrganizationUncheckedCreateWithoutLocationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLocationInput
    upsert?: OrganizationUpsertWithoutLocationInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutLocationInput, OrganizationUpdateWithoutLocationInput>, OrganizationUncheckedUpdateWithoutLocationInput>
  }

  export type UserUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLocationInput | UserUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLocationInput | UserUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLocationInput | UserUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutLocationInput | OrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutLocationInput | OrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutLocationInput | OrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ProductCreateWithoutLocationInput, ProductUncheckedCreateWithoutLocationInput> | ProductCreateWithoutLocationInput[] | ProductUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLocationInput | ProductCreateOrConnectWithoutLocationInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutLocationInput | ProductUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ProductCreateManyLocationInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutLocationInput | ProductUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutLocationInput | ProductUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type POSCreateNestedOneWithoutOrderInput = {
    create?: XOR<POSCreateWithoutOrderInput, POSUncheckedCreateWithoutOrderInput>
    connectOrCreate?: POSCreateOrConnectWithoutOrderInput
    connect?: POSWhereUniqueInput
  }

  export type CartCreateNestedOneWithoutOrderInput = {
    create?: XOR<CartCreateWithoutOrderInput, CartUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CartCreateOrConnectWithoutOrderInput
    connect?: CartWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutOrderInput = {
    create?: XOR<LocationCreateWithoutOrderInput, LocationUncheckedCreateWithoutOrderInput>
    connectOrCreate?: LocationCreateOrConnectWithoutOrderInput
    connect?: LocationWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutOrderInput = {
    create?: XOR<OrganizationCreateWithoutOrderInput, OrganizationUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrderInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type POSUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<POSCreateWithoutOrderInput, POSUncheckedCreateWithoutOrderInput>
    connectOrCreate?: POSCreateOrConnectWithoutOrderInput
    connect?: POSWhereUniqueInput
  }

  export type CartUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<CartCreateWithoutOrderInput, CartUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CartCreateOrConnectWithoutOrderInput
    connect?: CartWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type POSUpdateOneWithoutOrderNestedInput = {
    create?: XOR<POSCreateWithoutOrderInput, POSUncheckedCreateWithoutOrderInput>
    connectOrCreate?: POSCreateOrConnectWithoutOrderInput
    upsert?: POSUpsertWithoutOrderInput
    disconnect?: POSWhereInput | boolean
    delete?: POSWhereInput | boolean
    connect?: POSWhereUniqueInput
    update?: XOR<XOR<POSUpdateToOneWithWhereWithoutOrderInput, POSUpdateWithoutOrderInput>, POSUncheckedUpdateWithoutOrderInput>
  }

  export type CartUpdateOneWithoutOrderNestedInput = {
    create?: XOR<CartCreateWithoutOrderInput, CartUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CartCreateOrConnectWithoutOrderInput
    upsert?: CartUpsertWithoutOrderInput
    disconnect?: CartWhereInput | boolean
    delete?: CartWhereInput | boolean
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutOrderInput, CartUpdateWithoutOrderInput>, CartUncheckedUpdateWithoutOrderInput>
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type LocationUpdateOneWithoutOrderNestedInput = {
    create?: XOR<LocationCreateWithoutOrderInput, LocationUncheckedCreateWithoutOrderInput>
    connectOrCreate?: LocationCreateOrConnectWithoutOrderInput
    upsert?: LocationUpsertWithoutOrderInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutOrderInput, LocationUpdateWithoutOrderInput>, LocationUncheckedUpdateWithoutOrderInput>
  }

  export type OrganizationUpdateOneWithoutOrderNestedInput = {
    create?: XOR<OrganizationCreateWithoutOrderInput, OrganizationUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrderInput
    upsert?: OrganizationUpsertWithoutOrderInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOrderInput, OrganizationUpdateWithoutOrderInput>, OrganizationUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type POSUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<POSCreateWithoutOrderInput, POSUncheckedCreateWithoutOrderInput>
    connectOrCreate?: POSCreateOrConnectWithoutOrderInput
    upsert?: POSUpsertWithoutOrderInput
    disconnect?: POSWhereInput | boolean
    delete?: POSWhereInput | boolean
    connect?: POSWhereUniqueInput
    update?: XOR<XOR<POSUpdateToOneWithWhereWithoutOrderInput, POSUpdateWithoutOrderInput>, POSUncheckedUpdateWithoutOrderInput>
  }

  export type CartUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<CartCreateWithoutOrderInput, CartUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CartCreateOrConnectWithoutOrderInput
    upsert?: CartUpsertWithoutOrderInput
    disconnect?: CartWhereInput | boolean
    delete?: CartWhereInput | boolean
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutOrderInput, CartUpdateWithoutOrderInput>, CartUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderUpsertWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderItemsInput, OrderUpdateWithoutOrderItemsInput>, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type CustomerCreateNestedOneWithoutPosInput = {
    create?: XOR<CustomerCreateWithoutPosInput, CustomerUncheckedCreateWithoutPosInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPosInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPOSInput = {
    create?: XOR<UserCreateWithoutPOSInput, UserUncheckedCreateWithoutPOSInput>
    connectOrCreate?: UserCreateOrConnectWithoutPOSInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPosInput = {
    create?: XOR<OrderCreateWithoutPosInput, OrderUncheckedCreateWithoutPosInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPosInput
    connect?: OrderWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutPosNestedInput = {
    create?: XOR<CustomerCreateWithoutPosInput, CustomerUncheckedCreateWithoutPosInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPosInput
    upsert?: CustomerUpsertWithoutPosInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPosInput, CustomerUpdateWithoutPosInput>, CustomerUncheckedUpdateWithoutPosInput>
  }

  export type UserUpdateOneRequiredWithoutPOSNestedInput = {
    create?: XOR<UserCreateWithoutPOSInput, UserUncheckedCreateWithoutPOSInput>
    connectOrCreate?: UserCreateOrConnectWithoutPOSInput
    upsert?: UserUpsertWithoutPOSInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPOSInput, UserUpdateWithoutPOSInput>, UserUncheckedUpdateWithoutPOSInput>
  }

  export type OrderUpdateOneRequiredWithoutPosNestedInput = {
    create?: XOR<OrderCreateWithoutPosInput, OrderUncheckedCreateWithoutPosInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPosInput
    upsert?: OrderUpsertWithoutPosInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPosInput, OrderUpdateWithoutPosInput>, OrderUncheckedUpdateWithoutPosInput>
  }

  export type OrganizationCreateNestedOneWithoutPointOfSaleInput = {
    create?: XOR<OrganizationCreateWithoutPointOfSaleInput, OrganizationUncheckedCreateWithoutPointOfSaleInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPointOfSaleInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPointOfSaleInput = {
    create?: XOR<UserCreateWithoutPointOfSaleInput, UserUncheckedCreateWithoutPointOfSaleInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointOfSaleInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutPointOfSaleNestedInput = {
    create?: XOR<OrganizationCreateWithoutPointOfSaleInput, OrganizationUncheckedCreateWithoutPointOfSaleInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPointOfSaleInput
    upsert?: OrganizationUpsertWithoutPointOfSaleInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutPointOfSaleInput, OrganizationUpdateWithoutPointOfSaleInput>, OrganizationUncheckedUpdateWithoutPointOfSaleInput>
  }

  export type UserUpdateOneRequiredWithoutPointOfSaleNestedInput = {
    create?: XOR<UserCreateWithoutPointOfSaleInput, UserUncheckedCreateWithoutPointOfSaleInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointOfSaleInput
    upsert?: UserUpsertWithoutPointOfSaleInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPointOfSaleInput, UserUpdateWithoutPointOfSaleInput>, UserUncheckedUpdateWithoutPointOfSaleInput>
  }

  export type ProductCreateimageUrlInput = {
    set: string[]
  }

  export type FeaturedBrandsCreateNestedManyWithoutProductInput = {
    create?: XOR<FeaturedBrandsCreateWithoutProductInput, FeaturedBrandsUncheckedCreateWithoutProductInput> | FeaturedBrandsCreateWithoutProductInput[] | FeaturedBrandsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FeaturedBrandsCreateOrConnectWithoutProductInput | FeaturedBrandsCreateOrConnectWithoutProductInput[]
    createMany?: FeaturedBrandsCreateManyProductInputEnvelope
    connect?: FeaturedBrandsWhereUniqueInput | FeaturedBrandsWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type ProductVariationCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariationCreateWithoutProductInput, ProductVariationUncheckedCreateWithoutProductInput> | ProductVariationCreateWithoutProductInput[] | ProductVariationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariationCreateOrConnectWithoutProductInput | ProductVariationCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariationCreateManyProductInputEnvelope
    connect?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type ProductCollectionCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCollectionCreateWithoutProductsInput, ProductCollectionUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCollectionCreateOrConnectWithoutProductsInput
    connect?: ProductCollectionWhereUniqueInput
  }

  export type PurchaseCreateNestedOneWithoutProductsInput = {
    create?: XOR<PurchaseCreateWithoutProductsInput, PurchaseUncheckedCreateWithoutProductsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutProductInput = {
    create?: XOR<OrganizationCreateWithoutProductInput, OrganizationUncheckedCreateWithoutProductInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProductInput
    connect?: OrganizationWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutInventoryInput = {
    create?: XOR<WarehouseCreateWithoutInventoryInput, WarehouseUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryInput
    connect?: WarehouseWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutProductInput = {
    create?: XOR<LocationCreateWithoutProductInput, LocationUncheckedCreateWithoutProductInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProductInput
    connect?: LocationWhereUniqueInput
  }

  export type FeaturedBrandsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<FeaturedBrandsCreateWithoutProductInput, FeaturedBrandsUncheckedCreateWithoutProductInput> | FeaturedBrandsCreateWithoutProductInput[] | FeaturedBrandsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FeaturedBrandsCreateOrConnectWithoutProductInput | FeaturedBrandsCreateOrConnectWithoutProductInput[]
    createMany?: FeaturedBrandsCreateManyProductInputEnvelope
    connect?: FeaturedBrandsWhereUniqueInput | FeaturedBrandsWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type ProductVariationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariationCreateWithoutProductInput, ProductVariationUncheckedCreateWithoutProductInput> | ProductVariationCreateWithoutProductInput[] | ProductVariationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariationCreateOrConnectWithoutProductInput | ProductVariationCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariationCreateManyProductInputEnvelope
    connect?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumProductStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductStatus | null
  }

  export type ProductUpdateimageUrlInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FeaturedBrandsUpdateManyWithoutProductNestedInput = {
    create?: XOR<FeaturedBrandsCreateWithoutProductInput, FeaturedBrandsUncheckedCreateWithoutProductInput> | FeaturedBrandsCreateWithoutProductInput[] | FeaturedBrandsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FeaturedBrandsCreateOrConnectWithoutProductInput | FeaturedBrandsCreateOrConnectWithoutProductInput[]
    upsert?: FeaturedBrandsUpsertWithWhereUniqueWithoutProductInput | FeaturedBrandsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: FeaturedBrandsCreateManyProductInputEnvelope
    set?: FeaturedBrandsWhereUniqueInput | FeaturedBrandsWhereUniqueInput[]
    disconnect?: FeaturedBrandsWhereUniqueInput | FeaturedBrandsWhereUniqueInput[]
    delete?: FeaturedBrandsWhereUniqueInput | FeaturedBrandsWhereUniqueInput[]
    connect?: FeaturedBrandsWhereUniqueInput | FeaturedBrandsWhereUniqueInput[]
    update?: FeaturedBrandsUpdateWithWhereUniqueWithoutProductInput | FeaturedBrandsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: FeaturedBrandsUpdateManyWithWhereWithoutProductInput | FeaturedBrandsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: FeaturedBrandsScalarWhereInput | FeaturedBrandsScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type ProductVariationUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariationCreateWithoutProductInput, ProductVariationUncheckedCreateWithoutProductInput> | ProductVariationCreateWithoutProductInput[] | ProductVariationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariationCreateOrConnectWithoutProductInput | ProductVariationCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariationUpsertWithWhereUniqueWithoutProductInput | ProductVariationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariationCreateManyProductInputEnvelope
    set?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    disconnect?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    delete?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    connect?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    update?: ProductVariationUpdateWithWhereUniqueWithoutProductInput | ProductVariationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariationUpdateManyWithWhereWithoutProductInput | ProductVariationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariationScalarWhereInput | ProductVariationScalarWhereInput[]
  }

  export type ProductCategoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutProductInput | ProductCategoryUpsertWithWhereUniqueWithoutProductInput[]
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutProductInput | ProductCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutProductInput | ProductCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutProductInput | InventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutProductInput | InventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutProductInput | InventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type ProductCollectionUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ProductCollectionCreateWithoutProductsInput, ProductCollectionUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCollectionCreateOrConnectWithoutProductsInput
    upsert?: ProductCollectionUpsertWithoutProductsInput
    disconnect?: ProductCollectionWhereInput | boolean
    delete?: ProductCollectionWhereInput | boolean
    connect?: ProductCollectionWhereUniqueInput
    update?: XOR<XOR<ProductCollectionUpdateToOneWithWhereWithoutProductsInput, ProductCollectionUpdateWithoutProductsInput>, ProductCollectionUncheckedUpdateWithoutProductsInput>
  }

  export type PurchaseUpdateOneWithoutProductsNestedInput = {
    create?: XOR<PurchaseCreateWithoutProductsInput, PurchaseUncheckedCreateWithoutProductsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductsInput
    upsert?: PurchaseUpsertWithoutProductsInput
    disconnect?: PurchaseWhereInput | boolean
    delete?: PurchaseWhereInput | boolean
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutProductsInput, PurchaseUpdateWithoutProductsInput>, PurchaseUncheckedUpdateWithoutProductsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<OrganizationCreateWithoutProductInput, OrganizationUncheckedCreateWithoutProductInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProductInput
    upsert?: OrganizationUpsertWithoutProductInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutProductInput, OrganizationUpdateWithoutProductInput>, OrganizationUncheckedUpdateWithoutProductInput>
  }

  export type WarehouseUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<WarehouseCreateWithoutInventoryInput, WarehouseUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryInput
    upsert?: WarehouseUpsertWithoutInventoryInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutInventoryInput, WarehouseUpdateWithoutInventoryInput>, WarehouseUncheckedUpdateWithoutInventoryInput>
  }

  export type LocationUpdateOneWithoutProductNestedInput = {
    create?: XOR<LocationCreateWithoutProductInput, LocationUncheckedCreateWithoutProductInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProductInput
    upsert?: LocationUpsertWithoutProductInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutProductInput, LocationUpdateWithoutProductInput>, LocationUncheckedUpdateWithoutProductInput>
  }

  export type FeaturedBrandsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<FeaturedBrandsCreateWithoutProductInput, FeaturedBrandsUncheckedCreateWithoutProductInput> | FeaturedBrandsCreateWithoutProductInput[] | FeaturedBrandsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FeaturedBrandsCreateOrConnectWithoutProductInput | FeaturedBrandsCreateOrConnectWithoutProductInput[]
    upsert?: FeaturedBrandsUpsertWithWhereUniqueWithoutProductInput | FeaturedBrandsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: FeaturedBrandsCreateManyProductInputEnvelope
    set?: FeaturedBrandsWhereUniqueInput | FeaturedBrandsWhereUniqueInput[]
    disconnect?: FeaturedBrandsWhereUniqueInput | FeaturedBrandsWhereUniqueInput[]
    delete?: FeaturedBrandsWhereUniqueInput | FeaturedBrandsWhereUniqueInput[]
    connect?: FeaturedBrandsWhereUniqueInput | FeaturedBrandsWhereUniqueInput[]
    update?: FeaturedBrandsUpdateWithWhereUniqueWithoutProductInput | FeaturedBrandsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: FeaturedBrandsUpdateManyWithWhereWithoutProductInput | FeaturedBrandsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: FeaturedBrandsScalarWhereInput | FeaturedBrandsScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type ProductVariationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariationCreateWithoutProductInput, ProductVariationUncheckedCreateWithoutProductInput> | ProductVariationCreateWithoutProductInput[] | ProductVariationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariationCreateOrConnectWithoutProductInput | ProductVariationCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariationUpsertWithWhereUniqueWithoutProductInput | ProductVariationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariationCreateManyProductInputEnvelope
    set?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    disconnect?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    delete?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    connect?: ProductVariationWhereUniqueInput | ProductVariationWhereUniqueInput[]
    update?: ProductVariationUpdateWithWhereUniqueWithoutProductInput | ProductVariationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariationUpdateManyWithWhereWithoutProductInput | ProductVariationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariationScalarWhereInput | ProductVariationScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutProductInput | ProductCategoryUpsertWithWhereUniqueWithoutProductInput[]
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutProductInput | ProductCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutProductInput | ProductCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutProductInput | InventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutProductInput | InventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutProductInput | InventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutProductCategoryInput = {
    create?: XOR<OrganizationCreateWithoutProductCategoryInput, OrganizationUncheckedCreateWithoutProductCategoryInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProductCategoryInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductCategoryInput | ProductUpsertWithWhereUniqueWithoutProductCategoryInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductCategoryInput | ProductUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductCategoryInput | ProductUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutProductCategoryNestedInput = {
    create?: XOR<OrganizationCreateWithoutProductCategoryInput, OrganizationUncheckedCreateWithoutProductCategoryInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProductCategoryInput
    upsert?: OrganizationUpsertWithoutProductCategoryInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutProductCategoryInput, OrganizationUpdateWithoutProductCategoryInput>, OrganizationUncheckedUpdateWithoutProductCategoryInput>
  }

  export type ProductUncheckedUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductCategoryInput | ProductUpsertWithWhereUniqueWithoutProductCategoryInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductCategoryInput | ProductUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductCategoryInput | ProductUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCollectionInput = {
    create?: XOR<ProductCreateWithoutCollectionInput, ProductUncheckedCreateWithoutCollectionInput> | ProductCreateWithoutCollectionInput[] | ProductUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCollectionInput | ProductCreateOrConnectWithoutCollectionInput[]
    createMany?: ProductCreateManyCollectionInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<ProductCreateWithoutCollectionInput, ProductUncheckedCreateWithoutCollectionInput> | ProductCreateWithoutCollectionInput[] | ProductUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCollectionInput | ProductCreateOrConnectWithoutCollectionInput[]
    createMany?: ProductCreateManyCollectionInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<ProductCreateWithoutCollectionInput, ProductUncheckedCreateWithoutCollectionInput> | ProductCreateWithoutCollectionInput[] | ProductUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCollectionInput | ProductCreateOrConnectWithoutCollectionInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCollectionInput | ProductUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: ProductCreateManyCollectionInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCollectionInput | ProductUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCollectionInput | ProductUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<ProductCreateWithoutCollectionInput, ProductUncheckedCreateWithoutCollectionInput> | ProductCreateWithoutCollectionInput[] | ProductUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCollectionInput | ProductCreateOrConnectWithoutCollectionInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCollectionInput | ProductUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: ProductCreateManyCollectionInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCollectionInput | ProductUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCollectionInput | ProductUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductVariationInput = {
    create?: XOR<ProductCreateWithoutProductVariationInput, ProductUncheckedCreateWithoutProductVariationInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductVariationInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductVariationOptionCreateNestedManyWithoutVariationInput = {
    create?: XOR<ProductVariationOptionCreateWithoutVariationInput, ProductVariationOptionUncheckedCreateWithoutVariationInput> | ProductVariationOptionCreateWithoutVariationInput[] | ProductVariationOptionUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: ProductVariationOptionCreateOrConnectWithoutVariationInput | ProductVariationOptionCreateOrConnectWithoutVariationInput[]
    createMany?: ProductVariationOptionCreateManyVariationInputEnvelope
    connect?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
  }

  export type ProductVariationOptionUncheckedCreateNestedManyWithoutVariationInput = {
    create?: XOR<ProductVariationOptionCreateWithoutVariationInput, ProductVariationOptionUncheckedCreateWithoutVariationInput> | ProductVariationOptionCreateWithoutVariationInput[] | ProductVariationOptionUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: ProductVariationOptionCreateOrConnectWithoutVariationInput | ProductVariationOptionCreateOrConnectWithoutVariationInput[]
    createMany?: ProductVariationOptionCreateManyVariationInputEnvelope
    connect?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutProductVariationNestedInput = {
    create?: XOR<ProductCreateWithoutProductVariationInput, ProductUncheckedCreateWithoutProductVariationInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductVariationInput
    upsert?: ProductUpsertWithoutProductVariationInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductVariationInput, ProductUpdateWithoutProductVariationInput>, ProductUncheckedUpdateWithoutProductVariationInput>
  }

  export type ProductVariationOptionUpdateManyWithoutVariationNestedInput = {
    create?: XOR<ProductVariationOptionCreateWithoutVariationInput, ProductVariationOptionUncheckedCreateWithoutVariationInput> | ProductVariationOptionCreateWithoutVariationInput[] | ProductVariationOptionUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: ProductVariationOptionCreateOrConnectWithoutVariationInput | ProductVariationOptionCreateOrConnectWithoutVariationInput[]
    upsert?: ProductVariationOptionUpsertWithWhereUniqueWithoutVariationInput | ProductVariationOptionUpsertWithWhereUniqueWithoutVariationInput[]
    createMany?: ProductVariationOptionCreateManyVariationInputEnvelope
    set?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    disconnect?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    delete?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    connect?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    update?: ProductVariationOptionUpdateWithWhereUniqueWithoutVariationInput | ProductVariationOptionUpdateWithWhereUniqueWithoutVariationInput[]
    updateMany?: ProductVariationOptionUpdateManyWithWhereWithoutVariationInput | ProductVariationOptionUpdateManyWithWhereWithoutVariationInput[]
    deleteMany?: ProductVariationOptionScalarWhereInput | ProductVariationOptionScalarWhereInput[]
  }

  export type ProductVariationOptionUncheckedUpdateManyWithoutVariationNestedInput = {
    create?: XOR<ProductVariationOptionCreateWithoutVariationInput, ProductVariationOptionUncheckedCreateWithoutVariationInput> | ProductVariationOptionCreateWithoutVariationInput[] | ProductVariationOptionUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: ProductVariationOptionCreateOrConnectWithoutVariationInput | ProductVariationOptionCreateOrConnectWithoutVariationInput[]
    upsert?: ProductVariationOptionUpsertWithWhereUniqueWithoutVariationInput | ProductVariationOptionUpsertWithWhereUniqueWithoutVariationInput[]
    createMany?: ProductVariationOptionCreateManyVariationInputEnvelope
    set?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    disconnect?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    delete?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    connect?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    update?: ProductVariationOptionUpdateWithWhereUniqueWithoutVariationInput | ProductVariationOptionUpdateWithWhereUniqueWithoutVariationInput[]
    updateMany?: ProductVariationOptionUpdateManyWithWhereWithoutVariationInput | ProductVariationOptionUpdateManyWithWhereWithoutVariationInput[]
    deleteMany?: ProductVariationOptionScalarWhereInput | ProductVariationOptionScalarWhereInput[]
  }

  export type ProductVariantValueCreateNestedManyWithoutVariantInput = {
    create?: XOR<ProductVariantValueCreateWithoutVariantInput, ProductVariantValueUncheckedCreateWithoutVariantInput> | ProductVariantValueCreateWithoutVariantInput[] | ProductVariantValueUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ProductVariantValueCreateOrConnectWithoutVariantInput | ProductVariantValueCreateOrConnectWithoutVariantInput[]
    createMany?: ProductVariantValueCreateManyVariantInputEnvelope
    connect?: ProductVariantValueWhereUniqueInput | ProductVariantValueWhereUniqueInput[]
  }

  export type ProductVariantValueUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<ProductVariantValueCreateWithoutVariantInput, ProductVariantValueUncheckedCreateWithoutVariantInput> | ProductVariantValueCreateWithoutVariantInput[] | ProductVariantValueUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ProductVariantValueCreateOrConnectWithoutVariantInput | ProductVariantValueCreateOrConnectWithoutVariantInput[]
    createMany?: ProductVariantValueCreateManyVariantInputEnvelope
    connect?: ProductVariantValueWhereUniqueInput | ProductVariantValueWhereUniqueInput[]
  }

  export type ProductVariantValueUpdateManyWithoutVariantNestedInput = {
    create?: XOR<ProductVariantValueCreateWithoutVariantInput, ProductVariantValueUncheckedCreateWithoutVariantInput> | ProductVariantValueCreateWithoutVariantInput[] | ProductVariantValueUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ProductVariantValueCreateOrConnectWithoutVariantInput | ProductVariantValueCreateOrConnectWithoutVariantInput[]
    upsert?: ProductVariantValueUpsertWithWhereUniqueWithoutVariantInput | ProductVariantValueUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: ProductVariantValueCreateManyVariantInputEnvelope
    set?: ProductVariantValueWhereUniqueInput | ProductVariantValueWhereUniqueInput[]
    disconnect?: ProductVariantValueWhereUniqueInput | ProductVariantValueWhereUniqueInput[]
    delete?: ProductVariantValueWhereUniqueInput | ProductVariantValueWhereUniqueInput[]
    connect?: ProductVariantValueWhereUniqueInput | ProductVariantValueWhereUniqueInput[]
    update?: ProductVariantValueUpdateWithWhereUniqueWithoutVariantInput | ProductVariantValueUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: ProductVariantValueUpdateManyWithWhereWithoutVariantInput | ProductVariantValueUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: ProductVariantValueScalarWhereInput | ProductVariantValueScalarWhereInput[]
  }

  export type ProductVariantValueUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<ProductVariantValueCreateWithoutVariantInput, ProductVariantValueUncheckedCreateWithoutVariantInput> | ProductVariantValueCreateWithoutVariantInput[] | ProductVariantValueUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ProductVariantValueCreateOrConnectWithoutVariantInput | ProductVariantValueCreateOrConnectWithoutVariantInput[]
    upsert?: ProductVariantValueUpsertWithWhereUniqueWithoutVariantInput | ProductVariantValueUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: ProductVariantValueCreateManyVariantInputEnvelope
    set?: ProductVariantValueWhereUniqueInput | ProductVariantValueWhereUniqueInput[]
    disconnect?: ProductVariantValueWhereUniqueInput | ProductVariantValueWhereUniqueInput[]
    delete?: ProductVariantValueWhereUniqueInput | ProductVariantValueWhereUniqueInput[]
    connect?: ProductVariantValueWhereUniqueInput | ProductVariantValueWhereUniqueInput[]
    update?: ProductVariantValueUpdateWithWhereUniqueWithoutVariantInput | ProductVariantValueUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: ProductVariantValueUpdateManyWithWhereWithoutVariantInput | ProductVariantValueUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: ProductVariantValueScalarWhereInput | ProductVariantValueScalarWhereInput[]
  }

  export type ProductVariantCreateNestedOneWithoutValuesInput = {
    create?: XOR<ProductVariantCreateWithoutValuesInput, ProductVariantUncheckedCreateWithoutValuesInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutValuesInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type ProductVariationOptionCreateNestedManyWithoutValueInput = {
    create?: XOR<ProductVariationOptionCreateWithoutValueInput, ProductVariationOptionUncheckedCreateWithoutValueInput> | ProductVariationOptionCreateWithoutValueInput[] | ProductVariationOptionUncheckedCreateWithoutValueInput[]
    connectOrCreate?: ProductVariationOptionCreateOrConnectWithoutValueInput | ProductVariationOptionCreateOrConnectWithoutValueInput[]
    createMany?: ProductVariationOptionCreateManyValueInputEnvelope
    connect?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
  }

  export type ProductVariationOptionUncheckedCreateNestedManyWithoutValueInput = {
    create?: XOR<ProductVariationOptionCreateWithoutValueInput, ProductVariationOptionUncheckedCreateWithoutValueInput> | ProductVariationOptionCreateWithoutValueInput[] | ProductVariationOptionUncheckedCreateWithoutValueInput[]
    connectOrCreate?: ProductVariationOptionCreateOrConnectWithoutValueInput | ProductVariationOptionCreateOrConnectWithoutValueInput[]
    createMany?: ProductVariationOptionCreateManyValueInputEnvelope
    connect?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
  }

  export type ProductVariantUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<ProductVariantCreateWithoutValuesInput, ProductVariantUncheckedCreateWithoutValuesInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutValuesInput
    upsert?: ProductVariantUpsertWithoutValuesInput
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutValuesInput, ProductVariantUpdateWithoutValuesInput>, ProductVariantUncheckedUpdateWithoutValuesInput>
  }

  export type ProductVariationOptionUpdateManyWithoutValueNestedInput = {
    create?: XOR<ProductVariationOptionCreateWithoutValueInput, ProductVariationOptionUncheckedCreateWithoutValueInput> | ProductVariationOptionCreateWithoutValueInput[] | ProductVariationOptionUncheckedCreateWithoutValueInput[]
    connectOrCreate?: ProductVariationOptionCreateOrConnectWithoutValueInput | ProductVariationOptionCreateOrConnectWithoutValueInput[]
    upsert?: ProductVariationOptionUpsertWithWhereUniqueWithoutValueInput | ProductVariationOptionUpsertWithWhereUniqueWithoutValueInput[]
    createMany?: ProductVariationOptionCreateManyValueInputEnvelope
    set?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    disconnect?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    delete?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    connect?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    update?: ProductVariationOptionUpdateWithWhereUniqueWithoutValueInput | ProductVariationOptionUpdateWithWhereUniqueWithoutValueInput[]
    updateMany?: ProductVariationOptionUpdateManyWithWhereWithoutValueInput | ProductVariationOptionUpdateManyWithWhereWithoutValueInput[]
    deleteMany?: ProductVariationOptionScalarWhereInput | ProductVariationOptionScalarWhereInput[]
  }

  export type ProductVariationOptionUncheckedUpdateManyWithoutValueNestedInput = {
    create?: XOR<ProductVariationOptionCreateWithoutValueInput, ProductVariationOptionUncheckedCreateWithoutValueInput> | ProductVariationOptionCreateWithoutValueInput[] | ProductVariationOptionUncheckedCreateWithoutValueInput[]
    connectOrCreate?: ProductVariationOptionCreateOrConnectWithoutValueInput | ProductVariationOptionCreateOrConnectWithoutValueInput[]
    upsert?: ProductVariationOptionUpsertWithWhereUniqueWithoutValueInput | ProductVariationOptionUpsertWithWhereUniqueWithoutValueInput[]
    createMany?: ProductVariationOptionCreateManyValueInputEnvelope
    set?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    disconnect?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    delete?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    connect?: ProductVariationOptionWhereUniqueInput | ProductVariationOptionWhereUniqueInput[]
    update?: ProductVariationOptionUpdateWithWhereUniqueWithoutValueInput | ProductVariationOptionUpdateWithWhereUniqueWithoutValueInput[]
    updateMany?: ProductVariationOptionUpdateManyWithWhereWithoutValueInput | ProductVariationOptionUpdateManyWithWhereWithoutValueInput[]
    deleteMany?: ProductVariationOptionScalarWhereInput | ProductVariationOptionScalarWhereInput[]
  }

  export type ProductVariationCreateNestedOneWithoutOptionsInput = {
    create?: XOR<ProductVariationCreateWithoutOptionsInput, ProductVariationUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ProductVariationCreateOrConnectWithoutOptionsInput
    connect?: ProductVariationWhereUniqueInput
  }

  export type ProductVariantValueCreateNestedOneWithoutOptionsInput = {
    create?: XOR<ProductVariantValueCreateWithoutOptionsInput, ProductVariantValueUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ProductVariantValueCreateOrConnectWithoutOptionsInput
    connect?: ProductVariantValueWhereUniqueInput
  }

  export type ProductVariationUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<ProductVariationCreateWithoutOptionsInput, ProductVariationUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ProductVariationCreateOrConnectWithoutOptionsInput
    upsert?: ProductVariationUpsertWithoutOptionsInput
    connect?: ProductVariationWhereUniqueInput
    update?: XOR<XOR<ProductVariationUpdateToOneWithWhereWithoutOptionsInput, ProductVariationUpdateWithoutOptionsInput>, ProductVariationUncheckedUpdateWithoutOptionsInput>
  }

  export type ProductVariantValueUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<ProductVariantValueCreateWithoutOptionsInput, ProductVariantValueUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ProductVariantValueCreateOrConnectWithoutOptionsInput
    upsert?: ProductVariantValueUpsertWithoutOptionsInput
    connect?: ProductVariantValueWhereUniqueInput
    update?: XOR<XOR<ProductVariantValueUpdateToOneWithWhereWithoutOptionsInput, ProductVariantValueUpdateWithoutOptionsInput>, ProductVariantValueUncheckedUpdateWithoutOptionsInput>
  }

  export type ProductCreateNestedOneWithoutFeaturedBrandsInput = {
    create?: XOR<ProductCreateWithoutFeaturedBrandsInput, ProductUncheckedCreateWithoutFeaturedBrandsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFeaturedBrandsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutFeaturedBrandsNestedInput = {
    create?: XOR<ProductCreateWithoutFeaturedBrandsInput, ProductUncheckedCreateWithoutFeaturedBrandsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFeaturedBrandsInput
    upsert?: ProductUpsertWithoutFeaturedBrandsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutFeaturedBrandsInput, ProductUpdateWithoutFeaturedBrandsInput>, ProductUncheckedUpdateWithoutFeaturedBrandsInput>
  }

  export type PurchaseCreateNestedManyWithoutStoreSupplierInput = {
    create?: XOR<PurchaseCreateWithoutStoreSupplierInput, PurchaseUncheckedCreateWithoutStoreSupplierInput> | PurchaseCreateWithoutStoreSupplierInput[] | PurchaseUncheckedCreateWithoutStoreSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreSupplierInput | PurchaseCreateOrConnectWithoutStoreSupplierInput[]
    createMany?: PurchaseCreateManyStoreSupplierInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type OrganizationCreateNestedOneWithoutSupplierInput = {
    create?: XOR<OrganizationCreateWithoutSupplierInput, OrganizationUncheckedCreateWithoutSupplierInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSupplierInput
    connect?: OrganizationWhereUniqueInput
  }

  export type PurchaseUncheckedCreateNestedManyWithoutStoreSupplierInput = {
    create?: XOR<PurchaseCreateWithoutStoreSupplierInput, PurchaseUncheckedCreateWithoutStoreSupplierInput> | PurchaseCreateWithoutStoreSupplierInput[] | PurchaseUncheckedCreateWithoutStoreSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreSupplierInput | PurchaseCreateOrConnectWithoutStoreSupplierInput[]
    createMany?: PurchaseCreateManyStoreSupplierInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseUpdateManyWithoutStoreSupplierNestedInput = {
    create?: XOR<PurchaseCreateWithoutStoreSupplierInput, PurchaseUncheckedCreateWithoutStoreSupplierInput> | PurchaseCreateWithoutStoreSupplierInput[] | PurchaseUncheckedCreateWithoutStoreSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreSupplierInput | PurchaseCreateOrConnectWithoutStoreSupplierInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutStoreSupplierInput | PurchaseUpsertWithWhereUniqueWithoutStoreSupplierInput[]
    createMany?: PurchaseCreateManyStoreSupplierInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutStoreSupplierInput | PurchaseUpdateWithWhereUniqueWithoutStoreSupplierInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutStoreSupplierInput | PurchaseUpdateManyWithWhereWithoutStoreSupplierInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutSupplierNestedInput = {
    create?: XOR<OrganizationCreateWithoutSupplierInput, OrganizationUncheckedCreateWithoutSupplierInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSupplierInput
    upsert?: OrganizationUpsertWithoutSupplierInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSupplierInput, OrganizationUpdateWithoutSupplierInput>, OrganizationUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseUncheckedUpdateManyWithoutStoreSupplierNestedInput = {
    create?: XOR<PurchaseCreateWithoutStoreSupplierInput, PurchaseUncheckedCreateWithoutStoreSupplierInput> | PurchaseCreateWithoutStoreSupplierInput[] | PurchaseUncheckedCreateWithoutStoreSupplierInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreSupplierInput | PurchaseCreateOrConnectWithoutStoreSupplierInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutStoreSupplierInput | PurchaseUpsertWithWhereUniqueWithoutStoreSupplierInput[]
    createMany?: PurchaseCreateManyStoreSupplierInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutStoreSupplierInput | PurchaseUpdateWithWhereUniqueWithoutStoreSupplierInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutStoreSupplierInput | PurchaseUpdateManyWithWhereWithoutStoreSupplierInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type SupplierCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<SupplierCreateWithoutPurchaseInput, SupplierUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseInput
    connect?: SupplierWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<OrganizationCreateWithoutPurchaseInput, OrganizationUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPurchaseInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<ProductCreateWithoutPurchaseInput, ProductUncheckedCreateWithoutPurchaseInput> | ProductCreateWithoutPurchaseInput[] | ProductUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseInput | ProductCreateOrConnectWithoutPurchaseInput[]
    createMany?: ProductCreateManyPurchaseInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<ProductCreateWithoutPurchaseInput, ProductUncheckedCreateWithoutPurchaseInput> | ProductCreateWithoutPurchaseInput[] | ProductUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseInput | ProductCreateOrConnectWithoutPurchaseInput[]
    createMany?: ProductCreateManyPurchaseInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SupplierUpdateOneRequiredWithoutPurchaseNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchaseInput, SupplierUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseInput
    upsert?: SupplierUpsertWithoutPurchaseInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchaseInput, SupplierUpdateWithoutPurchaseInput>, SupplierUncheckedUpdateWithoutPurchaseInput>
  }

  export type OrganizationUpdateOneRequiredWithoutPurchaseNestedInput = {
    create?: XOR<OrganizationCreateWithoutPurchaseInput, OrganizationUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPurchaseInput
    upsert?: OrganizationUpsertWithoutPurchaseInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutPurchaseInput, OrganizationUpdateWithoutPurchaseInput>, OrganizationUncheckedUpdateWithoutPurchaseInput>
  }

  export type ProductUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseInput, ProductUncheckedCreateWithoutPurchaseInput> | ProductCreateWithoutPurchaseInput[] | ProductUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseInput | ProductCreateOrConnectWithoutPurchaseInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutPurchaseInput | ProductUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: ProductCreateManyPurchaseInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutPurchaseInput | ProductUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutPurchaseInput | ProductUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseInput, ProductUncheckedCreateWithoutPurchaseInput> | ProductCreateWithoutPurchaseInput[] | ProductUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseInput | ProductCreateOrConnectWithoutPurchaseInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutPurchaseInput | ProductUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: ProductCreateManyPurchaseInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutPurchaseInput | ProductUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutPurchaseInput | ProductUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutUserInput = {
    create?: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput> | InvitationCreateWithoutUserInput[] | InvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutUserInput | InvitationCreateOrConnectWithoutUserInput[]
    createMany?: InvitationCreateManyUserInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type LocationCreateNestedOneWithoutUserInput = {
    create?: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUserInput
    connect?: LocationWhereUniqueInput
  }

  export type PointOfSaleCreateNestedOneWithoutStaffAssignedInput = {
    create?: XOR<PointOfSaleCreateWithoutStaffAssignedInput, PointOfSaleUncheckedCreateWithoutStaffAssignedInput>
    connectOrCreate?: PointOfSaleCreateOrConnectWithoutStaffAssignedInput
    connect?: PointOfSaleWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutStaffAssignedInput = {
    create?: XOR<WarehouseCreateWithoutStaffAssignedInput, WarehouseUncheckedCreateWithoutStaffAssignedInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStaffAssignedInput
    connect?: WarehouseWhereUniqueInput
  }

  export type POSCreateNestedManyWithoutStaffInput = {
    create?: XOR<POSCreateWithoutStaffInput, POSUncheckedCreateWithoutStaffInput> | POSCreateWithoutStaffInput[] | POSUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: POSCreateOrConnectWithoutStaffInput | POSCreateOrConnectWithoutStaffInput[]
    createMany?: POSCreateManyStaffInputEnvelope
    connect?: POSWhereUniqueInput | POSWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput> | InvitationCreateWithoutUserInput[] | InvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutUserInput | InvitationCreateOrConnectWithoutUserInput[]
    createMany?: InvitationCreateManyUserInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type PointOfSaleUncheckedCreateNestedOneWithoutStaffAssignedInput = {
    create?: XOR<PointOfSaleCreateWithoutStaffAssignedInput, PointOfSaleUncheckedCreateWithoutStaffAssignedInput>
    connectOrCreate?: PointOfSaleCreateOrConnectWithoutStaffAssignedInput
    connect?: PointOfSaleWhereUniqueInput
  }

  export type WarehouseUncheckedCreateNestedOneWithoutStaffAssignedInput = {
    create?: XOR<WarehouseCreateWithoutStaffAssignedInput, WarehouseUncheckedCreateWithoutStaffAssignedInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStaffAssignedInput
    connect?: WarehouseWhereUniqueInput
  }

  export type POSUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<POSCreateWithoutStaffInput, POSUncheckedCreateWithoutStaffInput> | POSCreateWithoutStaffInput[] | POSUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: POSCreateOrConnectWithoutStaffInput | POSCreateOrConnectWithoutStaffInput[]
    createMany?: POSCreateManyStaffInputEnvelope
    connect?: POSWhereUniqueInput | POSWhereUniqueInput[]
  }

  export type MemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput> | InvitationCreateWithoutUserInput[] | InvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutUserInput | InvitationCreateOrConnectWithoutUserInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutUserInput | InvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvitationCreateManyUserInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutUserInput | InvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutUserInput | InvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type LocationUpdateOneWithoutUserNestedInput = {
    create?: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUserInput
    upsert?: LocationUpsertWithoutUserInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutUserInput, LocationUpdateWithoutUserInput>, LocationUncheckedUpdateWithoutUserInput>
  }

  export type PointOfSaleUpdateOneWithoutStaffAssignedNestedInput = {
    create?: XOR<PointOfSaleCreateWithoutStaffAssignedInput, PointOfSaleUncheckedCreateWithoutStaffAssignedInput>
    connectOrCreate?: PointOfSaleCreateOrConnectWithoutStaffAssignedInput
    upsert?: PointOfSaleUpsertWithoutStaffAssignedInput
    disconnect?: PointOfSaleWhereInput | boolean
    delete?: PointOfSaleWhereInput | boolean
    connect?: PointOfSaleWhereUniqueInput
    update?: XOR<XOR<PointOfSaleUpdateToOneWithWhereWithoutStaffAssignedInput, PointOfSaleUpdateWithoutStaffAssignedInput>, PointOfSaleUncheckedUpdateWithoutStaffAssignedInput>
  }

  export type WarehouseUpdateOneWithoutStaffAssignedNestedInput = {
    create?: XOR<WarehouseCreateWithoutStaffAssignedInput, WarehouseUncheckedCreateWithoutStaffAssignedInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStaffAssignedInput
    upsert?: WarehouseUpsertWithoutStaffAssignedInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutStaffAssignedInput, WarehouseUpdateWithoutStaffAssignedInput>, WarehouseUncheckedUpdateWithoutStaffAssignedInput>
  }

  export type POSUpdateManyWithoutStaffNestedInput = {
    create?: XOR<POSCreateWithoutStaffInput, POSUncheckedCreateWithoutStaffInput> | POSCreateWithoutStaffInput[] | POSUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: POSCreateOrConnectWithoutStaffInput | POSCreateOrConnectWithoutStaffInput[]
    upsert?: POSUpsertWithWhereUniqueWithoutStaffInput | POSUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: POSCreateManyStaffInputEnvelope
    set?: POSWhereUniqueInput | POSWhereUniqueInput[]
    disconnect?: POSWhereUniqueInput | POSWhereUniqueInput[]
    delete?: POSWhereUniqueInput | POSWhereUniqueInput[]
    connect?: POSWhereUniqueInput | POSWhereUniqueInput[]
    update?: POSUpdateWithWhereUniqueWithoutStaffInput | POSUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: POSUpdateManyWithWhereWithoutStaffInput | POSUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: POSScalarWhereInput | POSScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput> | InvitationCreateWithoutUserInput[] | InvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutUserInput | InvitationCreateOrConnectWithoutUserInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutUserInput | InvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvitationCreateManyUserInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutUserInput | InvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutUserInput | InvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type PointOfSaleUncheckedUpdateOneWithoutStaffAssignedNestedInput = {
    create?: XOR<PointOfSaleCreateWithoutStaffAssignedInput, PointOfSaleUncheckedCreateWithoutStaffAssignedInput>
    connectOrCreate?: PointOfSaleCreateOrConnectWithoutStaffAssignedInput
    upsert?: PointOfSaleUpsertWithoutStaffAssignedInput
    disconnect?: PointOfSaleWhereInput | boolean
    delete?: PointOfSaleWhereInput | boolean
    connect?: PointOfSaleWhereUniqueInput
    update?: XOR<XOR<PointOfSaleUpdateToOneWithWhereWithoutStaffAssignedInput, PointOfSaleUpdateWithoutStaffAssignedInput>, PointOfSaleUncheckedUpdateWithoutStaffAssignedInput>
  }

  export type WarehouseUncheckedUpdateOneWithoutStaffAssignedNestedInput = {
    create?: XOR<WarehouseCreateWithoutStaffAssignedInput, WarehouseUncheckedCreateWithoutStaffAssignedInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStaffAssignedInput
    upsert?: WarehouseUpsertWithoutStaffAssignedInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutStaffAssignedInput, WarehouseUpdateWithoutStaffAssignedInput>, WarehouseUncheckedUpdateWithoutStaffAssignedInput>
  }

  export type POSUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<POSCreateWithoutStaffInput, POSUncheckedCreateWithoutStaffInput> | POSCreateWithoutStaffInput[] | POSUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: POSCreateOrConnectWithoutStaffInput | POSCreateOrConnectWithoutStaffInput[]
    upsert?: POSUpsertWithWhereUniqueWithoutStaffInput | POSUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: POSCreateManyStaffInputEnvelope
    set?: POSWhereUniqueInput | POSWhereUniqueInput[]
    disconnect?: POSWhereUniqueInput | POSWhereUniqueInput[]
    delete?: POSWhereUniqueInput | POSWhereUniqueInput[]
    connect?: POSWhereUniqueInput | POSWhereUniqueInput[]
    update?: POSUpdateWithWhereUniqueWithoutStaffInput | POSUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: POSUpdateManyWithWhereWithoutStaffInput | POSUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: POSScalarWhereInput | POSScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type MemberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput> | InvitationCreateWithoutOrganizationInput[] | InvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrganizationInput | InvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: InvitationCreateManyOrganizationInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type BankDetailsCreateNestedOneWithoutStoreInput = {
    create?: XOR<BankDetailsCreateWithoutStoreInput, BankDetailsUncheckedCreateWithoutStoreInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutStoreInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutStoreInput = {
    create?: XOR<WalletCreateWithoutStoreInput, WalletUncheckedCreateWithoutStoreInput>
    connectOrCreate?: WalletCreateOrConnectWithoutStoreInput
    connect?: WalletWhereUniqueInput
  }

  export type LocationCreateNestedManyWithoutStoreInput = {
    create?: XOR<LocationCreateWithoutStoreInput, LocationUncheckedCreateWithoutStoreInput> | LocationCreateWithoutStoreInput[] | LocationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutStoreInput | LocationCreateOrConnectWithoutStoreInput[]
    createMany?: LocationCreateManyStoreInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutStoreInput = {
    create?: XOR<OrderCreateWithoutStoreInput, OrderUncheckedCreateWithoutStoreInput> | OrderCreateWithoutStoreInput[] | OrderUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStoreInput | OrderCreateOrConnectWithoutStoreInput[]
    createMany?: OrderCreateManyStoreInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutStoreInput = {
    create?: XOR<CustomerCreateWithoutStoreInput, CustomerUncheckedCreateWithoutStoreInput> | CustomerCreateWithoutStoreInput[] | CustomerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutStoreInput | CustomerCreateOrConnectWithoutStoreInput[]
    createMany?: CustomerCreateManyStoreInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerGroupsCreateNestedManyWithoutStoreInput = {
    create?: XOR<CustomerGroupsCreateWithoutStoreInput, CustomerGroupsUncheckedCreateWithoutStoreInput> | CustomerGroupsCreateWithoutStoreInput[] | CustomerGroupsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CustomerGroupsCreateOrConnectWithoutStoreInput | CustomerGroupsCreateOrConnectWithoutStoreInput[]
    createMany?: CustomerGroupsCreateManyStoreInputEnvelope
    connect?: CustomerGroupsWhereUniqueInput | CustomerGroupsWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutStoreInput = {
    create?: XOR<ExpenseCreateWithoutStoreInput, ExpenseUncheckedCreateWithoutStoreInput> | ExpenseCreateWithoutStoreInput[] | ExpenseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutStoreInput | ExpenseCreateOrConnectWithoutStoreInput[]
    createMany?: ExpenseCreateManyStoreInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutStoreInput = {
    create?: XOR<InvoiceCreateWithoutStoreInput, InvoiceUncheckedCreateWithoutStoreInput> | InvoiceCreateWithoutStoreInput[] | InvoiceUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStoreInput | InvoiceCreateOrConnectWithoutStoreInput[]
    createMany?: InvoiceCreateManyStoreInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PointOfSaleCreateNestedOneWithoutStoreInput = {
    create?: XOR<PointOfSaleCreateWithoutStoreInput, PointOfSaleUncheckedCreateWithoutStoreInput>
    connectOrCreate?: PointOfSaleCreateOrConnectWithoutStoreInput
    connect?: PointOfSaleWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductCreateWithoutStoreInput, ProductUncheckedCreateWithoutStoreInput> | ProductCreateWithoutStoreInput[] | ProductUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStoreInput | ProductCreateOrConnectWithoutStoreInput[]
    createMany?: ProductCreateManyStoreInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutStoreInput = {
    create?: XOR<SupplierCreateWithoutStoreInput, SupplierUncheckedCreateWithoutStoreInput> | SupplierCreateWithoutStoreInput[] | SupplierUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutStoreInput | SupplierCreateOrConnectWithoutStoreInput[]
    createMany?: SupplierCreateManyStoreInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutStoreInput = {
    create?: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput> | PurchaseCreateWithoutStoreInput[] | PurchaseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreInput | PurchaseCreateOrConnectWithoutStoreInput[]
    createMany?: PurchaseCreateManyStoreInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type SettlementCreateNestedManyWithoutStoreInput = {
    create?: XOR<SettlementCreateWithoutStoreInput, SettlementUncheckedCreateWithoutStoreInput> | SettlementCreateWithoutStoreInput[] | SettlementUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SettlementCreateOrConnectWithoutStoreInput | SettlementCreateOrConnectWithoutStoreInput[]
    createMany?: SettlementCreateManyStoreInputEnvelope
    connect?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutStoreInput = {
    create?: XOR<SubscriptionCreateWithoutStoreInput, SubscriptionUncheckedCreateWithoutStoreInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutStoreInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutStoreInput = {
    create?: XOR<TransactionCreateWithoutStoreInput, TransactionUncheckedCreateWithoutStoreInput> | TransactionCreateWithoutStoreInput[] | TransactionUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutStoreInput | TransactionCreateOrConnectWithoutStoreInput[]
    createMany?: TransactionCreateManyStoreInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type WarehouseCreateNestedManyWithoutStoreInput = {
    create?: XOR<WarehouseCreateWithoutStoreInput, WarehouseUncheckedCreateWithoutStoreInput> | WarehouseCreateWithoutStoreInput[] | WarehouseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutStoreInput | WarehouseCreateOrConnectWithoutStoreInput[]
    createMany?: WarehouseCreateManyStoreInputEnvelope
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
  }

  export type ShippingMethodCreateNestedManyWithoutStoreInput = {
    create?: XOR<ShippingMethodCreateWithoutStoreInput, ShippingMethodUncheckedCreateWithoutStoreInput> | ShippingMethodCreateWithoutStoreInput[] | ShippingMethodUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutStoreInput | ShippingMethodCreateOrConnectWithoutStoreInput[]
    createMany?: ShippingMethodCreateManyStoreInputEnvelope
    connect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
  }

  export type ShippingZoneCreateNestedManyWithoutStoreInput = {
    create?: XOR<ShippingZoneCreateWithoutStoreInput, ShippingZoneUncheckedCreateWithoutStoreInput> | ShippingZoneCreateWithoutStoreInput[] | ShippingZoneUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ShippingZoneCreateOrConnectWithoutStoreInput | ShippingZoneCreateOrConnectWithoutStoreInput[]
    createMany?: ShippingZoneCreateManyStoreInputEnvelope
    connect?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductCategoryCreateWithoutStoreInput, ProductCategoryUncheckedCreateWithoutStoreInput> | ProductCategoryCreateWithoutStoreInput[] | ProductCategoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutStoreInput | ProductCategoryCreateOrConnectWithoutStoreInput[]
    createMany?: ProductCategoryCreateManyStoreInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput> | InvitationCreateWithoutOrganizationInput[] | InvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrganizationInput | InvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: InvitationCreateManyOrganizationInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type BankDetailsUncheckedCreateNestedOneWithoutStoreInput = {
    create?: XOR<BankDetailsCreateWithoutStoreInput, BankDetailsUncheckedCreateWithoutStoreInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutStoreInput
    connect?: BankDetailsWhereUniqueInput
  }

  export type WalletUncheckedCreateNestedOneWithoutStoreInput = {
    create?: XOR<WalletCreateWithoutStoreInput, WalletUncheckedCreateWithoutStoreInput>
    connectOrCreate?: WalletCreateOrConnectWithoutStoreInput
    connect?: WalletWhereUniqueInput
  }

  export type LocationUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<LocationCreateWithoutStoreInput, LocationUncheckedCreateWithoutStoreInput> | LocationCreateWithoutStoreInput[] | LocationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutStoreInput | LocationCreateOrConnectWithoutStoreInput[]
    createMany?: LocationCreateManyStoreInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<OrderCreateWithoutStoreInput, OrderUncheckedCreateWithoutStoreInput> | OrderCreateWithoutStoreInput[] | OrderUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStoreInput | OrderCreateOrConnectWithoutStoreInput[]
    createMany?: OrderCreateManyStoreInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<CustomerCreateWithoutStoreInput, CustomerUncheckedCreateWithoutStoreInput> | CustomerCreateWithoutStoreInput[] | CustomerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutStoreInput | CustomerCreateOrConnectWithoutStoreInput[]
    createMany?: CustomerCreateManyStoreInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<CustomerGroupsCreateWithoutStoreInput, CustomerGroupsUncheckedCreateWithoutStoreInput> | CustomerGroupsCreateWithoutStoreInput[] | CustomerGroupsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CustomerGroupsCreateOrConnectWithoutStoreInput | CustomerGroupsCreateOrConnectWithoutStoreInput[]
    createMany?: CustomerGroupsCreateManyStoreInputEnvelope
    connect?: CustomerGroupsWhereUniqueInput | CustomerGroupsWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ExpenseCreateWithoutStoreInput, ExpenseUncheckedCreateWithoutStoreInput> | ExpenseCreateWithoutStoreInput[] | ExpenseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutStoreInput | ExpenseCreateOrConnectWithoutStoreInput[]
    createMany?: ExpenseCreateManyStoreInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<InvoiceCreateWithoutStoreInput, InvoiceUncheckedCreateWithoutStoreInput> | InvoiceCreateWithoutStoreInput[] | InvoiceUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStoreInput | InvoiceCreateOrConnectWithoutStoreInput[]
    createMany?: InvoiceCreateManyStoreInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PointOfSaleUncheckedCreateNestedOneWithoutStoreInput = {
    create?: XOR<PointOfSaleCreateWithoutStoreInput, PointOfSaleUncheckedCreateWithoutStoreInput>
    connectOrCreate?: PointOfSaleCreateOrConnectWithoutStoreInput
    connect?: PointOfSaleWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductCreateWithoutStoreInput, ProductUncheckedCreateWithoutStoreInput> | ProductCreateWithoutStoreInput[] | ProductUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStoreInput | ProductCreateOrConnectWithoutStoreInput[]
    createMany?: ProductCreateManyStoreInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<SupplierCreateWithoutStoreInput, SupplierUncheckedCreateWithoutStoreInput> | SupplierCreateWithoutStoreInput[] | SupplierUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutStoreInput | SupplierCreateOrConnectWithoutStoreInput[]
    createMany?: SupplierCreateManyStoreInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput> | PurchaseCreateWithoutStoreInput[] | PurchaseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreInput | PurchaseCreateOrConnectWithoutStoreInput[]
    createMany?: PurchaseCreateManyStoreInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type SettlementUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<SettlementCreateWithoutStoreInput, SettlementUncheckedCreateWithoutStoreInput> | SettlementCreateWithoutStoreInput[] | SettlementUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SettlementCreateOrConnectWithoutStoreInput | SettlementCreateOrConnectWithoutStoreInput[]
    createMany?: SettlementCreateManyStoreInputEnvelope
    connect?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutStoreInput = {
    create?: XOR<SubscriptionCreateWithoutStoreInput, SubscriptionUncheckedCreateWithoutStoreInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutStoreInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<TransactionCreateWithoutStoreInput, TransactionUncheckedCreateWithoutStoreInput> | TransactionCreateWithoutStoreInput[] | TransactionUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutStoreInput | TransactionCreateOrConnectWithoutStoreInput[]
    createMany?: TransactionCreateManyStoreInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type WarehouseUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<WarehouseCreateWithoutStoreInput, WarehouseUncheckedCreateWithoutStoreInput> | WarehouseCreateWithoutStoreInput[] | WarehouseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutStoreInput | WarehouseCreateOrConnectWithoutStoreInput[]
    createMany?: WarehouseCreateManyStoreInputEnvelope
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
  }

  export type ShippingMethodUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ShippingMethodCreateWithoutStoreInput, ShippingMethodUncheckedCreateWithoutStoreInput> | ShippingMethodCreateWithoutStoreInput[] | ShippingMethodUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutStoreInput | ShippingMethodCreateOrConnectWithoutStoreInput[]
    createMany?: ShippingMethodCreateManyStoreInputEnvelope
    connect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
  }

  export type ShippingZoneUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ShippingZoneCreateWithoutStoreInput, ShippingZoneUncheckedCreateWithoutStoreInput> | ShippingZoneCreateWithoutStoreInput[] | ShippingZoneUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ShippingZoneCreateOrConnectWithoutStoreInput | ShippingZoneCreateOrConnectWithoutStoreInput[]
    createMany?: ShippingZoneCreateManyStoreInputEnvelope
    connect?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductCategoryCreateWithoutStoreInput, ProductCategoryUncheckedCreateWithoutStoreInput> | ProductCategoryCreateWithoutStoreInput[] | ProductCategoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutStoreInput | ProductCategoryCreateOrConnectWithoutStoreInput[]
    createMany?: ProductCategoryCreateManyStoreInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type MemberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutOrganizationInput | MemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutOrganizationInput | MemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutOrganizationInput | MemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput> | InvitationCreateWithoutOrganizationInput[] | InvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrganizationInput | InvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutOrganizationInput | InvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InvitationCreateManyOrganizationInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutOrganizationInput | InvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutOrganizationInput | InvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type BankDetailsUpdateOneWithoutStoreNestedInput = {
    create?: XOR<BankDetailsCreateWithoutStoreInput, BankDetailsUncheckedCreateWithoutStoreInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutStoreInput
    upsert?: BankDetailsUpsertWithoutStoreInput
    disconnect?: BankDetailsWhereInput | boolean
    delete?: BankDetailsWhereInput | boolean
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<XOR<BankDetailsUpdateToOneWithWhereWithoutStoreInput, BankDetailsUpdateWithoutStoreInput>, BankDetailsUncheckedUpdateWithoutStoreInput>
  }

  export type WalletUpdateOneWithoutStoreNestedInput = {
    create?: XOR<WalletCreateWithoutStoreInput, WalletUncheckedCreateWithoutStoreInput>
    connectOrCreate?: WalletCreateOrConnectWithoutStoreInput
    upsert?: WalletUpsertWithoutStoreInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutStoreInput, WalletUpdateWithoutStoreInput>, WalletUncheckedUpdateWithoutStoreInput>
  }

  export type LocationUpdateManyWithoutStoreNestedInput = {
    create?: XOR<LocationCreateWithoutStoreInput, LocationUncheckedCreateWithoutStoreInput> | LocationCreateWithoutStoreInput[] | LocationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutStoreInput | LocationCreateOrConnectWithoutStoreInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutStoreInput | LocationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: LocationCreateManyStoreInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutStoreInput | LocationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutStoreInput | LocationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutStoreNestedInput = {
    create?: XOR<OrderCreateWithoutStoreInput, OrderUncheckedCreateWithoutStoreInput> | OrderCreateWithoutStoreInput[] | OrderUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStoreInput | OrderCreateOrConnectWithoutStoreInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStoreInput | OrderUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: OrderCreateManyStoreInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStoreInput | OrderUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStoreInput | OrderUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutStoreNestedInput = {
    create?: XOR<CustomerCreateWithoutStoreInput, CustomerUncheckedCreateWithoutStoreInput> | CustomerCreateWithoutStoreInput[] | CustomerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutStoreInput | CustomerCreateOrConnectWithoutStoreInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutStoreInput | CustomerUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: CustomerCreateManyStoreInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutStoreInput | CustomerUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutStoreInput | CustomerUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerGroupsUpdateManyWithoutStoreNestedInput = {
    create?: XOR<CustomerGroupsCreateWithoutStoreInput, CustomerGroupsUncheckedCreateWithoutStoreInput> | CustomerGroupsCreateWithoutStoreInput[] | CustomerGroupsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CustomerGroupsCreateOrConnectWithoutStoreInput | CustomerGroupsCreateOrConnectWithoutStoreInput[]
    upsert?: CustomerGroupsUpsertWithWhereUniqueWithoutStoreInput | CustomerGroupsUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: CustomerGroupsCreateManyStoreInputEnvelope
    set?: CustomerGroupsWhereUniqueInput | CustomerGroupsWhereUniqueInput[]
    disconnect?: CustomerGroupsWhereUniqueInput | CustomerGroupsWhereUniqueInput[]
    delete?: CustomerGroupsWhereUniqueInput | CustomerGroupsWhereUniqueInput[]
    connect?: CustomerGroupsWhereUniqueInput | CustomerGroupsWhereUniqueInput[]
    update?: CustomerGroupsUpdateWithWhereUniqueWithoutStoreInput | CustomerGroupsUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: CustomerGroupsUpdateManyWithWhereWithoutStoreInput | CustomerGroupsUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: CustomerGroupsScalarWhereInput | CustomerGroupsScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ExpenseCreateWithoutStoreInput, ExpenseUncheckedCreateWithoutStoreInput> | ExpenseCreateWithoutStoreInput[] | ExpenseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutStoreInput | ExpenseCreateOrConnectWithoutStoreInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutStoreInput | ExpenseUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ExpenseCreateManyStoreInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutStoreInput | ExpenseUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutStoreInput | ExpenseUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutStoreNestedInput = {
    create?: XOR<InvoiceCreateWithoutStoreInput, InvoiceUncheckedCreateWithoutStoreInput> | InvoiceCreateWithoutStoreInput[] | InvoiceUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStoreInput | InvoiceCreateOrConnectWithoutStoreInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutStoreInput | InvoiceUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: InvoiceCreateManyStoreInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutStoreInput | InvoiceUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutStoreInput | InvoiceUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PointOfSaleUpdateOneWithoutStoreNestedInput = {
    create?: XOR<PointOfSaleCreateWithoutStoreInput, PointOfSaleUncheckedCreateWithoutStoreInput>
    connectOrCreate?: PointOfSaleCreateOrConnectWithoutStoreInput
    upsert?: PointOfSaleUpsertWithoutStoreInput
    disconnect?: PointOfSaleWhereInput | boolean
    delete?: PointOfSaleWhereInput | boolean
    connect?: PointOfSaleWhereUniqueInput
    update?: XOR<XOR<PointOfSaleUpdateToOneWithWhereWithoutStoreInput, PointOfSaleUpdateWithoutStoreInput>, PointOfSaleUncheckedUpdateWithoutStoreInput>
  }

  export type ProductUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductCreateWithoutStoreInput, ProductUncheckedCreateWithoutStoreInput> | ProductCreateWithoutStoreInput[] | ProductUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStoreInput | ProductCreateOrConnectWithoutStoreInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutStoreInput | ProductUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductCreateManyStoreInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutStoreInput | ProductUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutStoreInput | ProductUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SupplierCreateWithoutStoreInput, SupplierUncheckedCreateWithoutStoreInput> | SupplierCreateWithoutStoreInput[] | SupplierUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutStoreInput | SupplierCreateOrConnectWithoutStoreInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutStoreInput | SupplierUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SupplierCreateManyStoreInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutStoreInput | SupplierUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutStoreInput | SupplierUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutStoreNestedInput = {
    create?: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput> | PurchaseCreateWithoutStoreInput[] | PurchaseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreInput | PurchaseCreateOrConnectWithoutStoreInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutStoreInput | PurchaseUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: PurchaseCreateManyStoreInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutStoreInput | PurchaseUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutStoreInput | PurchaseUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type SettlementUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SettlementCreateWithoutStoreInput, SettlementUncheckedCreateWithoutStoreInput> | SettlementCreateWithoutStoreInput[] | SettlementUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SettlementCreateOrConnectWithoutStoreInput | SettlementCreateOrConnectWithoutStoreInput[]
    upsert?: SettlementUpsertWithWhereUniqueWithoutStoreInput | SettlementUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SettlementCreateManyStoreInputEnvelope
    set?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    disconnect?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    delete?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    connect?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    update?: SettlementUpdateWithWhereUniqueWithoutStoreInput | SettlementUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SettlementUpdateManyWithWhereWithoutStoreInput | SettlementUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SettlementScalarWhereInput | SettlementScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutStoreNestedInput = {
    create?: XOR<SubscriptionCreateWithoutStoreInput, SubscriptionUncheckedCreateWithoutStoreInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutStoreInput
    upsert?: SubscriptionUpsertWithoutStoreInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutStoreInput, SubscriptionUpdateWithoutStoreInput>, SubscriptionUncheckedUpdateWithoutStoreInput>
  }

  export type TransactionUpdateManyWithoutStoreNestedInput = {
    create?: XOR<TransactionCreateWithoutStoreInput, TransactionUncheckedCreateWithoutStoreInput> | TransactionCreateWithoutStoreInput[] | TransactionUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutStoreInput | TransactionCreateOrConnectWithoutStoreInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutStoreInput | TransactionUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: TransactionCreateManyStoreInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutStoreInput | TransactionUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutStoreInput | TransactionUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type WarehouseUpdateManyWithoutStoreNestedInput = {
    create?: XOR<WarehouseCreateWithoutStoreInput, WarehouseUncheckedCreateWithoutStoreInput> | WarehouseCreateWithoutStoreInput[] | WarehouseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutStoreInput | WarehouseCreateOrConnectWithoutStoreInput[]
    upsert?: WarehouseUpsertWithWhereUniqueWithoutStoreInput | WarehouseUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: WarehouseCreateManyStoreInputEnvelope
    set?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    disconnect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    delete?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    update?: WarehouseUpdateWithWhereUniqueWithoutStoreInput | WarehouseUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: WarehouseUpdateManyWithWhereWithoutStoreInput | WarehouseUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
  }

  export type ShippingMethodUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ShippingMethodCreateWithoutStoreInput, ShippingMethodUncheckedCreateWithoutStoreInput> | ShippingMethodCreateWithoutStoreInput[] | ShippingMethodUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutStoreInput | ShippingMethodCreateOrConnectWithoutStoreInput[]
    upsert?: ShippingMethodUpsertWithWhereUniqueWithoutStoreInput | ShippingMethodUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ShippingMethodCreateManyStoreInputEnvelope
    set?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    disconnect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    delete?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    connect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    update?: ShippingMethodUpdateWithWhereUniqueWithoutStoreInput | ShippingMethodUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ShippingMethodUpdateManyWithWhereWithoutStoreInput | ShippingMethodUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ShippingMethodScalarWhereInput | ShippingMethodScalarWhereInput[]
  }

  export type ShippingZoneUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ShippingZoneCreateWithoutStoreInput, ShippingZoneUncheckedCreateWithoutStoreInput> | ShippingZoneCreateWithoutStoreInput[] | ShippingZoneUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ShippingZoneCreateOrConnectWithoutStoreInput | ShippingZoneCreateOrConnectWithoutStoreInput[]
    upsert?: ShippingZoneUpsertWithWhereUniqueWithoutStoreInput | ShippingZoneUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ShippingZoneCreateManyStoreInputEnvelope
    set?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    disconnect?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    delete?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    connect?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    update?: ShippingZoneUpdateWithWhereUniqueWithoutStoreInput | ShippingZoneUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ShippingZoneUpdateManyWithWhereWithoutStoreInput | ShippingZoneUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ShippingZoneScalarWhereInput | ShippingZoneScalarWhereInput[]
  }

  export type ProductCategoryUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutStoreInput, ProductCategoryUncheckedCreateWithoutStoreInput> | ProductCategoryCreateWithoutStoreInput[] | ProductCategoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutStoreInput | ProductCategoryCreateOrConnectWithoutStoreInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutStoreInput | ProductCategoryUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductCategoryCreateManyStoreInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutStoreInput | ProductCategoryUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutStoreInput | ProductCategoryUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutOrganizationInput | MemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutOrganizationInput | MemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutOrganizationInput | MemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput> | InvitationCreateWithoutOrganizationInput[] | InvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrganizationInput | InvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutOrganizationInput | InvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InvitationCreateManyOrganizationInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutOrganizationInput | InvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutOrganizationInput | InvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type BankDetailsUncheckedUpdateOneWithoutStoreNestedInput = {
    create?: XOR<BankDetailsCreateWithoutStoreInput, BankDetailsUncheckedCreateWithoutStoreInput>
    connectOrCreate?: BankDetailsCreateOrConnectWithoutStoreInput
    upsert?: BankDetailsUpsertWithoutStoreInput
    disconnect?: BankDetailsWhereInput | boolean
    delete?: BankDetailsWhereInput | boolean
    connect?: BankDetailsWhereUniqueInput
    update?: XOR<XOR<BankDetailsUpdateToOneWithWhereWithoutStoreInput, BankDetailsUpdateWithoutStoreInput>, BankDetailsUncheckedUpdateWithoutStoreInput>
  }

  export type WalletUncheckedUpdateOneWithoutStoreNestedInput = {
    create?: XOR<WalletCreateWithoutStoreInput, WalletUncheckedCreateWithoutStoreInput>
    connectOrCreate?: WalletCreateOrConnectWithoutStoreInput
    upsert?: WalletUpsertWithoutStoreInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutStoreInput, WalletUpdateWithoutStoreInput>, WalletUncheckedUpdateWithoutStoreInput>
  }

  export type LocationUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<LocationCreateWithoutStoreInput, LocationUncheckedCreateWithoutStoreInput> | LocationCreateWithoutStoreInput[] | LocationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutStoreInput | LocationCreateOrConnectWithoutStoreInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutStoreInput | LocationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: LocationCreateManyStoreInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutStoreInput | LocationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutStoreInput | LocationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<OrderCreateWithoutStoreInput, OrderUncheckedCreateWithoutStoreInput> | OrderCreateWithoutStoreInput[] | OrderUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStoreInput | OrderCreateOrConnectWithoutStoreInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStoreInput | OrderUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: OrderCreateManyStoreInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStoreInput | OrderUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStoreInput | OrderUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<CustomerCreateWithoutStoreInput, CustomerUncheckedCreateWithoutStoreInput> | CustomerCreateWithoutStoreInput[] | CustomerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutStoreInput | CustomerCreateOrConnectWithoutStoreInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutStoreInput | CustomerUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: CustomerCreateManyStoreInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutStoreInput | CustomerUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutStoreInput | CustomerUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<CustomerGroupsCreateWithoutStoreInput, CustomerGroupsUncheckedCreateWithoutStoreInput> | CustomerGroupsCreateWithoutStoreInput[] | CustomerGroupsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: CustomerGroupsCreateOrConnectWithoutStoreInput | CustomerGroupsCreateOrConnectWithoutStoreInput[]
    upsert?: CustomerGroupsUpsertWithWhereUniqueWithoutStoreInput | CustomerGroupsUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: CustomerGroupsCreateManyStoreInputEnvelope
    set?: CustomerGroupsWhereUniqueInput | CustomerGroupsWhereUniqueInput[]
    disconnect?: CustomerGroupsWhereUniqueInput | CustomerGroupsWhereUniqueInput[]
    delete?: CustomerGroupsWhereUniqueInput | CustomerGroupsWhereUniqueInput[]
    connect?: CustomerGroupsWhereUniqueInput | CustomerGroupsWhereUniqueInput[]
    update?: CustomerGroupsUpdateWithWhereUniqueWithoutStoreInput | CustomerGroupsUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: CustomerGroupsUpdateManyWithWhereWithoutStoreInput | CustomerGroupsUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: CustomerGroupsScalarWhereInput | CustomerGroupsScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ExpenseCreateWithoutStoreInput, ExpenseUncheckedCreateWithoutStoreInput> | ExpenseCreateWithoutStoreInput[] | ExpenseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutStoreInput | ExpenseCreateOrConnectWithoutStoreInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutStoreInput | ExpenseUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ExpenseCreateManyStoreInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutStoreInput | ExpenseUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutStoreInput | ExpenseUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<InvoiceCreateWithoutStoreInput, InvoiceUncheckedCreateWithoutStoreInput> | InvoiceCreateWithoutStoreInput[] | InvoiceUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStoreInput | InvoiceCreateOrConnectWithoutStoreInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutStoreInput | InvoiceUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: InvoiceCreateManyStoreInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutStoreInput | InvoiceUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutStoreInput | InvoiceUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput = {
    create?: XOR<PointOfSaleCreateWithoutStoreInput, PointOfSaleUncheckedCreateWithoutStoreInput>
    connectOrCreate?: PointOfSaleCreateOrConnectWithoutStoreInput
    upsert?: PointOfSaleUpsertWithoutStoreInput
    disconnect?: PointOfSaleWhereInput | boolean
    delete?: PointOfSaleWhereInput | boolean
    connect?: PointOfSaleWhereUniqueInput
    update?: XOR<XOR<PointOfSaleUpdateToOneWithWhereWithoutStoreInput, PointOfSaleUpdateWithoutStoreInput>, PointOfSaleUncheckedUpdateWithoutStoreInput>
  }

  export type ProductUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductCreateWithoutStoreInput, ProductUncheckedCreateWithoutStoreInput> | ProductCreateWithoutStoreInput[] | ProductUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStoreInput | ProductCreateOrConnectWithoutStoreInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutStoreInput | ProductUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductCreateManyStoreInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutStoreInput | ProductUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutStoreInput | ProductUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SupplierCreateWithoutStoreInput, SupplierUncheckedCreateWithoutStoreInput> | SupplierCreateWithoutStoreInput[] | SupplierUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutStoreInput | SupplierCreateOrConnectWithoutStoreInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutStoreInput | SupplierUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SupplierCreateManyStoreInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutStoreInput | SupplierUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutStoreInput | SupplierUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput> | PurchaseCreateWithoutStoreInput[] | PurchaseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreInput | PurchaseCreateOrConnectWithoutStoreInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutStoreInput | PurchaseUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: PurchaseCreateManyStoreInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutStoreInput | PurchaseUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutStoreInput | PurchaseUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type SettlementUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SettlementCreateWithoutStoreInput, SettlementUncheckedCreateWithoutStoreInput> | SettlementCreateWithoutStoreInput[] | SettlementUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SettlementCreateOrConnectWithoutStoreInput | SettlementCreateOrConnectWithoutStoreInput[]
    upsert?: SettlementUpsertWithWhereUniqueWithoutStoreInput | SettlementUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SettlementCreateManyStoreInputEnvelope
    set?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    disconnect?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    delete?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    connect?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    update?: SettlementUpdateWithWhereUniqueWithoutStoreInput | SettlementUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SettlementUpdateManyWithWhereWithoutStoreInput | SettlementUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SettlementScalarWhereInput | SettlementScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutStoreNestedInput = {
    create?: XOR<SubscriptionCreateWithoutStoreInput, SubscriptionUncheckedCreateWithoutStoreInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutStoreInput
    upsert?: SubscriptionUpsertWithoutStoreInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutStoreInput, SubscriptionUpdateWithoutStoreInput>, SubscriptionUncheckedUpdateWithoutStoreInput>
  }

  export type TransactionUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<TransactionCreateWithoutStoreInput, TransactionUncheckedCreateWithoutStoreInput> | TransactionCreateWithoutStoreInput[] | TransactionUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutStoreInput | TransactionCreateOrConnectWithoutStoreInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutStoreInput | TransactionUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: TransactionCreateManyStoreInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutStoreInput | TransactionUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutStoreInput | TransactionUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type WarehouseUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<WarehouseCreateWithoutStoreInput, WarehouseUncheckedCreateWithoutStoreInput> | WarehouseCreateWithoutStoreInput[] | WarehouseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutStoreInput | WarehouseCreateOrConnectWithoutStoreInput[]
    upsert?: WarehouseUpsertWithWhereUniqueWithoutStoreInput | WarehouseUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: WarehouseCreateManyStoreInputEnvelope
    set?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    disconnect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    delete?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    update?: WarehouseUpdateWithWhereUniqueWithoutStoreInput | WarehouseUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: WarehouseUpdateManyWithWhereWithoutStoreInput | WarehouseUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
  }

  export type ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ShippingMethodCreateWithoutStoreInput, ShippingMethodUncheckedCreateWithoutStoreInput> | ShippingMethodCreateWithoutStoreInput[] | ShippingMethodUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutStoreInput | ShippingMethodCreateOrConnectWithoutStoreInput[]
    upsert?: ShippingMethodUpsertWithWhereUniqueWithoutStoreInput | ShippingMethodUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ShippingMethodCreateManyStoreInputEnvelope
    set?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    disconnect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    delete?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    connect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    update?: ShippingMethodUpdateWithWhereUniqueWithoutStoreInput | ShippingMethodUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ShippingMethodUpdateManyWithWhereWithoutStoreInput | ShippingMethodUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ShippingMethodScalarWhereInput | ShippingMethodScalarWhereInput[]
  }

  export type ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ShippingZoneCreateWithoutStoreInput, ShippingZoneUncheckedCreateWithoutStoreInput> | ShippingZoneCreateWithoutStoreInput[] | ShippingZoneUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ShippingZoneCreateOrConnectWithoutStoreInput | ShippingZoneCreateOrConnectWithoutStoreInput[]
    upsert?: ShippingZoneUpsertWithWhereUniqueWithoutStoreInput | ShippingZoneUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ShippingZoneCreateManyStoreInputEnvelope
    set?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    disconnect?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    delete?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    connect?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    update?: ShippingZoneUpdateWithWhereUniqueWithoutStoreInput | ShippingZoneUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ShippingZoneUpdateManyWithWhereWithoutStoreInput | ShippingZoneUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ShippingZoneScalarWhereInput | ShippingZoneScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutStoreInput, ProductCategoryUncheckedCreateWithoutStoreInput> | ProductCategoryCreateWithoutStoreInput[] | ProductCategoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutStoreInput | ProductCategoryCreateOrConnectWithoutStoreInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutStoreInput | ProductCategoryUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductCategoryCreateManyStoreInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutStoreInput | ProductCategoryUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutStoreInput | ProductCategoryUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutMembersInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMembersInput = {
    create?: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembersInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    upsert?: OrganizationUpsertWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMembersInput, OrganizationUpdateWithoutMembersInput>, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembersInput
    upsert?: UserUpsertWithoutMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembersInput, UserUpdateWithoutMembersInput>, UserUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    upsert?: OrganizationUpsertWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutInvitationsInput, OrganizationUpdateWithoutInvitationsInput>, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    upsert?: UserUpsertWithoutInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsInput, UserUpdateWithoutInvitationsInput>, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type OrganizationCreateNestedOneWithoutSettlementsInput = {
    create?: XOR<OrganizationCreateWithoutSettlementsInput, OrganizationUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSettlementsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutSettlementsNestedInput = {
    create?: XOR<OrganizationCreateWithoutSettlementsInput, OrganizationUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSettlementsInput
    upsert?: OrganizationUpsertWithoutSettlementsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSettlementsInput, OrganizationUpdateWithoutSettlementsInput>, OrganizationUncheckedUpdateWithoutSettlementsInput>
  }

  export type ShippingMethodCreateNestedOneWithoutShippingInput = {
    create?: XOR<ShippingMethodCreateWithoutShippingInput, ShippingMethodUncheckedCreateWithoutShippingInput>
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutShippingInput
    connect?: ShippingMethodWhereUniqueInput
  }

  export type ShippingAuditCreateNestedManyWithoutShippingInput = {
    create?: XOR<ShippingAuditCreateWithoutShippingInput, ShippingAuditUncheckedCreateWithoutShippingInput> | ShippingAuditCreateWithoutShippingInput[] | ShippingAuditUncheckedCreateWithoutShippingInput[]
    connectOrCreate?: ShippingAuditCreateOrConnectWithoutShippingInput | ShippingAuditCreateOrConnectWithoutShippingInput[]
    createMany?: ShippingAuditCreateManyShippingInputEnvelope
    connect?: ShippingAuditWhereUniqueInput | ShippingAuditWhereUniqueInput[]
  }

  export type ShippingAuditUncheckedCreateNestedManyWithoutShippingInput = {
    create?: XOR<ShippingAuditCreateWithoutShippingInput, ShippingAuditUncheckedCreateWithoutShippingInput> | ShippingAuditCreateWithoutShippingInput[] | ShippingAuditUncheckedCreateWithoutShippingInput[]
    connectOrCreate?: ShippingAuditCreateOrConnectWithoutShippingInput | ShippingAuditCreateOrConnectWithoutShippingInput[]
    createMany?: ShippingAuditCreateManyShippingInputEnvelope
    connect?: ShippingAuditWhereUniqueInput | ShippingAuditWhereUniqueInput[]
  }

  export type EnumShippingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShippingStatus
  }

  export type ShippingMethodUpdateOneRequiredWithoutShippingNestedInput = {
    create?: XOR<ShippingMethodCreateWithoutShippingInput, ShippingMethodUncheckedCreateWithoutShippingInput>
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutShippingInput
    upsert?: ShippingMethodUpsertWithoutShippingInput
    connect?: ShippingMethodWhereUniqueInput
    update?: XOR<XOR<ShippingMethodUpdateToOneWithWhereWithoutShippingInput, ShippingMethodUpdateWithoutShippingInput>, ShippingMethodUncheckedUpdateWithoutShippingInput>
  }

  export type ShippingAuditUpdateManyWithoutShippingNestedInput = {
    create?: XOR<ShippingAuditCreateWithoutShippingInput, ShippingAuditUncheckedCreateWithoutShippingInput> | ShippingAuditCreateWithoutShippingInput[] | ShippingAuditUncheckedCreateWithoutShippingInput[]
    connectOrCreate?: ShippingAuditCreateOrConnectWithoutShippingInput | ShippingAuditCreateOrConnectWithoutShippingInput[]
    upsert?: ShippingAuditUpsertWithWhereUniqueWithoutShippingInput | ShippingAuditUpsertWithWhereUniqueWithoutShippingInput[]
    createMany?: ShippingAuditCreateManyShippingInputEnvelope
    set?: ShippingAuditWhereUniqueInput | ShippingAuditWhereUniqueInput[]
    disconnect?: ShippingAuditWhereUniqueInput | ShippingAuditWhereUniqueInput[]
    delete?: ShippingAuditWhereUniqueInput | ShippingAuditWhereUniqueInput[]
    connect?: ShippingAuditWhereUniqueInput | ShippingAuditWhereUniqueInput[]
    update?: ShippingAuditUpdateWithWhereUniqueWithoutShippingInput | ShippingAuditUpdateWithWhereUniqueWithoutShippingInput[]
    updateMany?: ShippingAuditUpdateManyWithWhereWithoutShippingInput | ShippingAuditUpdateManyWithWhereWithoutShippingInput[]
    deleteMany?: ShippingAuditScalarWhereInput | ShippingAuditScalarWhereInput[]
  }

  export type ShippingAuditUncheckedUpdateManyWithoutShippingNestedInput = {
    create?: XOR<ShippingAuditCreateWithoutShippingInput, ShippingAuditUncheckedCreateWithoutShippingInput> | ShippingAuditCreateWithoutShippingInput[] | ShippingAuditUncheckedCreateWithoutShippingInput[]
    connectOrCreate?: ShippingAuditCreateOrConnectWithoutShippingInput | ShippingAuditCreateOrConnectWithoutShippingInput[]
    upsert?: ShippingAuditUpsertWithWhereUniqueWithoutShippingInput | ShippingAuditUpsertWithWhereUniqueWithoutShippingInput[]
    createMany?: ShippingAuditCreateManyShippingInputEnvelope
    set?: ShippingAuditWhereUniqueInput | ShippingAuditWhereUniqueInput[]
    disconnect?: ShippingAuditWhereUniqueInput | ShippingAuditWhereUniqueInput[]
    delete?: ShippingAuditWhereUniqueInput | ShippingAuditWhereUniqueInput[]
    connect?: ShippingAuditWhereUniqueInput | ShippingAuditWhereUniqueInput[]
    update?: ShippingAuditUpdateWithWhereUniqueWithoutShippingInput | ShippingAuditUpdateWithWhereUniqueWithoutShippingInput[]
    updateMany?: ShippingAuditUpdateManyWithWhereWithoutShippingInput | ShippingAuditUpdateManyWithWhereWithoutShippingInput[]
    deleteMany?: ShippingAuditScalarWhereInput | ShippingAuditScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutShippingMethodInput = {
    create?: XOR<OrganizationCreateWithoutShippingMethodInput, OrganizationUncheckedCreateWithoutShippingMethodInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutShippingMethodInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ShippingZoneCreateNestedManyWithoutShippingMethodsInput = {
    create?: XOR<ShippingZoneCreateWithoutShippingMethodsInput, ShippingZoneUncheckedCreateWithoutShippingMethodsInput> | ShippingZoneCreateWithoutShippingMethodsInput[] | ShippingZoneUncheckedCreateWithoutShippingMethodsInput[]
    connectOrCreate?: ShippingZoneCreateOrConnectWithoutShippingMethodsInput | ShippingZoneCreateOrConnectWithoutShippingMethodsInput[]
    connect?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
  }

  export type ShippingCreateNestedManyWithoutShippingMethodInput = {
    create?: XOR<ShippingCreateWithoutShippingMethodInput, ShippingUncheckedCreateWithoutShippingMethodInput> | ShippingCreateWithoutShippingMethodInput[] | ShippingUncheckedCreateWithoutShippingMethodInput[]
    connectOrCreate?: ShippingCreateOrConnectWithoutShippingMethodInput | ShippingCreateOrConnectWithoutShippingMethodInput[]
    createMany?: ShippingCreateManyShippingMethodInputEnvelope
    connect?: ShippingWhereUniqueInput | ShippingWhereUniqueInput[]
  }

  export type ShippingZoneUncheckedCreateNestedManyWithoutShippingMethodsInput = {
    create?: XOR<ShippingZoneCreateWithoutShippingMethodsInput, ShippingZoneUncheckedCreateWithoutShippingMethodsInput> | ShippingZoneCreateWithoutShippingMethodsInput[] | ShippingZoneUncheckedCreateWithoutShippingMethodsInput[]
    connectOrCreate?: ShippingZoneCreateOrConnectWithoutShippingMethodsInput | ShippingZoneCreateOrConnectWithoutShippingMethodsInput[]
    connect?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
  }

  export type ShippingUncheckedCreateNestedManyWithoutShippingMethodInput = {
    create?: XOR<ShippingCreateWithoutShippingMethodInput, ShippingUncheckedCreateWithoutShippingMethodInput> | ShippingCreateWithoutShippingMethodInput[] | ShippingUncheckedCreateWithoutShippingMethodInput[]
    connectOrCreate?: ShippingCreateOrConnectWithoutShippingMethodInput | ShippingCreateOrConnectWithoutShippingMethodInput[]
    createMany?: ShippingCreateManyShippingMethodInputEnvelope
    connect?: ShippingWhereUniqueInput | ShippingWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutShippingMethodNestedInput = {
    create?: XOR<OrganizationCreateWithoutShippingMethodInput, OrganizationUncheckedCreateWithoutShippingMethodInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutShippingMethodInput
    upsert?: OrganizationUpsertWithoutShippingMethodInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutShippingMethodInput, OrganizationUpdateWithoutShippingMethodInput>, OrganizationUncheckedUpdateWithoutShippingMethodInput>
  }

  export type ShippingZoneUpdateManyWithoutShippingMethodsNestedInput = {
    create?: XOR<ShippingZoneCreateWithoutShippingMethodsInput, ShippingZoneUncheckedCreateWithoutShippingMethodsInput> | ShippingZoneCreateWithoutShippingMethodsInput[] | ShippingZoneUncheckedCreateWithoutShippingMethodsInput[]
    connectOrCreate?: ShippingZoneCreateOrConnectWithoutShippingMethodsInput | ShippingZoneCreateOrConnectWithoutShippingMethodsInput[]
    upsert?: ShippingZoneUpsertWithWhereUniqueWithoutShippingMethodsInput | ShippingZoneUpsertWithWhereUniqueWithoutShippingMethodsInput[]
    set?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    disconnect?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    delete?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    connect?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    update?: ShippingZoneUpdateWithWhereUniqueWithoutShippingMethodsInput | ShippingZoneUpdateWithWhereUniqueWithoutShippingMethodsInput[]
    updateMany?: ShippingZoneUpdateManyWithWhereWithoutShippingMethodsInput | ShippingZoneUpdateManyWithWhereWithoutShippingMethodsInput[]
    deleteMany?: ShippingZoneScalarWhereInput | ShippingZoneScalarWhereInput[]
  }

  export type ShippingUpdateManyWithoutShippingMethodNestedInput = {
    create?: XOR<ShippingCreateWithoutShippingMethodInput, ShippingUncheckedCreateWithoutShippingMethodInput> | ShippingCreateWithoutShippingMethodInput[] | ShippingUncheckedCreateWithoutShippingMethodInput[]
    connectOrCreate?: ShippingCreateOrConnectWithoutShippingMethodInput | ShippingCreateOrConnectWithoutShippingMethodInput[]
    upsert?: ShippingUpsertWithWhereUniqueWithoutShippingMethodInput | ShippingUpsertWithWhereUniqueWithoutShippingMethodInput[]
    createMany?: ShippingCreateManyShippingMethodInputEnvelope
    set?: ShippingWhereUniqueInput | ShippingWhereUniqueInput[]
    disconnect?: ShippingWhereUniqueInput | ShippingWhereUniqueInput[]
    delete?: ShippingWhereUniqueInput | ShippingWhereUniqueInput[]
    connect?: ShippingWhereUniqueInput | ShippingWhereUniqueInput[]
    update?: ShippingUpdateWithWhereUniqueWithoutShippingMethodInput | ShippingUpdateWithWhereUniqueWithoutShippingMethodInput[]
    updateMany?: ShippingUpdateManyWithWhereWithoutShippingMethodInput | ShippingUpdateManyWithWhereWithoutShippingMethodInput[]
    deleteMany?: ShippingScalarWhereInput | ShippingScalarWhereInput[]
  }

  export type ShippingZoneUncheckedUpdateManyWithoutShippingMethodsNestedInput = {
    create?: XOR<ShippingZoneCreateWithoutShippingMethodsInput, ShippingZoneUncheckedCreateWithoutShippingMethodsInput> | ShippingZoneCreateWithoutShippingMethodsInput[] | ShippingZoneUncheckedCreateWithoutShippingMethodsInput[]
    connectOrCreate?: ShippingZoneCreateOrConnectWithoutShippingMethodsInput | ShippingZoneCreateOrConnectWithoutShippingMethodsInput[]
    upsert?: ShippingZoneUpsertWithWhereUniqueWithoutShippingMethodsInput | ShippingZoneUpsertWithWhereUniqueWithoutShippingMethodsInput[]
    set?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    disconnect?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    delete?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    connect?: ShippingZoneWhereUniqueInput | ShippingZoneWhereUniqueInput[]
    update?: ShippingZoneUpdateWithWhereUniqueWithoutShippingMethodsInput | ShippingZoneUpdateWithWhereUniqueWithoutShippingMethodsInput[]
    updateMany?: ShippingZoneUpdateManyWithWhereWithoutShippingMethodsInput | ShippingZoneUpdateManyWithWhereWithoutShippingMethodsInput[]
    deleteMany?: ShippingZoneScalarWhereInput | ShippingZoneScalarWhereInput[]
  }

  export type ShippingUncheckedUpdateManyWithoutShippingMethodNestedInput = {
    create?: XOR<ShippingCreateWithoutShippingMethodInput, ShippingUncheckedCreateWithoutShippingMethodInput> | ShippingCreateWithoutShippingMethodInput[] | ShippingUncheckedCreateWithoutShippingMethodInput[]
    connectOrCreate?: ShippingCreateOrConnectWithoutShippingMethodInput | ShippingCreateOrConnectWithoutShippingMethodInput[]
    upsert?: ShippingUpsertWithWhereUniqueWithoutShippingMethodInput | ShippingUpsertWithWhereUniqueWithoutShippingMethodInput[]
    createMany?: ShippingCreateManyShippingMethodInputEnvelope
    set?: ShippingWhereUniqueInput | ShippingWhereUniqueInput[]
    disconnect?: ShippingWhereUniqueInput | ShippingWhereUniqueInput[]
    delete?: ShippingWhereUniqueInput | ShippingWhereUniqueInput[]
    connect?: ShippingWhereUniqueInput | ShippingWhereUniqueInput[]
    update?: ShippingUpdateWithWhereUniqueWithoutShippingMethodInput | ShippingUpdateWithWhereUniqueWithoutShippingMethodInput[]
    updateMany?: ShippingUpdateManyWithWhereWithoutShippingMethodInput | ShippingUpdateManyWithWhereWithoutShippingMethodInput[]
    deleteMany?: ShippingScalarWhereInput | ShippingScalarWhereInput[]
  }

  export type ShippingZoneCreatecountriesInput = {
    set: string[]
  }

  export type ShippingZoneCreateregionsInput = {
    set: string[]
  }

  export type ShippingZoneCreatepostalCodesInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutShippingZoneInput = {
    create?: XOR<OrganizationCreateWithoutShippingZoneInput, OrganizationUncheckedCreateWithoutShippingZoneInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutShippingZoneInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ShippingMethodCreateNestedManyWithoutShippingZonesInput = {
    create?: XOR<ShippingMethodCreateWithoutShippingZonesInput, ShippingMethodUncheckedCreateWithoutShippingZonesInput> | ShippingMethodCreateWithoutShippingZonesInput[] | ShippingMethodUncheckedCreateWithoutShippingZonesInput[]
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutShippingZonesInput | ShippingMethodCreateOrConnectWithoutShippingZonesInput[]
    connect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
  }

  export type ShippingMethodUncheckedCreateNestedManyWithoutShippingZonesInput = {
    create?: XOR<ShippingMethodCreateWithoutShippingZonesInput, ShippingMethodUncheckedCreateWithoutShippingZonesInput> | ShippingMethodCreateWithoutShippingZonesInput[] | ShippingMethodUncheckedCreateWithoutShippingZonesInput[]
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutShippingZonesInput | ShippingMethodCreateOrConnectWithoutShippingZonesInput[]
    connect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
  }

  export type ShippingZoneUpdatecountriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ShippingZoneUpdateregionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ShippingZoneUpdatepostalCodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneRequiredWithoutShippingZoneNestedInput = {
    create?: XOR<OrganizationCreateWithoutShippingZoneInput, OrganizationUncheckedCreateWithoutShippingZoneInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutShippingZoneInput
    upsert?: OrganizationUpsertWithoutShippingZoneInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutShippingZoneInput, OrganizationUpdateWithoutShippingZoneInput>, OrganizationUncheckedUpdateWithoutShippingZoneInput>
  }

  export type ShippingMethodUpdateManyWithoutShippingZonesNestedInput = {
    create?: XOR<ShippingMethodCreateWithoutShippingZonesInput, ShippingMethodUncheckedCreateWithoutShippingZonesInput> | ShippingMethodCreateWithoutShippingZonesInput[] | ShippingMethodUncheckedCreateWithoutShippingZonesInput[]
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutShippingZonesInput | ShippingMethodCreateOrConnectWithoutShippingZonesInput[]
    upsert?: ShippingMethodUpsertWithWhereUniqueWithoutShippingZonesInput | ShippingMethodUpsertWithWhereUniqueWithoutShippingZonesInput[]
    set?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    disconnect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    delete?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    connect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    update?: ShippingMethodUpdateWithWhereUniqueWithoutShippingZonesInput | ShippingMethodUpdateWithWhereUniqueWithoutShippingZonesInput[]
    updateMany?: ShippingMethodUpdateManyWithWhereWithoutShippingZonesInput | ShippingMethodUpdateManyWithWhereWithoutShippingZonesInput[]
    deleteMany?: ShippingMethodScalarWhereInput | ShippingMethodScalarWhereInput[]
  }

  export type ShippingMethodUncheckedUpdateManyWithoutShippingZonesNestedInput = {
    create?: XOR<ShippingMethodCreateWithoutShippingZonesInput, ShippingMethodUncheckedCreateWithoutShippingZonesInput> | ShippingMethodCreateWithoutShippingZonesInput[] | ShippingMethodUncheckedCreateWithoutShippingZonesInput[]
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutShippingZonesInput | ShippingMethodCreateOrConnectWithoutShippingZonesInput[]
    upsert?: ShippingMethodUpsertWithWhereUniqueWithoutShippingZonesInput | ShippingMethodUpsertWithWhereUniqueWithoutShippingZonesInput[]
    set?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    disconnect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    delete?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    connect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    update?: ShippingMethodUpdateWithWhereUniqueWithoutShippingZonesInput | ShippingMethodUpdateWithWhereUniqueWithoutShippingZonesInput[]
    updateMany?: ShippingMethodUpdateManyWithWhereWithoutShippingZonesInput | ShippingMethodUpdateManyWithWhereWithoutShippingZonesInput[]
    deleteMany?: ShippingMethodScalarWhereInput | ShippingMethodScalarWhereInput[]
  }

  export type ShippingCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ShippingCreateWithoutAuditLogsInput, ShippingUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ShippingCreateOrConnectWithoutAuditLogsInput
    connect?: ShippingWhereUniqueInput
  }

  export type ShippingUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<ShippingCreateWithoutAuditLogsInput, ShippingUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ShippingCreateOrConnectWithoutAuditLogsInput
    upsert?: ShippingUpsertWithoutAuditLogsInput
    connect?: ShippingWhereUniqueInput
    update?: XOR<XOR<ShippingUpdateToOneWithWhereWithoutAuditLogsInput, ShippingUpdateWithoutAuditLogsInput>, ShippingUncheckedUpdateWithoutAuditLogsInput>
  }

  export type OrganizationCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<OrganizationCreateWithoutSubscriptionInput, OrganizationUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscriptionInput
    connect?: OrganizationWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type OrganizationUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<OrganizationCreateWithoutSubscriptionInput, OrganizationUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubscriptionInput
    upsert?: OrganizationUpsertWithoutSubscriptionInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSubscriptionInput, OrganizationUpdateWithoutSubscriptionInput>, OrganizationUncheckedUpdateWithoutSubscriptionInput>
  }

  export type OrganizationCreateNestedOneWithoutTransactionInput = {
    create?: XOR<OrganizationCreateWithoutTransactionInput, OrganizationUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTransactionInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<OrganizationCreateWithoutTransactionInput, OrganizationUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTransactionInput
    upsert?: OrganizationUpsertWithoutTransactionInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTransactionInput, OrganizationUpdateWithoutTransactionInput>, OrganizationUncheckedUpdateWithoutTransactionInput>
  }

  export type ProductCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ProductCreateWithoutWarehouseInput, ProductUncheckedCreateWithoutWarehouseInput> | ProductCreateWithoutWarehouseInput[] | ProductUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutWarehouseInput | ProductCreateOrConnectWithoutWarehouseInput[]
    createMany?: ProductCreateManyWarehouseInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryCreateWithoutWarehouseInput, InventoryUncheckedCreateWithoutWarehouseInput> | InventoryCreateWithoutWarehouseInput[] | InventoryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutWarehouseInput | InventoryCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryCreateManyWarehouseInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutWarehouseInput = {
    create?: XOR<UserCreateWithoutWarehouseInput, UserUncheckedCreateWithoutWarehouseInput>
    connectOrCreate?: UserCreateOrConnectWithoutWarehouseInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutWarehouseInput = {
    create?: XOR<OrganizationCreateWithoutWarehouseInput, OrganizationUncheckedCreateWithoutWarehouseInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutWarehouseInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ProductCreateWithoutWarehouseInput, ProductUncheckedCreateWithoutWarehouseInput> | ProductCreateWithoutWarehouseInput[] | ProductUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutWarehouseInput | ProductCreateOrConnectWithoutWarehouseInput[]
    createMany?: ProductCreateManyWarehouseInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryCreateWithoutWarehouseInput, InventoryUncheckedCreateWithoutWarehouseInput> | InventoryCreateWithoutWarehouseInput[] | InventoryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutWarehouseInput | InventoryCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryCreateManyWarehouseInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ProductCreateWithoutWarehouseInput, ProductUncheckedCreateWithoutWarehouseInput> | ProductCreateWithoutWarehouseInput[] | ProductUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutWarehouseInput | ProductCreateOrConnectWithoutWarehouseInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutWarehouseInput | ProductUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ProductCreateManyWarehouseInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutWarehouseInput | ProductUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutWarehouseInput | ProductUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryCreateWithoutWarehouseInput, InventoryUncheckedCreateWithoutWarehouseInput> | InventoryCreateWithoutWarehouseInput[] | InventoryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutWarehouseInput | InventoryCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutWarehouseInput | InventoryUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryCreateManyWarehouseInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutWarehouseInput | InventoryUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutWarehouseInput | InventoryUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutWarehouseNestedInput = {
    create?: XOR<UserCreateWithoutWarehouseInput, UserUncheckedCreateWithoutWarehouseInput>
    connectOrCreate?: UserCreateOrConnectWithoutWarehouseInput
    upsert?: UserUpsertWithoutWarehouseInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWarehouseInput, UserUpdateWithoutWarehouseInput>, UserUncheckedUpdateWithoutWarehouseInput>
  }

  export type OrganizationUpdateOneRequiredWithoutWarehouseNestedInput = {
    create?: XOR<OrganizationCreateWithoutWarehouseInput, OrganizationUncheckedCreateWithoutWarehouseInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutWarehouseInput
    upsert?: OrganizationUpsertWithoutWarehouseInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutWarehouseInput, OrganizationUpdateWithoutWarehouseInput>, OrganizationUncheckedUpdateWithoutWarehouseInput>
  }

  export type ProductUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ProductCreateWithoutWarehouseInput, ProductUncheckedCreateWithoutWarehouseInput> | ProductCreateWithoutWarehouseInput[] | ProductUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutWarehouseInput | ProductCreateOrConnectWithoutWarehouseInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutWarehouseInput | ProductUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ProductCreateManyWarehouseInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutWarehouseInput | ProductUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutWarehouseInput | ProductUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryCreateWithoutWarehouseInput, InventoryUncheckedCreateWithoutWarehouseInput> | InventoryCreateWithoutWarehouseInput[] | InventoryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutWarehouseInput | InventoryCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutWarehouseInput | InventoryUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryCreateManyWarehouseInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutWarehouseInput | InventoryUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutWarehouseInput | InventoryUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryItemsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryItemsInput
    upsert?: ProductUpsertWithoutInventoryItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryItemsInput, ProductUpdateWithoutInventoryItemsInput>, ProductUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type WarehouseUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryItemsInput
    upsert?: WarehouseUpsertWithoutInventoryItemsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutInventoryItemsInput, WarehouseUpdateWithoutInventoryItemsInput>, WarehouseUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumProductStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProductStatusNullableFilter<$PrismaModel> | $Enums.ProductStatus | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumProductStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProductStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProductStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumProductStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumShippingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingStatus | EnumShippingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingStatus[] | ListEnumShippingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShippingStatus[] | ListEnumShippingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShippingStatusFilter<$PrismaModel> | $Enums.ShippingStatus
  }

  export type NestedEnumShippingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingStatus | EnumShippingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingStatus[] | ListEnumShippingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShippingStatus[] | ListEnumShippingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShippingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShippingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShippingStatusFilter<$PrismaModel>
    _max?: NestedEnumShippingStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type CartItemCreateWithoutCartInput = {
    id?: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateWithoutCartInput = {
    id?: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutCartInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateManyCartInputEnvelope = {
    data: CartItemCreateManyCartInput | CartItemCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCartInput = {
    id?: string
    createdBy?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    pos?: POSCreateNestedOneWithoutOrderInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    location?: LocationCreateNestedOneWithoutOrderInput
    store?: OrganizationCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCartInput = {
    id?: string
    customerId: string
    locationId: string
    createdBy?: string | null
    storeId?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    pos?: POSUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCartInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCartInput, OrderUncheckedCreateWithoutCartInput>
  }

  export type CustomerCreateWithoutCartsInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutCustomerInput
    pos?: POSCreateNestedManyWithoutCustomerInput
    customerGroupMember?: CustomerGroupMemberCreateNestedManyWithoutCustomerInput
    store?: OrganizationCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCartsInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutCustomerInput
    pos?: POSUncheckedCreateNestedManyWithoutCustomerInput
    customerGroupMember?: CustomerGroupMemberUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCartsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCartsInput, CustomerUncheckedCreateWithoutCartsInput>
  }

  export type CartItemUpsertWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithWhereWithoutCartInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutCartInput>
  }

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    OR?: CartItemScalarWhereInput[]
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    price?: FloatFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
  }

  export type OrderUpsertWithoutCartInput = {
    update: XOR<OrderUpdateWithoutCartInput, OrderUncheckedUpdateWithoutCartInput>
    create: XOR<OrderCreateWithoutCartInput, OrderUncheckedCreateWithoutCartInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutCartInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutCartInput, OrderUncheckedUpdateWithoutCartInput>
  }

  export type OrderUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    pos?: POSUpdateOneWithoutOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    location?: LocationUpdateOneWithoutOrderNestedInput
    store?: OrganizationUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    pos?: POSUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type CustomerUpsertWithoutCartsInput = {
    update: XOR<CustomerUpdateWithoutCartsInput, CustomerUncheckedUpdateWithoutCartsInput>
    create: XOR<CustomerCreateWithoutCartsInput, CustomerUncheckedCreateWithoutCartsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCartsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCartsInput, CustomerUncheckedUpdateWithoutCartsInput>
  }

  export type CustomerUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutCustomerNestedInput
    pos?: POSUpdateManyWithoutCustomerNestedInput
    customerGroupMember?: CustomerGroupMemberUpdateManyWithoutCustomerNestedInput
    store?: OrganizationUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    pos?: POSUncheckedUpdateManyWithoutCustomerNestedInput
    customerGroupMember?: CustomerGroupMemberUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CartCreateWithoutCartItemsInput = {
    id?: string
    storeId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutCartInput
    customer: CustomerCreateNestedOneWithoutCartsInput
  }

  export type CartUncheckedCreateWithoutCartItemsInput = {
    id?: string
    storeId: string
    customerId: string
    orderId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartCreateOrConnectWithoutCartItemsInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutCartItemsInput, CartUncheckedCreateWithoutCartItemsInput>
  }

  export type ProductCreateWithoutCartItemsInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredBrands?: FeaturedBrandsCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    collection?: ProductCollectionCreateNestedOneWithoutProductsInput
    purchase?: PurchaseCreateNestedOneWithoutProductsInput
    store: OrganizationCreateNestedOneWithoutProductInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryInput
    location?: LocationCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCartItemsInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
    featuredBrands?: FeaturedBrandsUncheckedCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCartItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
  }

  export type CartUpsertWithoutCartItemsInput = {
    update: XOR<CartUpdateWithoutCartItemsInput, CartUncheckedUpdateWithoutCartItemsInput>
    create: XOR<CartCreateWithoutCartItemsInput, CartUncheckedCreateWithoutCartItemsInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutCartItemsInput, CartUncheckedUpdateWithoutCartItemsInput>
  }

  export type CartUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutCartNestedInput
    customer?: CustomerUpdateOneRequiredWithoutCartsNestedInput
  }

  export type CartUncheckedUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutCartItemsInput = {
    update: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type ProductUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredBrands?: FeaturedBrandsUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    collection?: ProductCollectionUpdateOneWithoutProductsNestedInput
    purchase?: PurchaseUpdateOneWithoutProductsNestedInput
    store?: OrganizationUpdateOneRequiredWithoutProductNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryNestedInput
    location?: LocationUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredBrands?: FeaturedBrandsUncheckedUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    createdBy?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    pos?: POSCreateNestedOneWithoutOrderInput
    cart?: CartCreateNestedOneWithoutOrderInput
    location?: LocationCreateNestedOneWithoutOrderInput
    store?: OrganizationCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    locationId: string
    createdBy?: string | null
    storeId?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    pos?: POSUncheckedCreateNestedOneWithoutOrderInput
    cart?: CartUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CartCreateWithoutCustomerInput = {
    id?: string
    storeId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutCartInput
    order: OrderCreateNestedOneWithoutCartInput
  }

  export type CartUncheckedCreateWithoutCustomerInput = {
    id?: string
    storeId: string
    orderId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutCustomerInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput>
  }

  export type CartCreateManyCustomerInputEnvelope = {
    data: CartCreateManyCustomerInput | CartCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseHistoryCreateWithoutCustomerInput = {
    id?: string
    orderId: string
    totalAmount: number
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseHistoryUncheckedCreateWithoutCustomerInput = {
    id?: string
    orderId: string
    totalAmount: number
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseHistoryCreateOrConnectWithoutCustomerInput = {
    where: PurchaseHistoryWhereUniqueInput
    create: XOR<PurchaseHistoryCreateWithoutCustomerInput, PurchaseHistoryUncheckedCreateWithoutCustomerInput>
  }

  export type PurchaseHistoryCreateManyCustomerInputEnvelope = {
    data: PurchaseHistoryCreateManyCustomerInput | PurchaseHistoryCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type POSCreateWithoutCustomerInput = {
    id?: string
    terminalId: string
    confirmed?: boolean
    confirmedAt?: Date | string | null
    staff: UserCreateNestedOneWithoutPOSInput
    order: OrderCreateNestedOneWithoutPosInput
  }

  export type POSUncheckedCreateWithoutCustomerInput = {
    id?: string
    staffId: string
    orderId: string
    terminalId: string
    confirmed?: boolean
    confirmedAt?: Date | string | null
  }

  export type POSCreateOrConnectWithoutCustomerInput = {
    where: POSWhereUniqueInput
    create: XOR<POSCreateWithoutCustomerInput, POSUncheckedCreateWithoutCustomerInput>
  }

  export type POSCreateManyCustomerInputEnvelope = {
    data: POSCreateManyCustomerInput | POSCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerGroupMemberCreateWithoutCustomerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    customerGroup: CustomerGroupsCreateNestedOneWithoutCustomerGroupMemberInput
  }

  export type CustomerGroupMemberUncheckedCreateWithoutCustomerInput = {
    customerGroupId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerGroupMemberCreateOrConnectWithoutCustomerInput = {
    where: CustomerGroupMemberWhereUniqueInput
    create: XOR<CustomerGroupMemberCreateWithoutCustomerInput, CustomerGroupMemberUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerGroupMemberCreateManyCustomerInputEnvelope = {
    data: CustomerGroupMemberCreateManyCustomerInput | CustomerGroupMemberCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutCustomerInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutCustomerInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutCustomerInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutCustomerInput, OrganizationUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    customerId?: StringFilter<"Order"> | string
    locationId?: StringFilter<"Order"> | string
    createdBy?: StringNullableFilter<"Order"> | string | null
    storeId?: StringNullableFilter<"Order"> | string | null
    shippingMethodId?: StringNullableFilter<"Order"> | string | null
    grandTotal?: FloatFilter<"Order"> | number
    iscustomerAssigned?: BoolFilter<"Order"> | boolean
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"Order"> | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFilter<"Order"> | number
    totalAmount?: FloatFilter<"Order"> | number
    subtotalAmount?: FloatFilter<"Order"> | number
    discountAmount?: FloatNullableFilter<"Order"> | number | null
    taxAmount?: FloatFilter<"Order"> | number
    shippingFee?: FloatFilter<"Order"> | number
    shippingZoneName?: StringNullableFilter<"Order"> | string | null
    shippingAddress?: StringNullableFilter<"Order"> | string | null
    shippingStatus?: StringNullableFilter<"Order"> | string | null
    channel?: StringNullableFilter<"Order"> | string | null
    isposConfirmed?: BoolNullableFilter<"Order"> | boolean | null
    customerName?: StringFilter<"Order"> | string
    customerEmail?: StringFilter<"Order"> | string
    customerPhoneNumber?: StringFilter<"Order"> | string
    posConfirmedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type CartUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CartWhereUniqueInput
    update: XOR<CartUpdateWithoutCustomerInput, CartUncheckedUpdateWithoutCustomerInput>
    create: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput>
  }

  export type CartUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CartWhereUniqueInput
    data: XOR<CartUpdateWithoutCustomerInput, CartUncheckedUpdateWithoutCustomerInput>
  }

  export type CartUpdateManyWithWhereWithoutCustomerInput = {
    where: CartScalarWhereInput
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CartScalarWhereInput = {
    AND?: CartScalarWhereInput | CartScalarWhereInput[]
    OR?: CartScalarWhereInput[]
    NOT?: CartScalarWhereInput | CartScalarWhereInput[]
    id?: StringFilter<"Cart"> | string
    storeId?: StringFilter<"Cart"> | string
    customerId?: StringFilter<"Cart"> | string
    orderId?: StringFilter<"Cart"> | string
    totalAmount?: FloatFilter<"Cart"> | number
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
  }

  export type PurchaseHistoryUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PurchaseHistoryWhereUniqueInput
    update: XOR<PurchaseHistoryUpdateWithoutCustomerInput, PurchaseHistoryUncheckedUpdateWithoutCustomerInput>
    create: XOR<PurchaseHistoryCreateWithoutCustomerInput, PurchaseHistoryUncheckedCreateWithoutCustomerInput>
  }

  export type PurchaseHistoryUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PurchaseHistoryWhereUniqueInput
    data: XOR<PurchaseHistoryUpdateWithoutCustomerInput, PurchaseHistoryUncheckedUpdateWithoutCustomerInput>
  }

  export type PurchaseHistoryUpdateManyWithWhereWithoutCustomerInput = {
    where: PurchaseHistoryScalarWhereInput
    data: XOR<PurchaseHistoryUpdateManyMutationInput, PurchaseHistoryUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PurchaseHistoryScalarWhereInput = {
    AND?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
    OR?: PurchaseHistoryScalarWhereInput[]
    NOT?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
    id?: StringFilter<"PurchaseHistory"> | string
    orderId?: StringFilter<"PurchaseHistory"> | string
    totalAmount?: FloatFilter<"PurchaseHistory"> | number
    date?: DateTimeFilter<"PurchaseHistory"> | Date | string
    customerId?: StringFilter<"PurchaseHistory"> | string
    createdAt?: DateTimeFilter<"PurchaseHistory"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseHistory"> | Date | string
  }

  export type POSUpsertWithWhereUniqueWithoutCustomerInput = {
    where: POSWhereUniqueInput
    update: XOR<POSUpdateWithoutCustomerInput, POSUncheckedUpdateWithoutCustomerInput>
    create: XOR<POSCreateWithoutCustomerInput, POSUncheckedCreateWithoutCustomerInput>
  }

  export type POSUpdateWithWhereUniqueWithoutCustomerInput = {
    where: POSWhereUniqueInput
    data: XOR<POSUpdateWithoutCustomerInput, POSUncheckedUpdateWithoutCustomerInput>
  }

  export type POSUpdateManyWithWhereWithoutCustomerInput = {
    where: POSScalarWhereInput
    data: XOR<POSUpdateManyMutationInput, POSUncheckedUpdateManyWithoutCustomerInput>
  }

  export type POSScalarWhereInput = {
    AND?: POSScalarWhereInput | POSScalarWhereInput[]
    OR?: POSScalarWhereInput[]
    NOT?: POSScalarWhereInput | POSScalarWhereInput[]
    id?: StringFilter<"POS"> | string
    staffId?: StringFilter<"POS"> | string
    orderId?: StringFilter<"POS"> | string
    customerId?: StringFilter<"POS"> | string
    terminalId?: StringFilter<"POS"> | string
    confirmed?: BoolFilter<"POS"> | boolean
    confirmedAt?: DateTimeNullableFilter<"POS"> | Date | string | null
  }

  export type CustomerGroupMemberUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerGroupMemberWhereUniqueInput
    update: XOR<CustomerGroupMemberUpdateWithoutCustomerInput, CustomerGroupMemberUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerGroupMemberCreateWithoutCustomerInput, CustomerGroupMemberUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerGroupMemberUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerGroupMemberWhereUniqueInput
    data: XOR<CustomerGroupMemberUpdateWithoutCustomerInput, CustomerGroupMemberUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerGroupMemberUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerGroupMemberScalarWhereInput
    data: XOR<CustomerGroupMemberUpdateManyMutationInput, CustomerGroupMemberUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerGroupMemberScalarWhereInput = {
    AND?: CustomerGroupMemberScalarWhereInput | CustomerGroupMemberScalarWhereInput[]
    OR?: CustomerGroupMemberScalarWhereInput[]
    NOT?: CustomerGroupMemberScalarWhereInput | CustomerGroupMemberScalarWhereInput[]
    customerId?: StringFilter<"CustomerGroupMember"> | string
    customerGroupId?: StringFilter<"CustomerGroupMember"> | string
    createdAt?: DateTimeFilter<"CustomerGroupMember"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerGroupMember"> | Date | string
  }

  export type OrganizationUpsertWithoutCustomerInput = {
    update: XOR<OrganizationUpdateWithoutCustomerInput, OrganizationUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrganizationCreateWithoutCustomerInput, OrganizationUncheckedCreateWithoutCustomerInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutCustomerInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutCustomerInput, OrganizationUncheckedUpdateWithoutCustomerInput>
  }

  export type OrganizationUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type CustomerCreateWithoutPurchaseHistoryInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    pos?: POSCreateNestedManyWithoutCustomerInput
    customerGroupMember?: CustomerGroupMemberCreateNestedManyWithoutCustomerInput
    store?: OrganizationCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPurchaseHistoryInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    pos?: POSUncheckedCreateNestedManyWithoutCustomerInput
    customerGroupMember?: CustomerGroupMemberUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPurchaseHistoryInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPurchaseHistoryInput, CustomerUncheckedCreateWithoutPurchaseHistoryInput>
  }

  export type CustomerUpsertWithoutPurchaseHistoryInput = {
    update: XOR<CustomerUpdateWithoutPurchaseHistoryInput, CustomerUncheckedUpdateWithoutPurchaseHistoryInput>
    create: XOR<CustomerCreateWithoutPurchaseHistoryInput, CustomerUncheckedCreateWithoutPurchaseHistoryInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPurchaseHistoryInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPurchaseHistoryInput, CustomerUncheckedUpdateWithoutPurchaseHistoryInput>
  }

  export type CustomerUpdateWithoutPurchaseHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    pos?: POSUpdateManyWithoutCustomerNestedInput
    customerGroupMember?: CustomerGroupMemberUpdateManyWithoutCustomerNestedInput
    store?: OrganizationUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPurchaseHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    pos?: POSUncheckedUpdateManyWithoutCustomerNestedInput
    customerGroupMember?: CustomerGroupMemberUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrganizationCreateWithoutCustomerGroupsInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutCustomerGroupsInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutCustomerGroupsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutCustomerGroupsInput, OrganizationUncheckedCreateWithoutCustomerGroupsInput>
  }

  export type CustomerGroupMemberCreateWithoutCustomerGroupInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCustomerGroupMemberInput
  }

  export type CustomerGroupMemberUncheckedCreateWithoutCustomerGroupInput = {
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerGroupMemberCreateOrConnectWithoutCustomerGroupInput = {
    where: CustomerGroupMemberWhereUniqueInput
    create: XOR<CustomerGroupMemberCreateWithoutCustomerGroupInput, CustomerGroupMemberUncheckedCreateWithoutCustomerGroupInput>
  }

  export type CustomerGroupMemberCreateManyCustomerGroupInputEnvelope = {
    data: CustomerGroupMemberCreateManyCustomerGroupInput | CustomerGroupMemberCreateManyCustomerGroupInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutCustomerGroupsInput = {
    update: XOR<OrganizationUpdateWithoutCustomerGroupsInput, OrganizationUncheckedUpdateWithoutCustomerGroupsInput>
    create: XOR<OrganizationCreateWithoutCustomerGroupsInput, OrganizationUncheckedCreateWithoutCustomerGroupsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutCustomerGroupsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutCustomerGroupsInput, OrganizationUncheckedUpdateWithoutCustomerGroupsInput>
  }

  export type OrganizationUpdateWithoutCustomerGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutCustomerGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type CustomerGroupMemberUpsertWithWhereUniqueWithoutCustomerGroupInput = {
    where: CustomerGroupMemberWhereUniqueInput
    update: XOR<CustomerGroupMemberUpdateWithoutCustomerGroupInput, CustomerGroupMemberUncheckedUpdateWithoutCustomerGroupInput>
    create: XOR<CustomerGroupMemberCreateWithoutCustomerGroupInput, CustomerGroupMemberUncheckedCreateWithoutCustomerGroupInput>
  }

  export type CustomerGroupMemberUpdateWithWhereUniqueWithoutCustomerGroupInput = {
    where: CustomerGroupMemberWhereUniqueInput
    data: XOR<CustomerGroupMemberUpdateWithoutCustomerGroupInput, CustomerGroupMemberUncheckedUpdateWithoutCustomerGroupInput>
  }

  export type CustomerGroupMemberUpdateManyWithWhereWithoutCustomerGroupInput = {
    where: CustomerGroupMemberScalarWhereInput
    data: XOR<CustomerGroupMemberUpdateManyMutationInput, CustomerGroupMemberUncheckedUpdateManyWithoutCustomerGroupInput>
  }

  export type CustomerCreateWithoutCustomerGroupMemberInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutCustomerInput
    pos?: POSCreateNestedManyWithoutCustomerInput
    store?: OrganizationCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomerGroupMemberInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutCustomerInput
    pos?: POSUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomerGroupMemberInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerGroupMemberInput, CustomerUncheckedCreateWithoutCustomerGroupMemberInput>
  }

  export type CustomerGroupsCreateWithoutCustomerGroupMemberInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutCustomerGroupsInput
  }

  export type CustomerGroupsUncheckedCreateWithoutCustomerGroupMemberInput = {
    id?: string
    name: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerGroupsCreateOrConnectWithoutCustomerGroupMemberInput = {
    where: CustomerGroupsWhereUniqueInput
    create: XOR<CustomerGroupsCreateWithoutCustomerGroupMemberInput, CustomerGroupsUncheckedCreateWithoutCustomerGroupMemberInput>
  }

  export type CustomerUpsertWithoutCustomerGroupMemberInput = {
    update: XOR<CustomerUpdateWithoutCustomerGroupMemberInput, CustomerUncheckedUpdateWithoutCustomerGroupMemberInput>
    create: XOR<CustomerCreateWithoutCustomerGroupMemberInput, CustomerUncheckedCreateWithoutCustomerGroupMemberInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerGroupMemberInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerGroupMemberInput, CustomerUncheckedUpdateWithoutCustomerGroupMemberInput>
  }

  export type CustomerUpdateWithoutCustomerGroupMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutCustomerNestedInput
    pos?: POSUpdateManyWithoutCustomerNestedInput
    store?: OrganizationUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerGroupMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    pos?: POSUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerGroupsUpsertWithoutCustomerGroupMemberInput = {
    update: XOR<CustomerGroupsUpdateWithoutCustomerGroupMemberInput, CustomerGroupsUncheckedUpdateWithoutCustomerGroupMemberInput>
    create: XOR<CustomerGroupsCreateWithoutCustomerGroupMemberInput, CustomerGroupsUncheckedCreateWithoutCustomerGroupMemberInput>
    where?: CustomerGroupsWhereInput
  }

  export type CustomerGroupsUpdateToOneWithWhereWithoutCustomerGroupMemberInput = {
    where?: CustomerGroupsWhereInput
    data: XOR<CustomerGroupsUpdateWithoutCustomerGroupMemberInput, CustomerGroupsUncheckedUpdateWithoutCustomerGroupMemberInput>
  }

  export type CustomerGroupsUpdateWithoutCustomerGroupMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutCustomerGroupsNestedInput
  }

  export type CustomerGroupsUncheckedUpdateWithoutCustomerGroupMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryCreateWithoutExpenseInput = {
    id?: string
    name: string
    description: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCategoryUncheckedCreateWithoutExpenseInput = {
    id?: string
    name: string
    description: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCategoryCreateOrConnectWithoutExpenseInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutExpenseInput, ExpenseCategoryUncheckedCreateWithoutExpenseInput>
  }

  export type ExpenseCategoryCreateManyExpenseInputEnvelope = {
    data: ExpenseCategoryCreateManyExpenseInput | ExpenseCategoryCreateManyExpenseInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutExpenseInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutExpenseInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutExpenseInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutExpenseInput, OrganizationUncheckedCreateWithoutExpenseInput>
  }

  export type ExpenseCategoryUpsertWithWhereUniqueWithoutExpenseInput = {
    where: ExpenseCategoryWhereUniqueInput
    update: XOR<ExpenseCategoryUpdateWithoutExpenseInput, ExpenseCategoryUncheckedUpdateWithoutExpenseInput>
    create: XOR<ExpenseCategoryCreateWithoutExpenseInput, ExpenseCategoryUncheckedCreateWithoutExpenseInput>
  }

  export type ExpenseCategoryUpdateWithWhereUniqueWithoutExpenseInput = {
    where: ExpenseCategoryWhereUniqueInput
    data: XOR<ExpenseCategoryUpdateWithoutExpenseInput, ExpenseCategoryUncheckedUpdateWithoutExpenseInput>
  }

  export type ExpenseCategoryUpdateManyWithWhereWithoutExpenseInput = {
    where: ExpenseCategoryScalarWhereInput
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyWithoutExpenseInput>
  }

  export type ExpenseCategoryScalarWhereInput = {
    AND?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
    OR?: ExpenseCategoryScalarWhereInput[]
    NOT?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
    id?: StringFilter<"ExpenseCategory"> | string
    name?: StringFilter<"ExpenseCategory"> | string
    description?: StringFilter<"ExpenseCategory"> | string
    date?: DateTimeFilter<"ExpenseCategory"> | Date | string
    expenseId?: StringFilter<"ExpenseCategory"> | string
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
  }

  export type OrganizationUpsertWithoutExpenseInput = {
    update: XOR<OrganizationUpdateWithoutExpenseInput, OrganizationUncheckedUpdateWithoutExpenseInput>
    create: XOR<OrganizationCreateWithoutExpenseInput, OrganizationUncheckedCreateWithoutExpenseInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutExpenseInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutExpenseInput, OrganizationUncheckedUpdateWithoutExpenseInput>
  }

  export type OrganizationUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ExpenseCreateWithoutExpenseCategoryInput = {
    id?: string
    name?: string | null
    amount?: number | null
    description?: string | null
    paymentMethod?: string | null
    paymentStatus?: string | null
    date?: Date | string | null
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutExpenseCategoryInput = {
    id?: string
    name?: string | null
    amount?: number | null
    description?: string | null
    paymentMethod?: string | null
    paymentStatus?: string | null
    date?: Date | string | null
    locationId: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutExpenseCategoryInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutExpenseCategoryInput, ExpenseUncheckedCreateWithoutExpenseCategoryInput>
  }

  export type ExpenseUpsertWithoutExpenseCategoryInput = {
    update: XOR<ExpenseUpdateWithoutExpenseCategoryInput, ExpenseUncheckedUpdateWithoutExpenseCategoryInput>
    create: XOR<ExpenseCreateWithoutExpenseCategoryInput, ExpenseUncheckedCreateWithoutExpenseCategoryInput>
    where?: ExpenseWhereInput
  }

  export type ExpenseUpdateToOneWithWhereWithoutExpenseCategoryInput = {
    where?: ExpenseWhereInput
    data: XOR<ExpenseUpdateWithoutExpenseCategoryInput, ExpenseUncheckedUpdateWithoutExpenseCategoryInput>
  }

  export type ExpenseUpdateWithoutExpenseCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutExpenseCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutBankDetailsInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutBankDetailsInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutBankDetailsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutBankDetailsInput, OrganizationUncheckedCreateWithoutBankDetailsInput>
  }

  export type OrganizationUpsertWithoutBankDetailsInput = {
    update: XOR<OrganizationUpdateWithoutBankDetailsInput, OrganizationUncheckedUpdateWithoutBankDetailsInput>
    create: XOR<OrganizationCreateWithoutBankDetailsInput, OrganizationUncheckedCreateWithoutBankDetailsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutBankDetailsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutBankDetailsInput, OrganizationUncheckedUpdateWithoutBankDetailsInput>
  }

  export type OrganizationUpdateWithoutBankDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutBankDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationCreateWithoutWalletInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutWalletInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutWalletInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutWalletInput, OrganizationUncheckedCreateWithoutWalletInput>
  }

  export type OrganizationUpsertWithoutWalletInput = {
    update: XOR<OrganizationUpdateWithoutWalletInput, OrganizationUncheckedUpdateWithoutWalletInput>
    create: XOR<OrganizationCreateWithoutWalletInput, OrganizationUncheckedCreateWithoutWalletInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutWalletInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutWalletInput, OrganizationUncheckedUpdateWithoutWalletInput>
  }

  export type OrganizationUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationCreateWithoutInvoiceInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutInvoiceInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutInvoiceInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutInvoiceInput, OrganizationUncheckedCreateWithoutInvoiceInput>
  }

  export type OrganizationUpsertWithoutInvoiceInput = {
    update: XOR<OrganizationUpdateWithoutInvoiceInput, OrganizationUncheckedUpdateWithoutInvoiceInput>
    create: XOR<OrganizationCreateWithoutInvoiceInput, OrganizationUncheckedCreateWithoutInvoiceInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutInvoiceInput, OrganizationUncheckedUpdateWithoutInvoiceInput>
  }

  export type OrganizationUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserCreateWithoutLocationInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    PointOfSale?: PointOfSaleCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseCreateNestedOneWithoutStaffAssignedInput
    POS?: POSCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutLocationInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    PointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseUncheckedCreateNestedOneWithoutStaffAssignedInput
    POS?: POSUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutLocationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
  }

  export type UserCreateManyLocationInputEnvelope = {
    data: UserCreateManyLocationInput | UserCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutLocationInput = {
    id?: string
    createdBy?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    pos?: POSCreateNestedOneWithoutOrderInput
    cart?: CartCreateNestedOneWithoutOrderInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    store?: OrganizationCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutLocationInput = {
    id?: string
    customerId: string
    createdBy?: string | null
    storeId?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    pos?: POSUncheckedCreateNestedOneWithoutOrderInput
    cart?: CartUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutLocationInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput>
  }

  export type OrderCreateManyLocationInputEnvelope = {
    data: OrderCreateManyLocationInput | OrderCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutLocationInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredBrands?: FeaturedBrandsCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    collection?: ProductCollectionCreateNestedOneWithoutProductsInput
    purchase?: PurchaseCreateNestedOneWithoutProductsInput
    store: OrganizationCreateNestedOneWithoutProductInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryInput
  }

  export type ProductUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
    featuredBrands?: FeaturedBrandsUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutLocationInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutLocationInput, ProductUncheckedCreateWithoutLocationInput>
  }

  export type ProductCreateManyLocationInputEnvelope = {
    data: ProductCreateManyLocationInput | ProductCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutLocationInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutLocationInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutLocationInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutLocationInput, OrganizationUncheckedCreateWithoutLocationInput>
  }

  export type UserUpsertWithWhereUniqueWithoutLocationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLocationInput, UserUncheckedUpdateWithoutLocationInput>
    create: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLocationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLocationInput, UserUncheckedUpdateWithoutLocationInput>
  }

  export type UserUpdateManyWithWhereWithoutLocationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutLocationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    middleName?: StringNullableFilter<"User"> | string | null
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    image?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    locationId?: StringNullableFilter<"User"> | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutLocationInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutLocationInput, OrderUncheckedUpdateWithoutLocationInput>
    create: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutLocationInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutLocationInput, OrderUncheckedUpdateWithoutLocationInput>
  }

  export type OrderUpdateManyWithWhereWithoutLocationInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutLocationInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutLocationInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutLocationInput, ProductUncheckedUpdateWithoutLocationInput>
    create: XOR<ProductCreateWithoutLocationInput, ProductUncheckedCreateWithoutLocationInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutLocationInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutLocationInput, ProductUncheckedUpdateWithoutLocationInput>
  }

  export type ProductUpdateManyWithWhereWithoutLocationInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutLocationInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    shortDescription?: StringNullableFilter<"Product"> | string | null
    description?: StringNullableFilter<"Product"> | string | null
    sku?: StringNullableFilter<"Product"> | string | null
    stock?: IntNullableFilter<"Product"> | number | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    shippingWeight?: StringNullableFilter<"Product"> | string | null
    handleTime?: StringNullableFilter<"Product"> | string | null
    freeShipping?: BoolNullableFilter<"Product"> | boolean | null
    packaging?: StringNullableFilter<"Product"> | string | null
    discountPrice?: StringNullableFilter<"Product"> | string | null
    unitSold?: StringNullableFilter<"Product"> | string | null
    length?: FloatNullableFilter<"Product"> | number | null
    width?: FloatNullableFilter<"Product"> | number | null
    height?: FloatNullableFilter<"Product"> | number | null
    productSize?: StringNullableFilter<"Product"> | string | null
    productStatus?: EnumProductStatusNullableFilter<"Product"> | $Enums.ProductStatus | null
    imageUrl?: StringNullableListFilter<"Product">
    storeId?: StringFilter<"Product"> | string
    locationId?: StringNullableFilter<"Product"> | string | null
    purchaseOrderId?: StringNullableFilter<"Product"> | string | null
    collectionId?: StringNullableFilter<"Product"> | string | null
    hasVariation?: BoolNullableFilter<"Product"> | boolean | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    warehouseId?: StringNullableFilter<"Product"> | string | null
  }

  export type OrganizationUpsertWithoutLocationInput = {
    update: XOR<OrganizationUpdateWithoutLocationInput, OrganizationUncheckedUpdateWithoutLocationInput>
    create: XOR<OrganizationCreateWithoutLocationInput, OrganizationUncheckedCreateWithoutLocationInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutLocationInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutLocationInput, OrganizationUncheckedUpdateWithoutLocationInput>
  }

  export type OrganizationUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity: number
    price: number
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    quantity: number
    price: number
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type POSCreateWithoutOrderInput = {
    id?: string
    terminalId: string
    confirmed?: boolean
    confirmedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutPosInput
    staff: UserCreateNestedOneWithoutPOSInput
  }

  export type POSUncheckedCreateWithoutOrderInput = {
    id?: string
    staffId: string
    customerId: string
    terminalId: string
    confirmed?: boolean
    confirmedAt?: Date | string | null
  }

  export type POSCreateOrConnectWithoutOrderInput = {
    where: POSWhereUniqueInput
    create: XOR<POSCreateWithoutOrderInput, POSUncheckedCreateWithoutOrderInput>
  }

  export type CartCreateWithoutOrderInput = {
    id?: string
    storeId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutCartInput
    customer: CustomerCreateNestedOneWithoutCartsInput
  }

  export type CartUncheckedCreateWithoutOrderInput = {
    id?: string
    storeId: string
    customerId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutOrderInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutOrderInput, CartUncheckedCreateWithoutOrderInput>
  }

  export type CustomerCreateWithoutOrdersInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutCustomerInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutCustomerInput
    pos?: POSCreateNestedManyWithoutCustomerInput
    customerGroupMember?: CustomerGroupMemberCreateNestedManyWithoutCustomerInput
    store?: OrganizationCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutCustomerInput
    pos?: POSUncheckedCreateNestedManyWithoutCustomerInput
    customerGroupMember?: CustomerGroupMemberUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type LocationCreateWithoutOrderInput = {
    id?: string
    name: string
    address?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    description?: string | null
    isdefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedManyWithoutLocationInput
    product?: ProductCreateNestedManyWithoutLocationInput
    store: OrganizationCreateNestedOneWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutOrderInput = {
    id?: string
    name: string
    address?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    description?: string | null
    storeId: string
    isdefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedManyWithoutLocationInput
    product?: ProductUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutOrderInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutOrderInput, LocationUncheckedCreateWithoutOrderInput>
  }

  export type OrganizationCreateWithoutOrderInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutOrderInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutOrderInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrderInput, OrganizationUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    orderId?: StringFilter<"OrderItem"> | string
  }

  export type POSUpsertWithoutOrderInput = {
    update: XOR<POSUpdateWithoutOrderInput, POSUncheckedUpdateWithoutOrderInput>
    create: XOR<POSCreateWithoutOrderInput, POSUncheckedCreateWithoutOrderInput>
    where?: POSWhereInput
  }

  export type POSUpdateToOneWithWhereWithoutOrderInput = {
    where?: POSWhereInput
    data: XOR<POSUpdateWithoutOrderInput, POSUncheckedUpdateWithoutOrderInput>
  }

  export type POSUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutPosNestedInput
    staff?: UserUpdateOneRequiredWithoutPOSNestedInput
  }

  export type POSUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CartUpsertWithoutOrderInput = {
    update: XOR<CartUpdateWithoutOrderInput, CartUncheckedUpdateWithoutOrderInput>
    create: XOR<CartCreateWithoutOrderInput, CartUncheckedCreateWithoutOrderInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutOrderInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutOrderInput, CartUncheckedUpdateWithoutOrderInput>
  }

  export type CartUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutCartNestedInput
    customer?: CustomerUpdateOneRequiredWithoutCartsNestedInput
  }

  export type CartUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutCustomerNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutCustomerNestedInput
    pos?: POSUpdateManyWithoutCustomerNestedInput
    customerGroupMember?: CustomerGroupMemberUpdateManyWithoutCustomerNestedInput
    store?: OrganizationUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    pos?: POSUncheckedUpdateManyWithoutCustomerNestedInput
    customerGroupMember?: CustomerGroupMemberUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type LocationUpsertWithoutOrderInput = {
    update: XOR<LocationUpdateWithoutOrderInput, LocationUncheckedUpdateWithoutOrderInput>
    create: XOR<LocationCreateWithoutOrderInput, LocationUncheckedCreateWithoutOrderInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutOrderInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutOrderInput, LocationUncheckedUpdateWithoutOrderInput>
  }

  export type LocationUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateManyWithoutLocationNestedInput
    product?: ProductUpdateManyWithoutLocationNestedInput
    store?: OrganizationUpdateOneRequiredWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateManyWithoutLocationNestedInput
    product?: ProductUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type OrganizationUpsertWithoutOrderInput = {
    update: XOR<OrganizationUpdateWithoutOrderInput, OrganizationUncheckedUpdateWithoutOrderInput>
    create: XOR<OrganizationCreateWithoutOrderInput, OrganizationUncheckedCreateWithoutOrderInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutOrderInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutOrderInput, OrganizationUncheckedUpdateWithoutOrderInput>
  }

  export type OrganizationUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type OrderCreateWithoutOrderItemsInput = {
    id?: string
    createdBy?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pos?: POSCreateNestedOneWithoutOrderInput
    cart?: CartCreateNestedOneWithoutOrderInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    location?: LocationCreateNestedOneWithoutOrderInput
    store?: OrganizationCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    customerId: string
    locationId: string
    createdBy?: string | null
    storeId?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pos?: POSUncheckedCreateNestedOneWithoutOrderInput
    cart?: CartUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pos?: POSUpdateOneWithoutOrderNestedInput
    cart?: CartUpdateOneWithoutOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    location?: LocationUpdateOneWithoutOrderNestedInput
    store?: OrganizationUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pos?: POSUncheckedUpdateOneWithoutOrderNestedInput
    cart?: CartUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type CustomerCreateWithoutPosInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutCustomerInput
    customerGroupMember?: CustomerGroupMemberCreateNestedManyWithoutCustomerInput
    store?: OrganizationCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPosInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    storeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutCustomerInput
    customerGroupMember?: CustomerGroupMemberUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPosInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPosInput, CustomerUncheckedCreateWithoutPosInput>
  }

  export type UserCreateWithoutPOSInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    PointOfSale?: PointOfSaleCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseCreateNestedOneWithoutStaffAssignedInput
  }

  export type UserUncheckedCreateWithoutPOSInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    PointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseUncheckedCreateNestedOneWithoutStaffAssignedInput
  }

  export type UserCreateOrConnectWithoutPOSInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPOSInput, UserUncheckedCreateWithoutPOSInput>
  }

  export type OrderCreateWithoutPosInput = {
    id?: string
    createdBy?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    cart?: CartCreateNestedOneWithoutOrderInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    location?: LocationCreateNestedOneWithoutOrderInput
    store?: OrganizationCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPosInput = {
    id?: string
    customerId: string
    locationId: string
    createdBy?: string | null
    storeId?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    cart?: CartUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPosInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPosInput, OrderUncheckedCreateWithoutPosInput>
  }

  export type CustomerUpsertWithoutPosInput = {
    update: XOR<CustomerUpdateWithoutPosInput, CustomerUncheckedUpdateWithoutPosInput>
    create: XOR<CustomerCreateWithoutPosInput, CustomerUncheckedCreateWithoutPosInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPosInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPosInput, CustomerUncheckedUpdateWithoutPosInput>
  }

  export type CustomerUpdateWithoutPosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutCustomerNestedInput
    customerGroupMember?: CustomerGroupMemberUpdateManyWithoutCustomerNestedInput
    store?: OrganizationUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    customerGroupMember?: CustomerGroupMemberUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutPOSInput = {
    update: XOR<UserUpdateWithoutPOSInput, UserUncheckedUpdateWithoutPOSInput>
    create: XOR<UserCreateWithoutPOSInput, UserUncheckedCreateWithoutPOSInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPOSInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPOSInput, UserUncheckedUpdateWithoutPOSInput>
  }

  export type UserUpdateWithoutPOSInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    PointOfSale?: PointOfSaleUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUpdateOneWithoutStaffAssignedNestedInput
  }

  export type UserUncheckedUpdateWithoutPOSInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    PointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUncheckedUpdateOneWithoutStaffAssignedNestedInput
  }

  export type OrderUpsertWithoutPosInput = {
    update: XOR<OrderUpdateWithoutPosInput, OrderUncheckedUpdateWithoutPosInput>
    create: XOR<OrderCreateWithoutPosInput, OrderUncheckedCreateWithoutPosInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPosInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPosInput, OrderUncheckedUpdateWithoutPosInput>
  }

  export type OrderUpdateWithoutPosInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    cart?: CartUpdateOneWithoutOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    location?: LocationUpdateOneWithoutOrderNestedInput
    store?: OrganizationUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPosInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    cart?: CartUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrganizationCreateWithoutPointOfSaleInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutPointOfSaleInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutPointOfSaleInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutPointOfSaleInput, OrganizationUncheckedCreateWithoutPointOfSaleInput>
  }

  export type UserCreateWithoutPointOfSaleInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    warehouse?: WarehouseCreateNestedOneWithoutStaffAssignedInput
    POS?: POSCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutPointOfSaleInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    warehouse?: WarehouseUncheckedCreateNestedOneWithoutStaffAssignedInput
    POS?: POSUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutPointOfSaleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPointOfSaleInput, UserUncheckedCreateWithoutPointOfSaleInput>
  }

  export type OrganizationUpsertWithoutPointOfSaleInput = {
    update: XOR<OrganizationUpdateWithoutPointOfSaleInput, OrganizationUncheckedUpdateWithoutPointOfSaleInput>
    create: XOR<OrganizationCreateWithoutPointOfSaleInput, OrganizationUncheckedCreateWithoutPointOfSaleInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutPointOfSaleInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutPointOfSaleInput, OrganizationUncheckedUpdateWithoutPointOfSaleInput>
  }

  export type OrganizationUpdateWithoutPointOfSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutPointOfSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserUpsertWithoutPointOfSaleInput = {
    update: XOR<UserUpdateWithoutPointOfSaleInput, UserUncheckedUpdateWithoutPointOfSaleInput>
    create: XOR<UserCreateWithoutPointOfSaleInput, UserUncheckedCreateWithoutPointOfSaleInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPointOfSaleInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPointOfSaleInput, UserUncheckedUpdateWithoutPointOfSaleInput>
  }

  export type UserUpdateWithoutPointOfSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    warehouse?: WarehouseUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutPointOfSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    warehouse?: WarehouseUncheckedUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type FeaturedBrandsCreateWithoutProductInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedBrandsUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedBrandsCreateOrConnectWithoutProductInput = {
    where: FeaturedBrandsWhereUniqueInput
    create: XOR<FeaturedBrandsCreateWithoutProductInput, FeaturedBrandsUncheckedCreateWithoutProductInput>
  }

  export type FeaturedBrandsCreateManyProductInputEnvelope = {
    data: FeaturedBrandsCreateManyProductInput | FeaturedBrandsCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CartItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateWithoutProductInput = {
    id?: string
    cartId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutProductInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemCreateManyProductInputEnvelope = {
    data: CartItemCreateManyProductInput | CartItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductVariationCreateWithoutProductInput = {
    id?: string
    sku: string
    price: number
    cost?: number | null
    discountPrice?: number | null
    stock?: number
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ProductVariationOptionCreateNestedManyWithoutVariationInput
  }

  export type ProductVariationUncheckedCreateWithoutProductInput = {
    id?: string
    sku: string
    price: number
    cost?: number | null
    discountPrice?: number | null
    stock?: number
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ProductVariationOptionUncheckedCreateNestedManyWithoutVariationInput
  }

  export type ProductVariationCreateOrConnectWithoutProductInput = {
    where: ProductVariationWhereUniqueInput
    create: XOR<ProductVariationCreateWithoutProductInput, ProductVariationUncheckedCreateWithoutProductInput>
  }

  export type ProductVariationCreateManyProductInputEnvelope = {
    data: ProductVariationCreateManyProductInput | ProductVariationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutProductInput = {
    id?: string
    name?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductInput = {
    id?: string
    name?: string | null
    description?: string | null
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateOrConnectWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
  }

  export type InventoryCreateWithoutProductInput = {
    id?: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryUncheckedCreateWithoutProductInput = {
    id?: string
    quantity?: number
    warehouseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateOrConnectWithoutProductInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type InventoryCreateManyProductInputEnvelope = {
    data: InventoryCreateManyProductInput | InventoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductCollectionCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCollectionUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCollectionCreateOrConnectWithoutProductsInput = {
    where: ProductCollectionWhereUniqueInput
    create: XOR<ProductCollectionCreateWithoutProductsInput, ProductCollectionUncheckedCreateWithoutProductsInput>
  }

  export type PurchaseCreateWithoutProductsInput = {
    id?: string
    status: string
    downloadUrl: string
    toalCost: Decimal | DecimalJsLike | number | string
    deliveryDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeSupplier: SupplierCreateNestedOneWithoutPurchaseInput
    store: OrganizationCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutProductsInput = {
    id?: string
    status: string
    downloadUrl: string
    toalCost: Decimal | DecimalJsLike | number | string
    storeSupplierId: string
    storeId: string
    deliveryDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutProductsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutProductsInput, PurchaseUncheckedCreateWithoutProductsInput>
  }

  export type OrganizationCreateWithoutProductInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutProductInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutProductInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProductInput, OrganizationUncheckedCreateWithoutProductInput>
  }

  export type WarehouseCreateWithoutInventoryInput = {
    id?: string
    name: string
    isDefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryCreateNestedManyWithoutWarehouseInput
    staffAssigned: UserCreateNestedOneWithoutWarehouseInput
    store: OrganizationCreateNestedOneWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutInventoryInput = {
    id?: string
    name: string
    isDefaultLocation?: boolean | null
    staffId: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutInventoryInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutInventoryInput, WarehouseUncheckedCreateWithoutInventoryInput>
  }

  export type LocationCreateWithoutProductInput = {
    id?: string
    name: string
    address?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    description?: string | null
    isdefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedManyWithoutLocationInput
    order?: OrderCreateNestedManyWithoutLocationInput
    store: OrganizationCreateNestedOneWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    address?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    description?: string | null
    storeId: string
    isdefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedManyWithoutLocationInput
    order?: OrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutProductInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutProductInput, LocationUncheckedCreateWithoutProductInput>
  }

  export type FeaturedBrandsUpsertWithWhereUniqueWithoutProductInput = {
    where: FeaturedBrandsWhereUniqueInput
    update: XOR<FeaturedBrandsUpdateWithoutProductInput, FeaturedBrandsUncheckedUpdateWithoutProductInput>
    create: XOR<FeaturedBrandsCreateWithoutProductInput, FeaturedBrandsUncheckedCreateWithoutProductInput>
  }

  export type FeaturedBrandsUpdateWithWhereUniqueWithoutProductInput = {
    where: FeaturedBrandsWhereUniqueInput
    data: XOR<FeaturedBrandsUpdateWithoutProductInput, FeaturedBrandsUncheckedUpdateWithoutProductInput>
  }

  export type FeaturedBrandsUpdateManyWithWhereWithoutProductInput = {
    where: FeaturedBrandsScalarWhereInput
    data: XOR<FeaturedBrandsUpdateManyMutationInput, FeaturedBrandsUncheckedUpdateManyWithoutProductInput>
  }

  export type FeaturedBrandsScalarWhereInput = {
    AND?: FeaturedBrandsScalarWhereInput | FeaturedBrandsScalarWhereInput[]
    OR?: FeaturedBrandsScalarWhereInput[]
    NOT?: FeaturedBrandsScalarWhereInput | FeaturedBrandsScalarWhereInput[]
    id?: StringFilter<"FeaturedBrands"> | string
    name?: StringFilter<"FeaturedBrands"> | string
    productId?: StringFilter<"FeaturedBrands"> | string
    createdAt?: DateTimeFilter<"FeaturedBrands"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedBrands"> | Date | string
  }

  export type CartItemUpsertWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
  }

  export type CartItemUpdateManyWithWhereWithoutProductInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductVariationUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductVariationWhereUniqueInput
    update: XOR<ProductVariationUpdateWithoutProductInput, ProductVariationUncheckedUpdateWithoutProductInput>
    create: XOR<ProductVariationCreateWithoutProductInput, ProductVariationUncheckedCreateWithoutProductInput>
  }

  export type ProductVariationUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductVariationWhereUniqueInput
    data: XOR<ProductVariationUpdateWithoutProductInput, ProductVariationUncheckedUpdateWithoutProductInput>
  }

  export type ProductVariationUpdateManyWithWhereWithoutProductInput = {
    where: ProductVariationScalarWhereInput
    data: XOR<ProductVariationUpdateManyMutationInput, ProductVariationUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductVariationScalarWhereInput = {
    AND?: ProductVariationScalarWhereInput | ProductVariationScalarWhereInput[]
    OR?: ProductVariationScalarWhereInput[]
    NOT?: ProductVariationScalarWhereInput | ProductVariationScalarWhereInput[]
    id?: StringFilter<"ProductVariation"> | string
    productId?: StringFilter<"ProductVariation"> | string
    sku?: StringFilter<"ProductVariation"> | string
    price?: FloatFilter<"ProductVariation"> | number
    cost?: FloatNullableFilter<"ProductVariation"> | number | null
    discountPrice?: FloatNullableFilter<"ProductVariation"> | number | null
    stock?: IntFilter<"ProductVariation"> | number
    imageUrl?: StringNullableFilter<"ProductVariation"> | string | null
    createdAt?: DateTimeFilter<"ProductVariation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariation"> | Date | string
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutProductInput, ProductCategoryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutProductInput, ProductCategoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutProductInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    name?: StringNullableFilter<"ProductCategory"> | string | null
    description?: StringNullableFilter<"ProductCategory"> | string | null
    storeId?: StringFilter<"ProductCategory"> | string
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
  }

  export type InventoryUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type InventoryUpdateManyWithWhereWithoutProductInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutProductInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    id?: StringFilter<"Inventory"> | string
    quantity?: IntFilter<"Inventory"> | number
    productId?: StringFilter<"Inventory"> | string
    warehouseId?: StringFilter<"Inventory"> | string
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
  }

  export type ProductCollectionUpsertWithoutProductsInput = {
    update: XOR<ProductCollectionUpdateWithoutProductsInput, ProductCollectionUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCollectionCreateWithoutProductsInput, ProductCollectionUncheckedCreateWithoutProductsInput>
    where?: ProductCollectionWhereInput
  }

  export type ProductCollectionUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCollectionWhereInput
    data: XOR<ProductCollectionUpdateWithoutProductsInput, ProductCollectionUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCollectionUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCollectionUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpsertWithoutProductsInput = {
    update: XOR<PurchaseUpdateWithoutProductsInput, PurchaseUncheckedUpdateWithoutProductsInput>
    create: XOR<PurchaseCreateWithoutProductsInput, PurchaseUncheckedCreateWithoutProductsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutProductsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutProductsInput, PurchaseUncheckedUpdateWithoutProductsInput>
  }

  export type PurchaseUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    toalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeSupplier?: SupplierUpdateOneRequiredWithoutPurchaseNestedInput
    store?: OrganizationUpdateOneRequiredWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    toalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    storeSupplierId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUpsertWithoutProductInput = {
    update: XOR<OrganizationUpdateWithoutProductInput, OrganizationUncheckedUpdateWithoutProductInput>
    create: XOR<OrganizationCreateWithoutProductInput, OrganizationUncheckedCreateWithoutProductInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutProductInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutProductInput, OrganizationUncheckedUpdateWithoutProductInput>
  }

  export type OrganizationUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type WarehouseUpsertWithoutInventoryInput = {
    update: XOR<WarehouseUpdateWithoutInventoryInput, WarehouseUncheckedUpdateWithoutInventoryInput>
    create: XOR<WarehouseCreateWithoutInventoryInput, WarehouseUncheckedCreateWithoutInventoryInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutInventoryInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutInventoryInput, WarehouseUncheckedUpdateWithoutInventoryInput>
  }

  export type WarehouseUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryUpdateManyWithoutWarehouseNestedInput
    staffAssigned?: UserUpdateOneRequiredWithoutWarehouseNestedInput
    store?: OrganizationUpdateOneRequiredWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    staffId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type LocationUpsertWithoutProductInput = {
    update: XOR<LocationUpdateWithoutProductInput, LocationUncheckedUpdateWithoutProductInput>
    create: XOR<LocationCreateWithoutProductInput, LocationUncheckedCreateWithoutProductInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutProductInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutProductInput, LocationUncheckedUpdateWithoutProductInput>
  }

  export type LocationUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateManyWithoutLocationNestedInput
    order?: OrderUpdateManyWithoutLocationNestedInput
    store?: OrganizationUpdateOneRequiredWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateManyWithoutLocationNestedInput
    order?: OrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type ProductCreateWithoutProductCategoryInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredBrands?: FeaturedBrandsCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    collection?: ProductCollectionCreateNestedOneWithoutProductsInput
    purchase?: PurchaseCreateNestedOneWithoutProductsInput
    store: OrganizationCreateNestedOneWithoutProductInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryInput
    location?: LocationCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductCategoryInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
    featuredBrands?: FeaturedBrandsUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type OrganizationCreateWithoutProductCategoryInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutProductCategoryInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutProductCategoryInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProductCategoryInput, OrganizationUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductCategoryInput>
  }

  export type OrganizationUpsertWithoutProductCategoryInput = {
    update: XOR<OrganizationUpdateWithoutProductCategoryInput, OrganizationUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<OrganizationCreateWithoutProductCategoryInput, OrganizationUncheckedCreateWithoutProductCategoryInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutProductCategoryInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutProductCategoryInput, OrganizationUncheckedUpdateWithoutProductCategoryInput>
  }

  export type OrganizationUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ProductCreateWithoutCollectionInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredBrands?: FeaturedBrandsCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    purchase?: PurchaseCreateNestedOneWithoutProductsInput
    store: OrganizationCreateNestedOneWithoutProductInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryInput
    location?: LocationCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCollectionInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    purchaseOrderId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
    featuredBrands?: FeaturedBrandsUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCollectionInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCollectionInput, ProductUncheckedCreateWithoutCollectionInput>
  }

  export type ProductCreateManyCollectionInputEnvelope = {
    data: ProductCreateManyCollectionInput | ProductCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCollectionInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCollectionInput, ProductUncheckedUpdateWithoutCollectionInput>
    create: XOR<ProductCreateWithoutCollectionInput, ProductUncheckedCreateWithoutCollectionInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCollectionInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCollectionInput, ProductUncheckedUpdateWithoutCollectionInput>
  }

  export type ProductUpdateManyWithWhereWithoutCollectionInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCollectionInput>
  }

  export type ProductCreateWithoutProductVariationInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredBrands?: FeaturedBrandsCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    collection?: ProductCollectionCreateNestedOneWithoutProductsInput
    purchase?: PurchaseCreateNestedOneWithoutProductsInput
    store: OrganizationCreateNestedOneWithoutProductInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryInput
    location?: LocationCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductVariationInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
    featuredBrands?: FeaturedBrandsUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductVariationInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductVariationInput, ProductUncheckedCreateWithoutProductVariationInput>
  }

  export type ProductVariationOptionCreateWithoutVariationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    value: ProductVariantValueCreateNestedOneWithoutOptionsInput
  }

  export type ProductVariationOptionUncheckedCreateWithoutVariationInput = {
    id?: string
    valueId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationOptionCreateOrConnectWithoutVariationInput = {
    where: ProductVariationOptionWhereUniqueInput
    create: XOR<ProductVariationOptionCreateWithoutVariationInput, ProductVariationOptionUncheckedCreateWithoutVariationInput>
  }

  export type ProductVariationOptionCreateManyVariationInputEnvelope = {
    data: ProductVariationOptionCreateManyVariationInput | ProductVariationOptionCreateManyVariationInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutProductVariationInput = {
    update: XOR<ProductUpdateWithoutProductVariationInput, ProductUncheckedUpdateWithoutProductVariationInput>
    create: XOR<ProductCreateWithoutProductVariationInput, ProductUncheckedCreateWithoutProductVariationInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductVariationInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductVariationInput, ProductUncheckedUpdateWithoutProductVariationInput>
  }

  export type ProductUpdateWithoutProductVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredBrands?: FeaturedBrandsUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    collection?: ProductCollectionUpdateOneWithoutProductsNestedInput
    purchase?: PurchaseUpdateOneWithoutProductsNestedInput
    store?: OrganizationUpdateOneRequiredWithoutProductNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryNestedInput
    location?: LocationUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredBrands?: FeaturedBrandsUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductVariationOptionUpsertWithWhereUniqueWithoutVariationInput = {
    where: ProductVariationOptionWhereUniqueInput
    update: XOR<ProductVariationOptionUpdateWithoutVariationInput, ProductVariationOptionUncheckedUpdateWithoutVariationInput>
    create: XOR<ProductVariationOptionCreateWithoutVariationInput, ProductVariationOptionUncheckedCreateWithoutVariationInput>
  }

  export type ProductVariationOptionUpdateWithWhereUniqueWithoutVariationInput = {
    where: ProductVariationOptionWhereUniqueInput
    data: XOR<ProductVariationOptionUpdateWithoutVariationInput, ProductVariationOptionUncheckedUpdateWithoutVariationInput>
  }

  export type ProductVariationOptionUpdateManyWithWhereWithoutVariationInput = {
    where: ProductVariationOptionScalarWhereInput
    data: XOR<ProductVariationOptionUpdateManyMutationInput, ProductVariationOptionUncheckedUpdateManyWithoutVariationInput>
  }

  export type ProductVariationOptionScalarWhereInput = {
    AND?: ProductVariationOptionScalarWhereInput | ProductVariationOptionScalarWhereInput[]
    OR?: ProductVariationOptionScalarWhereInput[]
    NOT?: ProductVariationOptionScalarWhereInput | ProductVariationOptionScalarWhereInput[]
    id?: StringFilter<"ProductVariationOption"> | string
    variationId?: StringFilter<"ProductVariationOption"> | string
    valueId?: StringFilter<"ProductVariationOption"> | string
    createdAt?: DateTimeFilter<"ProductVariationOption"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariationOption"> | Date | string
  }

  export type ProductVariantValueCreateWithoutVariantInput = {
    id?: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ProductVariationOptionCreateNestedManyWithoutValueInput
  }

  export type ProductVariantValueUncheckedCreateWithoutVariantInput = {
    id?: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ProductVariationOptionUncheckedCreateNestedManyWithoutValueInput
  }

  export type ProductVariantValueCreateOrConnectWithoutVariantInput = {
    where: ProductVariantValueWhereUniqueInput
    create: XOR<ProductVariantValueCreateWithoutVariantInput, ProductVariantValueUncheckedCreateWithoutVariantInput>
  }

  export type ProductVariantValueCreateManyVariantInputEnvelope = {
    data: ProductVariantValueCreateManyVariantInput | ProductVariantValueCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type ProductVariantValueUpsertWithWhereUniqueWithoutVariantInput = {
    where: ProductVariantValueWhereUniqueInput
    update: XOR<ProductVariantValueUpdateWithoutVariantInput, ProductVariantValueUncheckedUpdateWithoutVariantInput>
    create: XOR<ProductVariantValueCreateWithoutVariantInput, ProductVariantValueUncheckedCreateWithoutVariantInput>
  }

  export type ProductVariantValueUpdateWithWhereUniqueWithoutVariantInput = {
    where: ProductVariantValueWhereUniqueInput
    data: XOR<ProductVariantValueUpdateWithoutVariantInput, ProductVariantValueUncheckedUpdateWithoutVariantInput>
  }

  export type ProductVariantValueUpdateManyWithWhereWithoutVariantInput = {
    where: ProductVariantValueScalarWhereInput
    data: XOR<ProductVariantValueUpdateManyMutationInput, ProductVariantValueUncheckedUpdateManyWithoutVariantInput>
  }

  export type ProductVariantValueScalarWhereInput = {
    AND?: ProductVariantValueScalarWhereInput | ProductVariantValueScalarWhereInput[]
    OR?: ProductVariantValueScalarWhereInput[]
    NOT?: ProductVariantValueScalarWhereInput | ProductVariantValueScalarWhereInput[]
    id?: StringFilter<"ProductVariantValue"> | string
    variantId?: StringFilter<"ProductVariantValue"> | string
    value?: StringFilter<"ProductVariantValue"> | string
    createdAt?: DateTimeFilter<"ProductVariantValue"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariantValue"> | Date | string
  }

  export type ProductVariantCreateWithoutValuesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUncheckedCreateWithoutValuesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantCreateOrConnectWithoutValuesInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutValuesInput, ProductVariantUncheckedCreateWithoutValuesInput>
  }

  export type ProductVariationOptionCreateWithoutValueInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: ProductVariationCreateNestedOneWithoutOptionsInput
  }

  export type ProductVariationOptionUncheckedCreateWithoutValueInput = {
    id?: string
    variationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationOptionCreateOrConnectWithoutValueInput = {
    where: ProductVariationOptionWhereUniqueInput
    create: XOR<ProductVariationOptionCreateWithoutValueInput, ProductVariationOptionUncheckedCreateWithoutValueInput>
  }

  export type ProductVariationOptionCreateManyValueInputEnvelope = {
    data: ProductVariationOptionCreateManyValueInput | ProductVariationOptionCreateManyValueInput[]
    skipDuplicates?: boolean
  }

  export type ProductVariantUpsertWithoutValuesInput = {
    update: XOR<ProductVariantUpdateWithoutValuesInput, ProductVariantUncheckedUpdateWithoutValuesInput>
    create: XOR<ProductVariantCreateWithoutValuesInput, ProductVariantUncheckedCreateWithoutValuesInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutValuesInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutValuesInput, ProductVariantUncheckedUpdateWithoutValuesInput>
  }

  export type ProductVariantUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUncheckedUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationOptionUpsertWithWhereUniqueWithoutValueInput = {
    where: ProductVariationOptionWhereUniqueInput
    update: XOR<ProductVariationOptionUpdateWithoutValueInput, ProductVariationOptionUncheckedUpdateWithoutValueInput>
    create: XOR<ProductVariationOptionCreateWithoutValueInput, ProductVariationOptionUncheckedCreateWithoutValueInput>
  }

  export type ProductVariationOptionUpdateWithWhereUniqueWithoutValueInput = {
    where: ProductVariationOptionWhereUniqueInput
    data: XOR<ProductVariationOptionUpdateWithoutValueInput, ProductVariationOptionUncheckedUpdateWithoutValueInput>
  }

  export type ProductVariationOptionUpdateManyWithWhereWithoutValueInput = {
    where: ProductVariationOptionScalarWhereInput
    data: XOR<ProductVariationOptionUpdateManyMutationInput, ProductVariationOptionUncheckedUpdateManyWithoutValueInput>
  }

  export type ProductVariationCreateWithoutOptionsInput = {
    id?: string
    sku: string
    price: number
    cost?: number | null
    discountPrice?: number | null
    stock?: number
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductVariationInput
  }

  export type ProductVariationUncheckedCreateWithoutOptionsInput = {
    id?: string
    productId: string
    sku: string
    price: number
    cost?: number | null
    discountPrice?: number | null
    stock?: number
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationCreateOrConnectWithoutOptionsInput = {
    where: ProductVariationWhereUniqueInput
    create: XOR<ProductVariationCreateWithoutOptionsInput, ProductVariationUncheckedCreateWithoutOptionsInput>
  }

  export type ProductVariantValueCreateWithoutOptionsInput = {
    id?: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    variant: ProductVariantCreateNestedOneWithoutValuesInput
  }

  export type ProductVariantValueUncheckedCreateWithoutOptionsInput = {
    id?: string
    variantId: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantValueCreateOrConnectWithoutOptionsInput = {
    where: ProductVariantValueWhereUniqueInput
    create: XOR<ProductVariantValueCreateWithoutOptionsInput, ProductVariantValueUncheckedCreateWithoutOptionsInput>
  }

  export type ProductVariationUpsertWithoutOptionsInput = {
    update: XOR<ProductVariationUpdateWithoutOptionsInput, ProductVariationUncheckedUpdateWithoutOptionsInput>
    create: XOR<ProductVariationCreateWithoutOptionsInput, ProductVariationUncheckedCreateWithoutOptionsInput>
    where?: ProductVariationWhereInput
  }

  export type ProductVariationUpdateToOneWithWhereWithoutOptionsInput = {
    where?: ProductVariationWhereInput
    data: XOR<ProductVariationUpdateWithoutOptionsInput, ProductVariationUncheckedUpdateWithoutOptionsInput>
  }

  export type ProductVariationUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductVariationNestedInput
  }

  export type ProductVariationUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantValueUpsertWithoutOptionsInput = {
    update: XOR<ProductVariantValueUpdateWithoutOptionsInput, ProductVariantValueUncheckedUpdateWithoutOptionsInput>
    create: XOR<ProductVariantValueCreateWithoutOptionsInput, ProductVariantValueUncheckedCreateWithoutOptionsInput>
    where?: ProductVariantValueWhereInput
  }

  export type ProductVariantValueUpdateToOneWithWhereWithoutOptionsInput = {
    where?: ProductVariantValueWhereInput
    data: XOR<ProductVariantValueUpdateWithoutOptionsInput, ProductVariantValueUncheckedUpdateWithoutOptionsInput>
  }

  export type ProductVariantValueUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: ProductVariantUpdateOneRequiredWithoutValuesNestedInput
  }

  export type ProductVariantValueUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutFeaturedBrandsInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    collection?: ProductCollectionCreateNestedOneWithoutProductsInput
    purchase?: PurchaseCreateNestedOneWithoutProductsInput
    store: OrganizationCreateNestedOneWithoutProductInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryInput
    location?: LocationCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutFeaturedBrandsInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutFeaturedBrandsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutFeaturedBrandsInput, ProductUncheckedCreateWithoutFeaturedBrandsInput>
  }

  export type ProductUpsertWithoutFeaturedBrandsInput = {
    update: XOR<ProductUpdateWithoutFeaturedBrandsInput, ProductUncheckedUpdateWithoutFeaturedBrandsInput>
    create: XOR<ProductCreateWithoutFeaturedBrandsInput, ProductUncheckedCreateWithoutFeaturedBrandsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutFeaturedBrandsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutFeaturedBrandsInput, ProductUncheckedUpdateWithoutFeaturedBrandsInput>
  }

  export type ProductUpdateWithoutFeaturedBrandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    collection?: ProductCollectionUpdateOneWithoutProductsNestedInput
    purchase?: PurchaseUpdateOneWithoutProductsNestedInput
    store?: OrganizationUpdateOneRequiredWithoutProductNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryNestedInput
    location?: LocationUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutFeaturedBrandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PurchaseCreateWithoutStoreSupplierInput = {
    id?: string
    status: string
    downloadUrl: string
    toalCost: Decimal | DecimalJsLike | number | string
    deliveryDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutPurchaseInput
    products?: ProductCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutStoreSupplierInput = {
    id?: string
    status: string
    downloadUrl: string
    toalCost: Decimal | DecimalJsLike | number | string
    storeId: string
    deliveryDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutStoreSupplierInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutStoreSupplierInput, PurchaseUncheckedCreateWithoutStoreSupplierInput>
  }

  export type PurchaseCreateManyStoreSupplierInputEnvelope = {
    data: PurchaseCreateManyStoreSupplierInput | PurchaseCreateManyStoreSupplierInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutSupplierInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutSupplierInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutSupplierInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSupplierInput, OrganizationUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseUpsertWithWhereUniqueWithoutStoreSupplierInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutStoreSupplierInput, PurchaseUncheckedUpdateWithoutStoreSupplierInput>
    create: XOR<PurchaseCreateWithoutStoreSupplierInput, PurchaseUncheckedCreateWithoutStoreSupplierInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutStoreSupplierInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutStoreSupplierInput, PurchaseUncheckedUpdateWithoutStoreSupplierInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutStoreSupplierInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutStoreSupplierInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    status?: StringFilter<"Purchase"> | string
    downloadUrl?: StringFilter<"Purchase"> | string
    toalCost?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    storeSupplierId?: StringFilter<"Purchase"> | string
    storeId?: StringFilter<"Purchase"> | string
    deliveryDate?: DateTimeFilter<"Purchase"> | Date | string
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type OrganizationUpsertWithoutSupplierInput = {
    update: XOR<OrganizationUpdateWithoutSupplierInput, OrganizationUncheckedUpdateWithoutSupplierInput>
    create: XOR<OrganizationCreateWithoutSupplierInput, OrganizationUncheckedCreateWithoutSupplierInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSupplierInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSupplierInput, OrganizationUncheckedUpdateWithoutSupplierInput>
  }

  export type OrganizationUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type SupplierCreateWithoutPurchaseInput = {
    id?: string
    supplierName: string
    email: string
    phoneNumber: string
    personOfSupplier: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPurchaseInput = {
    id?: string
    supplierName: string
    email: string
    phoneNumber: string
    personOfSupplier: string
    location: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateOrConnectWithoutPurchaseInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchaseInput, SupplierUncheckedCreateWithoutPurchaseInput>
  }

  export type OrganizationCreateWithoutPurchaseInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutPurchaseInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutPurchaseInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutPurchaseInput, OrganizationUncheckedCreateWithoutPurchaseInput>
  }

  export type ProductCreateWithoutPurchaseInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredBrands?: FeaturedBrandsCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    collection?: ProductCollectionCreateNestedOneWithoutProductsInput
    store: OrganizationCreateNestedOneWithoutProductInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryInput
    location?: LocationCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
    featuredBrands?: FeaturedBrandsUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseInput, ProductUncheckedCreateWithoutPurchaseInput>
  }

  export type ProductCreateManyPurchaseInputEnvelope = {
    data: ProductCreateManyPurchaseInput | ProductCreateManyPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type SupplierUpsertWithoutPurchaseInput = {
    update: XOR<SupplierUpdateWithoutPurchaseInput, SupplierUncheckedUpdateWithoutPurchaseInput>
    create: XOR<SupplierCreateWithoutPurchaseInput, SupplierUncheckedCreateWithoutPurchaseInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchaseInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchaseInput, SupplierUncheckedUpdateWithoutPurchaseInput>
  }

  export type SupplierUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personOfSupplier?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personOfSupplier?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUpsertWithoutPurchaseInput = {
    update: XOR<OrganizationUpdateWithoutPurchaseInput, OrganizationUncheckedUpdateWithoutPurchaseInput>
    create: XOR<OrganizationCreateWithoutPurchaseInput, OrganizationUncheckedCreateWithoutPurchaseInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutPurchaseInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutPurchaseInput, OrganizationUncheckedUpdateWithoutPurchaseInput>
  }

  export type OrganizationUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutPurchaseInput, ProductUncheckedUpdateWithoutPurchaseInput>
    create: XOR<ProductCreateWithoutPurchaseInput, ProductUncheckedCreateWithoutPurchaseInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutPurchaseInput, ProductUncheckedUpdateWithoutPurchaseInput>
  }

  export type ProductUpdateManyWithWhereWithoutPurchaseInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type MemberCreateWithoutUserInput = {
    id: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutUserInput = {
    id: string
    organizationId: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberCreateOrConnectWithoutUserInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberCreateManyUserInputEnvelope = {
    data: MemberCreateManyUserInput | MemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutUserInput = {
    id: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutUserInput = {
    id: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationCreateOrConnectWithoutUserInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput>
  }

  export type InvitationCreateManyUserInputEnvelope = {
    data: InvitationCreateManyUserInput | InvitationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
    activeOrganizationId?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
    activeOrganizationId?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutUserInput = {
    id?: string
    name: string
    address?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    description?: string | null
    isdefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedManyWithoutLocationInput
    product?: ProductCreateNestedManyWithoutLocationInput
    store: OrganizationCreateNestedOneWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    address?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    description?: string | null
    storeId: string
    isdefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderUncheckedCreateNestedManyWithoutLocationInput
    product?: ProductUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutUserInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
  }

  export type PointOfSaleCreateWithoutStaffAssignedInput = {
    id?: string
    createdAt: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutPointOfSaleInput
  }

  export type PointOfSaleUncheckedCreateWithoutStaffAssignedInput = {
    id?: string
    storeId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type PointOfSaleCreateOrConnectWithoutStaffAssignedInput = {
    where: PointOfSaleWhereUniqueInput
    create: XOR<PointOfSaleCreateWithoutStaffAssignedInput, PointOfSaleUncheckedCreateWithoutStaffAssignedInput>
  }

  export type WarehouseCreateWithoutStaffAssignedInput = {
    id?: string
    name: string
    isDefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryCreateNestedManyWithoutWarehouseInput
    store: OrganizationCreateNestedOneWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutStaffAssignedInput = {
    id?: string
    name: string
    isDefaultLocation?: boolean | null
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutStaffAssignedInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutStaffAssignedInput, WarehouseUncheckedCreateWithoutStaffAssignedInput>
  }

  export type POSCreateWithoutStaffInput = {
    id?: string
    terminalId: string
    confirmed?: boolean
    confirmedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutPosInput
    order: OrderCreateNestedOneWithoutPosInput
  }

  export type POSUncheckedCreateWithoutStaffInput = {
    id?: string
    orderId: string
    customerId: string
    terminalId: string
    confirmed?: boolean
    confirmedAt?: Date | string | null
  }

  export type POSCreateOrConnectWithoutStaffInput = {
    where: POSWhereUniqueInput
    create: XOR<POSCreateWithoutStaffInput, POSUncheckedCreateWithoutStaffInput>
  }

  export type POSCreateManyStaffInputEnvelope = {
    data: POSCreateManyStaffInput | POSCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
  }

  export type MemberUpdateManyWithWhereWithoutUserInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    id?: StringFilter<"Member"> | string
    organizationId?: StringFilter<"Member"> | string
    userId?: StringFilter<"Member"> | string
    role?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
  }

  export type InvitationUpsertWithWhereUniqueWithoutUserInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutUserInput, InvitationUncheckedUpdateWithoutUserInput>
    create: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutUserInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutUserInput, InvitationUncheckedUpdateWithoutUserInput>
  }

  export type InvitationUpdateManyWithWhereWithoutUserInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutUserInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    OR?: InvitationScalarWhereInput[]
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    id?: StringFilter<"Invitation"> | string
    organizationId?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    role?: StringNullableFilter<"Invitation"> | string | null
    status?: StringFilter<"Invitation"> | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    inviterId?: StringFilter<"Invitation"> | string
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    updatedAt?: DateTimeFilter<"Invitation"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
    activeOrganizationId?: StringNullableFilter<"Session"> | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type LocationUpsertWithoutUserInput = {
    update: XOR<LocationUpdateWithoutUserInput, LocationUncheckedUpdateWithoutUserInput>
    create: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutUserInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutUserInput, LocationUncheckedUpdateWithoutUserInput>
  }

  export type LocationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateManyWithoutLocationNestedInput
    product?: ProductUpdateManyWithoutLocationNestedInput
    store?: OrganizationUpdateOneRequiredWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    product?: ProductUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type PointOfSaleUpsertWithoutStaffAssignedInput = {
    update: XOR<PointOfSaleUpdateWithoutStaffAssignedInput, PointOfSaleUncheckedUpdateWithoutStaffAssignedInput>
    create: XOR<PointOfSaleCreateWithoutStaffAssignedInput, PointOfSaleUncheckedCreateWithoutStaffAssignedInput>
    where?: PointOfSaleWhereInput
  }

  export type PointOfSaleUpdateToOneWithWhereWithoutStaffAssignedInput = {
    where?: PointOfSaleWhereInput
    data: XOR<PointOfSaleUpdateWithoutStaffAssignedInput, PointOfSaleUncheckedUpdateWithoutStaffAssignedInput>
  }

  export type PointOfSaleUpdateWithoutStaffAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutPointOfSaleNestedInput
  }

  export type PointOfSaleUncheckedUpdateWithoutStaffAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUpsertWithoutStaffAssignedInput = {
    update: XOR<WarehouseUpdateWithoutStaffAssignedInput, WarehouseUncheckedUpdateWithoutStaffAssignedInput>
    create: XOR<WarehouseCreateWithoutStaffAssignedInput, WarehouseUncheckedCreateWithoutStaffAssignedInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutStaffAssignedInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutStaffAssignedInput, WarehouseUncheckedUpdateWithoutStaffAssignedInput>
  }

  export type WarehouseUpdateWithoutStaffAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryUpdateManyWithoutWarehouseNestedInput
    store?: OrganizationUpdateOneRequiredWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutStaffAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type POSUpsertWithWhereUniqueWithoutStaffInput = {
    where: POSWhereUniqueInput
    update: XOR<POSUpdateWithoutStaffInput, POSUncheckedUpdateWithoutStaffInput>
    create: XOR<POSCreateWithoutStaffInput, POSUncheckedCreateWithoutStaffInput>
  }

  export type POSUpdateWithWhereUniqueWithoutStaffInput = {
    where: POSWhereUniqueInput
    data: XOR<POSUpdateWithoutStaffInput, POSUncheckedUpdateWithoutStaffInput>
  }

  export type POSUpdateManyWithWhereWithoutStaffInput = {
    where: POSScalarWhereInput
    data: XOR<POSUpdateManyMutationInput, POSUncheckedUpdateManyWithoutStaffInput>
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    PointOfSale?: PointOfSaleCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseCreateNestedOneWithoutStaffAssignedInput
    POS?: POSCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    PointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseUncheckedCreateNestedOneWithoutStaffAssignedInput
    POS?: POSUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    PointOfSale?: PointOfSaleUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    PointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUncheckedUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    PointOfSale?: PointOfSaleCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseCreateNestedOneWithoutStaffAssignedInput
    POS?: POSCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    PointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseUncheckedCreateNestedOneWithoutStaffAssignedInput
    POS?: POSUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    PointOfSale?: PointOfSaleUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    PointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUncheckedUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type MemberCreateWithoutOrganizationInput = {
    id: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutOrganizationInput = {
    id: string
    userId: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberCreateOrConnectWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput>
  }

  export type MemberCreateManyOrganizationInputEnvelope = {
    data: MemberCreateManyOrganizationInput | MemberCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutOrganizationInput = {
    id: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutOrganizationInput = {
    id: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationCreateOrConnectWithoutOrganizationInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type InvitationCreateManyOrganizationInputEnvelope = {
    data: InvitationCreateManyOrganizationInput | InvitationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type BankDetailsCreateWithoutStoreInput = {
    id?: string
    bankName: string
    bankCode: string
    accountName: string
    accountNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailsUncheckedCreateWithoutStoreInput = {
    id?: string
    bankName: string
    bankCode: string
    accountName: string
    accountNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailsCreateOrConnectWithoutStoreInput = {
    where: BankDetailsWhereUniqueInput
    create: XOR<BankDetailsCreateWithoutStoreInput, BankDetailsUncheckedCreateWithoutStoreInput>
  }

  export type WalletCreateWithoutStoreInput = {
    id?: string
    balance: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletUncheckedCreateWithoutStoreInput = {
    id?: string
    balance: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletCreateOrConnectWithoutStoreInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutStoreInput, WalletUncheckedCreateWithoutStoreInput>
  }

  export type LocationCreateWithoutStoreInput = {
    id?: string
    name: string
    address?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    description?: string | null
    isdefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedManyWithoutLocationInput
    order?: OrderCreateNestedManyWithoutLocationInput
    product?: ProductCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    address?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    description?: string | null
    isdefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedManyWithoutLocationInput
    order?: OrderUncheckedCreateNestedManyWithoutLocationInput
    product?: ProductUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutStoreInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutStoreInput, LocationUncheckedCreateWithoutStoreInput>
  }

  export type LocationCreateManyStoreInputEnvelope = {
    data: LocationCreateManyStoreInput | LocationCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutStoreInput = {
    id?: string
    createdBy?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    pos?: POSCreateNestedOneWithoutOrderInput
    cart?: CartCreateNestedOneWithoutOrderInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    location?: LocationCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutStoreInput = {
    id?: string
    customerId: string
    locationId: string
    createdBy?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    pos?: POSUncheckedCreateNestedOneWithoutOrderInput
    cart?: CartUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutStoreInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStoreInput, OrderUncheckedCreateWithoutStoreInput>
  }

  export type OrderCreateManyStoreInputEnvelope = {
    data: OrderCreateManyStoreInput | OrderCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutStoreInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerInput
    carts?: CartCreateNestedManyWithoutCustomerInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutCustomerInput
    pos?: POSCreateNestedManyWithoutCustomerInput
    customerGroupMember?: CustomerGroupMemberCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    carts?: CartUncheckedCreateNestedManyWithoutCustomerInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutCustomerInput
    pos?: POSUncheckedCreateNestedManyWithoutCustomerInput
    customerGroupMember?: CustomerGroupMemberUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutStoreInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutStoreInput, CustomerUncheckedCreateWithoutStoreInput>
  }

  export type CustomerCreateManyStoreInputEnvelope = {
    data: CustomerCreateManyStoreInput | CustomerCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type CustomerGroupsCreateWithoutStoreInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerGroupMember?: CustomerGroupMemberCreateNestedManyWithoutCustomerGroupInput
  }

  export type CustomerGroupsUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerGroupMember?: CustomerGroupMemberUncheckedCreateNestedManyWithoutCustomerGroupInput
  }

  export type CustomerGroupsCreateOrConnectWithoutStoreInput = {
    where: CustomerGroupsWhereUniqueInput
    create: XOR<CustomerGroupsCreateWithoutStoreInput, CustomerGroupsUncheckedCreateWithoutStoreInput>
  }

  export type CustomerGroupsCreateManyStoreInputEnvelope = {
    data: CustomerGroupsCreateManyStoreInput | CustomerGroupsCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutStoreInput = {
    id?: string
    name?: string | null
    amount?: number | null
    description?: string | null
    paymentMethod?: string | null
    paymentStatus?: string | null
    date?: Date | string | null
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expenseCategory?: ExpenseCategoryCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutStoreInput = {
    id?: string
    name?: string | null
    amount?: number | null
    description?: string | null
    paymentMethod?: string | null
    paymentStatus?: string | null
    date?: Date | string | null
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expenseCategory?: ExpenseCategoryUncheckedCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseCreateOrConnectWithoutStoreInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutStoreInput, ExpenseUncheckedCreateWithoutStoreInput>
  }

  export type ExpenseCreateManyStoreInputEnvelope = {
    data: ExpenseCreateManyStoreInput | ExpenseCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutStoreInput = {
    id?: string
    invoiceNumber: string
    title: string
    customerEmail: string
    description?: string | null
    status?: string | null
    downloadUrl: string
    paymentLink?: string | null
    qrCode?: string | null
    amount: string
    total?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUncheckedCreateWithoutStoreInput = {
    id?: string
    invoiceNumber: string
    title: string
    customerEmail: string
    description?: string | null
    status?: string | null
    downloadUrl: string
    paymentLink?: string | null
    qrCode?: string | null
    amount: string
    total?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutStoreInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutStoreInput, InvoiceUncheckedCreateWithoutStoreInput>
  }

  export type InvoiceCreateManyStoreInputEnvelope = {
    data: InvoiceCreateManyStoreInput | InvoiceCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type PointOfSaleCreateWithoutStoreInput = {
    id?: string
    createdAt: Date | string
    updatedAt?: Date | string
    staffAssigned: UserCreateNestedOneWithoutPointOfSaleInput
  }

  export type PointOfSaleUncheckedCreateWithoutStoreInput = {
    id?: string
    staffAssignedId: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type PointOfSaleCreateOrConnectWithoutStoreInput = {
    where: PointOfSaleWhereUniqueInput
    create: XOR<PointOfSaleCreateWithoutStoreInput, PointOfSaleUncheckedCreateWithoutStoreInput>
  }

  export type ProductCreateWithoutStoreInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredBrands?: FeaturedBrandsCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    collection?: ProductCollectionCreateNestedOneWithoutProductsInput
    purchase?: PurchaseCreateNestedOneWithoutProductsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryInput
    location?: LocationCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    locationId?: string | null
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
    featuredBrands?: FeaturedBrandsUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStoreInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStoreInput, ProductUncheckedCreateWithoutStoreInput>
  }

  export type ProductCreateManyStoreInputEnvelope = {
    data: ProductCreateManyStoreInput | ProductCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutStoreInput = {
    id?: string
    supplierName: string
    email: string
    phoneNumber: string
    personOfSupplier: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase?: PurchaseCreateNestedManyWithoutStoreSupplierInput
  }

  export type SupplierUncheckedCreateWithoutStoreInput = {
    id?: string
    supplierName: string
    email: string
    phoneNumber: string
    personOfSupplier: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreSupplierInput
  }

  export type SupplierCreateOrConnectWithoutStoreInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutStoreInput, SupplierUncheckedCreateWithoutStoreInput>
  }

  export type SupplierCreateManyStoreInputEnvelope = {
    data: SupplierCreateManyStoreInput | SupplierCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutStoreInput = {
    id?: string
    status: string
    downloadUrl: string
    toalCost: Decimal | DecimalJsLike | number | string
    deliveryDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    storeSupplier: SupplierCreateNestedOneWithoutPurchaseInput
    products?: ProductCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutStoreInput = {
    id?: string
    status: string
    downloadUrl: string
    toalCost: Decimal | DecimalJsLike | number | string
    storeSupplierId: string
    deliveryDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutStoreInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput>
  }

  export type PurchaseCreateManyStoreInputEnvelope = {
    data: PurchaseCreateManyStoreInput | PurchaseCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type SettlementCreateWithoutStoreInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementUncheckedCreateWithoutStoreInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementCreateOrConnectWithoutStoreInput = {
    where: SettlementWhereUniqueInput
    create: XOR<SettlementCreateWithoutStoreInput, SettlementUncheckedCreateWithoutStoreInput>
  }

  export type SettlementCreateManyStoreInputEnvelope = {
    data: SettlementCreateManyStoreInput | SettlementCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutStoreInput = {
    amount?: Decimal | DecimalJsLike | number | string | null
    channel?: string | null
    customersId?: number | null
    customersCode?: string | null
    authorizationCode?: string | null
    status?: string | null
    cardType?: string | null
    cardBank?: string | null
    cardBrand?: string | null
    countryCode?: string | null
    accountName?: string | null
    cardBin?: number | null
    cardLast4?: number | null
    expMonth?: number | null
    expYear?: number | null
    interval?: string | null
    emailToken?: string | null
    startDate?: Date | string | null
    endsAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutStoreInput = {
    id?: number
    amount?: Decimal | DecimalJsLike | number | string | null
    channel?: string | null
    customersId?: number | null
    customersCode?: string | null
    authorizationCode?: string | null
    status?: string | null
    cardType?: string | null
    cardBank?: string | null
    cardBrand?: string | null
    countryCode?: string | null
    accountName?: string | null
    cardBin?: number | null
    cardLast4?: number | null
    expMonth?: number | null
    expYear?: number | null
    interval?: string | null
    emailToken?: string | null
    startDate?: Date | string | null
    endsAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutStoreInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutStoreInput, SubscriptionUncheckedCreateWithoutStoreInput>
  }

  export type TransactionCreateWithoutStoreInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutStoreInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutStoreInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutStoreInput, TransactionUncheckedCreateWithoutStoreInput>
  }

  export type TransactionCreateManyStoreInputEnvelope = {
    data: TransactionCreateManyStoreInput | TransactionCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseCreateWithoutStoreInput = {
    id?: string
    name: string
    isDefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryCreateNestedManyWithoutWarehouseInput
    staffAssigned: UserCreateNestedOneWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    isDefaultLocation?: boolean | null
    staffId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutStoreInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutStoreInput, WarehouseUncheckedCreateWithoutStoreInput>
  }

  export type WarehouseCreateManyStoreInputEnvelope = {
    data: WarehouseCreateManyStoreInput | WarehouseCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type ShippingMethodCreateWithoutStoreInput = {
    id?: string
    name: string
    description?: string | null
    carrier?: string | null
    deliveryTime: string
    baseCost: number
    costCalculation?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shippingZones?: ShippingZoneCreateNestedManyWithoutShippingMethodsInput
    Shipping?: ShippingCreateNestedManyWithoutShippingMethodInput
  }

  export type ShippingMethodUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    description?: string | null
    carrier?: string | null
    deliveryTime: string
    baseCost: number
    costCalculation?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shippingZones?: ShippingZoneUncheckedCreateNestedManyWithoutShippingMethodsInput
    Shipping?: ShippingUncheckedCreateNestedManyWithoutShippingMethodInput
  }

  export type ShippingMethodCreateOrConnectWithoutStoreInput = {
    where: ShippingMethodWhereUniqueInput
    create: XOR<ShippingMethodCreateWithoutStoreInput, ShippingMethodUncheckedCreateWithoutStoreInput>
  }

  export type ShippingMethodCreateManyStoreInputEnvelope = {
    data: ShippingMethodCreateManyStoreInput | ShippingMethodCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type ShippingZoneCreateWithoutStoreInput = {
    id?: string
    name: string
    countries?: ShippingZoneCreatecountriesInput | string[]
    regions?: ShippingZoneCreateregionsInput | string[]
    postalCodes?: ShippingZoneCreatepostalCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    shippingMethods?: ShippingMethodCreateNestedManyWithoutShippingZonesInput
  }

  export type ShippingZoneUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    countries?: ShippingZoneCreatecountriesInput | string[]
    regions?: ShippingZoneCreateregionsInput | string[]
    postalCodes?: ShippingZoneCreatepostalCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    shippingMethods?: ShippingMethodUncheckedCreateNestedManyWithoutShippingZonesInput
  }

  export type ShippingZoneCreateOrConnectWithoutStoreInput = {
    where: ShippingZoneWhereUniqueInput
    create: XOR<ShippingZoneCreateWithoutStoreInput, ShippingZoneUncheckedCreateWithoutStoreInput>
  }

  export type ShippingZoneCreateManyStoreInputEnvelope = {
    data: ShippingZoneCreateManyStoreInput | ShippingZoneCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutStoreInput = {
    id?: string
    name?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutStoreInput = {
    id?: string
    name?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutStoreInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutStoreInput, ProductCategoryUncheckedCreateWithoutStoreInput>
  }

  export type ProductCategoryCreateManyStoreInputEnvelope = {
    data: ProductCategoryCreateManyStoreInput | ProductCategoryCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutOrganizationInput, MemberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutOrganizationInput, MemberUncheckedUpdateWithoutOrganizationInput>
  }

  export type MemberUpdateManyWithWhereWithoutOrganizationInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type InvitationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutOrganizationInput, InvitationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutOrganizationInput, InvitationUncheckedUpdateWithoutOrganizationInput>
  }

  export type InvitationUpdateManyWithWhereWithoutOrganizationInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type BankDetailsUpsertWithoutStoreInput = {
    update: XOR<BankDetailsUpdateWithoutStoreInput, BankDetailsUncheckedUpdateWithoutStoreInput>
    create: XOR<BankDetailsCreateWithoutStoreInput, BankDetailsUncheckedCreateWithoutStoreInput>
    where?: BankDetailsWhereInput
  }

  export type BankDetailsUpdateToOneWithWhereWithoutStoreInput = {
    where?: BankDetailsWhereInput
    data: XOR<BankDetailsUpdateWithoutStoreInput, BankDetailsUncheckedUpdateWithoutStoreInput>
  }

  export type BankDetailsUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailsUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUpsertWithoutStoreInput = {
    update: XOR<WalletUpdateWithoutStoreInput, WalletUncheckedUpdateWithoutStoreInput>
    create: XOR<WalletCreateWithoutStoreInput, WalletUncheckedCreateWithoutStoreInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutStoreInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutStoreInput, WalletUncheckedUpdateWithoutStoreInput>
  }

  export type WalletUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpsertWithWhereUniqueWithoutStoreInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutStoreInput, LocationUncheckedUpdateWithoutStoreInput>
    create: XOR<LocationCreateWithoutStoreInput, LocationUncheckedCreateWithoutStoreInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutStoreInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutStoreInput, LocationUncheckedUpdateWithoutStoreInput>
  }

  export type LocationUpdateManyWithWhereWithoutStoreInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutStoreInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    country?: StringNullableFilter<"Location"> | string | null
    region?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    description?: StringNullableFilter<"Location"> | string | null
    storeId?: StringFilter<"Location"> | string
    isdefaultLocation?: BoolNullableFilter<"Location"> | boolean | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutStoreInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutStoreInput, OrderUncheckedUpdateWithoutStoreInput>
    create: XOR<OrderCreateWithoutStoreInput, OrderUncheckedCreateWithoutStoreInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutStoreInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutStoreInput, OrderUncheckedUpdateWithoutStoreInput>
  }

  export type OrderUpdateManyWithWhereWithoutStoreInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutStoreInput>
  }

  export type CustomerUpsertWithWhereUniqueWithoutStoreInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutStoreInput, CustomerUncheckedUpdateWithoutStoreInput>
    create: XOR<CustomerCreateWithoutStoreInput, CustomerUncheckedCreateWithoutStoreInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutStoreInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutStoreInput, CustomerUncheckedUpdateWithoutStoreInput>
  }

  export type CustomerUpdateManyWithWhereWithoutStoreInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutStoreInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    avatar?: StringNullableFilter<"Customer"> | string | null
    isGuest?: BoolFilter<"Customer"> | boolean
    customerType?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    storeId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type CustomerGroupsUpsertWithWhereUniqueWithoutStoreInput = {
    where: CustomerGroupsWhereUniqueInput
    update: XOR<CustomerGroupsUpdateWithoutStoreInput, CustomerGroupsUncheckedUpdateWithoutStoreInput>
    create: XOR<CustomerGroupsCreateWithoutStoreInput, CustomerGroupsUncheckedCreateWithoutStoreInput>
  }

  export type CustomerGroupsUpdateWithWhereUniqueWithoutStoreInput = {
    where: CustomerGroupsWhereUniqueInput
    data: XOR<CustomerGroupsUpdateWithoutStoreInput, CustomerGroupsUncheckedUpdateWithoutStoreInput>
  }

  export type CustomerGroupsUpdateManyWithWhereWithoutStoreInput = {
    where: CustomerGroupsScalarWhereInput
    data: XOR<CustomerGroupsUpdateManyMutationInput, CustomerGroupsUncheckedUpdateManyWithoutStoreInput>
  }

  export type CustomerGroupsScalarWhereInput = {
    AND?: CustomerGroupsScalarWhereInput | CustomerGroupsScalarWhereInput[]
    OR?: CustomerGroupsScalarWhereInput[]
    NOT?: CustomerGroupsScalarWhereInput | CustomerGroupsScalarWhereInput[]
    id?: StringFilter<"CustomerGroups"> | string
    name?: StringFilter<"CustomerGroups"> | string
    storeId?: StringFilter<"CustomerGroups"> | string
    createdAt?: DateTimeFilter<"CustomerGroups"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerGroups"> | Date | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutStoreInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutStoreInput, ExpenseUncheckedUpdateWithoutStoreInput>
    create: XOR<ExpenseCreateWithoutStoreInput, ExpenseUncheckedCreateWithoutStoreInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutStoreInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutStoreInput, ExpenseUncheckedUpdateWithoutStoreInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutStoreInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutStoreInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    name?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatNullableFilter<"Expense"> | number | null
    description?: StringNullableFilter<"Expense"> | string | null
    paymentMethod?: StringNullableFilter<"Expense"> | string | null
    paymentStatus?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeNullableFilter<"Expense"> | Date | string | null
    locationId?: StringFilter<"Expense"> | string
    storeId?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutStoreInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutStoreInput, InvoiceUncheckedUpdateWithoutStoreInput>
    create: XOR<InvoiceCreateWithoutStoreInput, InvoiceUncheckedCreateWithoutStoreInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutStoreInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutStoreInput, InvoiceUncheckedUpdateWithoutStoreInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutStoreInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutStoreInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    storeId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    title?: StringFilter<"Invoice"> | string
    customerEmail?: StringFilter<"Invoice"> | string
    description?: StringNullableFilter<"Invoice"> | string | null
    status?: StringNullableFilter<"Invoice"> | string | null
    downloadUrl?: StringFilter<"Invoice"> | string
    paymentLink?: StringNullableFilter<"Invoice"> | string | null
    qrCode?: StringNullableFilter<"Invoice"> | string | null
    amount?: StringFilter<"Invoice"> | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type PointOfSaleUpsertWithoutStoreInput = {
    update: XOR<PointOfSaleUpdateWithoutStoreInput, PointOfSaleUncheckedUpdateWithoutStoreInput>
    create: XOR<PointOfSaleCreateWithoutStoreInput, PointOfSaleUncheckedCreateWithoutStoreInput>
    where?: PointOfSaleWhereInput
  }

  export type PointOfSaleUpdateToOneWithWhereWithoutStoreInput = {
    where?: PointOfSaleWhereInput
    data: XOR<PointOfSaleUpdateWithoutStoreInput, PointOfSaleUncheckedUpdateWithoutStoreInput>
  }

  export type PointOfSaleUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffAssigned?: UserUpdateOneRequiredWithoutPointOfSaleNestedInput
  }

  export type PointOfSaleUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffAssignedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutStoreInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutStoreInput, ProductUncheckedUpdateWithoutStoreInput>
    create: XOR<ProductCreateWithoutStoreInput, ProductUncheckedCreateWithoutStoreInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutStoreInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutStoreInput, ProductUncheckedUpdateWithoutStoreInput>
  }

  export type ProductUpdateManyWithWhereWithoutStoreInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutStoreInput>
  }

  export type SupplierUpsertWithWhereUniqueWithoutStoreInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutStoreInput, SupplierUncheckedUpdateWithoutStoreInput>
    create: XOR<SupplierCreateWithoutStoreInput, SupplierUncheckedCreateWithoutStoreInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutStoreInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutStoreInput, SupplierUncheckedUpdateWithoutStoreInput>
  }

  export type SupplierUpdateManyWithWhereWithoutStoreInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutStoreInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: StringFilter<"Supplier"> | string
    supplierName?: StringFilter<"Supplier"> | string
    email?: StringFilter<"Supplier"> | string
    phoneNumber?: StringFilter<"Supplier"> | string
    personOfSupplier?: StringFilter<"Supplier"> | string
    location?: StringFilter<"Supplier"> | string
    storeId?: StringFilter<"Supplier"> | string
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutStoreInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutStoreInput, PurchaseUncheckedUpdateWithoutStoreInput>
    create: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutStoreInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutStoreInput, PurchaseUncheckedUpdateWithoutStoreInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutStoreInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutStoreInput>
  }

  export type SettlementUpsertWithWhereUniqueWithoutStoreInput = {
    where: SettlementWhereUniqueInput
    update: XOR<SettlementUpdateWithoutStoreInput, SettlementUncheckedUpdateWithoutStoreInput>
    create: XOR<SettlementCreateWithoutStoreInput, SettlementUncheckedCreateWithoutStoreInput>
  }

  export type SettlementUpdateWithWhereUniqueWithoutStoreInput = {
    where: SettlementWhereUniqueInput
    data: XOR<SettlementUpdateWithoutStoreInput, SettlementUncheckedUpdateWithoutStoreInput>
  }

  export type SettlementUpdateManyWithWhereWithoutStoreInput = {
    where: SettlementScalarWhereInput
    data: XOR<SettlementUpdateManyMutationInput, SettlementUncheckedUpdateManyWithoutStoreInput>
  }

  export type SettlementScalarWhereInput = {
    AND?: SettlementScalarWhereInput | SettlementScalarWhereInput[]
    OR?: SettlementScalarWhereInput[]
    NOT?: SettlementScalarWhereInput | SettlementScalarWhereInput[]
    id?: StringFilter<"Settlement"> | string
    amount?: DecimalFilter<"Settlement"> | Decimal | DecimalJsLike | number | string
    storeId?: StringFilter<"Settlement"> | string
    createdAt?: DateTimeFilter<"Settlement"> | Date | string
    updatedAt?: DateTimeFilter<"Settlement"> | Date | string
  }

  export type SubscriptionUpsertWithoutStoreInput = {
    update: XOR<SubscriptionUpdateWithoutStoreInput, SubscriptionUncheckedUpdateWithoutStoreInput>
    create: XOR<SubscriptionCreateWithoutStoreInput, SubscriptionUncheckedCreateWithoutStoreInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutStoreInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutStoreInput, SubscriptionUncheckedUpdateWithoutStoreInput>
  }

  export type SubscriptionUpdateWithoutStoreInput = {
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    customersCode?: NullableStringFieldUpdateOperationsInput | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardBank?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBin?: NullableIntFieldUpdateOperationsInput | number | null
    cardLast4?: NullableIntFieldUpdateOperationsInput | number | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableStringFieldUpdateOperationsInput | string | null
    emailToken?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    customersCode?: NullableStringFieldUpdateOperationsInput | string | null
    authorizationCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cardType?: NullableStringFieldUpdateOperationsInput | string | null
    cardBank?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    cardBin?: NullableIntFieldUpdateOperationsInput | number | null
    cardLast4?: NullableIntFieldUpdateOperationsInput | number | null
    expMonth?: NullableIntFieldUpdateOperationsInput | number | null
    expYear?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableStringFieldUpdateOperationsInput | string | null
    emailToken?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutStoreInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutStoreInput, TransactionUncheckedUpdateWithoutStoreInput>
    create: XOR<TransactionCreateWithoutStoreInput, TransactionUncheckedCreateWithoutStoreInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutStoreInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutStoreInput, TransactionUncheckedUpdateWithoutStoreInput>
  }

  export type TransactionUpdateManyWithWhereWithoutStoreInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutStoreInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    storeId?: StringNullableFilter<"Transaction"> | string | null
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type WarehouseUpsertWithWhereUniqueWithoutStoreInput = {
    where: WarehouseWhereUniqueInput
    update: XOR<WarehouseUpdateWithoutStoreInput, WarehouseUncheckedUpdateWithoutStoreInput>
    create: XOR<WarehouseCreateWithoutStoreInput, WarehouseUncheckedCreateWithoutStoreInput>
  }

  export type WarehouseUpdateWithWhereUniqueWithoutStoreInput = {
    where: WarehouseWhereUniqueInput
    data: XOR<WarehouseUpdateWithoutStoreInput, WarehouseUncheckedUpdateWithoutStoreInput>
  }

  export type WarehouseUpdateManyWithWhereWithoutStoreInput = {
    where: WarehouseScalarWhereInput
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyWithoutStoreInput>
  }

  export type WarehouseScalarWhereInput = {
    AND?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
    OR?: WarehouseScalarWhereInput[]
    NOT?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
    id?: StringFilter<"Warehouse"> | string
    name?: StringFilter<"Warehouse"> | string
    isDefaultLocation?: BoolNullableFilter<"Warehouse"> | boolean | null
    staffId?: StringFilter<"Warehouse"> | string
    storeId?: StringFilter<"Warehouse"> | string
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
  }

  export type ShippingMethodUpsertWithWhereUniqueWithoutStoreInput = {
    where: ShippingMethodWhereUniqueInput
    update: XOR<ShippingMethodUpdateWithoutStoreInput, ShippingMethodUncheckedUpdateWithoutStoreInput>
    create: XOR<ShippingMethodCreateWithoutStoreInput, ShippingMethodUncheckedCreateWithoutStoreInput>
  }

  export type ShippingMethodUpdateWithWhereUniqueWithoutStoreInput = {
    where: ShippingMethodWhereUniqueInput
    data: XOR<ShippingMethodUpdateWithoutStoreInput, ShippingMethodUncheckedUpdateWithoutStoreInput>
  }

  export type ShippingMethodUpdateManyWithWhereWithoutStoreInput = {
    where: ShippingMethodScalarWhereInput
    data: XOR<ShippingMethodUpdateManyMutationInput, ShippingMethodUncheckedUpdateManyWithoutStoreInput>
  }

  export type ShippingMethodScalarWhereInput = {
    AND?: ShippingMethodScalarWhereInput | ShippingMethodScalarWhereInput[]
    OR?: ShippingMethodScalarWhereInput[]
    NOT?: ShippingMethodScalarWhereInput | ShippingMethodScalarWhereInput[]
    id?: StringFilter<"ShippingMethod"> | string
    name?: StringFilter<"ShippingMethod"> | string
    storeId?: StringFilter<"ShippingMethod"> | string
    description?: StringNullableFilter<"ShippingMethod"> | string | null
    carrier?: StringNullableFilter<"ShippingMethod"> | string | null
    deliveryTime?: StringFilter<"ShippingMethod"> | string
    baseCost?: FloatFilter<"ShippingMethod"> | number
    costCalculation?: StringNullableFilter<"ShippingMethod"> | string | null
    isActive?: BoolFilter<"ShippingMethod"> | boolean
    createdAt?: DateTimeFilter<"ShippingMethod"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingMethod"> | Date | string
  }

  export type ShippingZoneUpsertWithWhereUniqueWithoutStoreInput = {
    where: ShippingZoneWhereUniqueInput
    update: XOR<ShippingZoneUpdateWithoutStoreInput, ShippingZoneUncheckedUpdateWithoutStoreInput>
    create: XOR<ShippingZoneCreateWithoutStoreInput, ShippingZoneUncheckedCreateWithoutStoreInput>
  }

  export type ShippingZoneUpdateWithWhereUniqueWithoutStoreInput = {
    where: ShippingZoneWhereUniqueInput
    data: XOR<ShippingZoneUpdateWithoutStoreInput, ShippingZoneUncheckedUpdateWithoutStoreInput>
  }

  export type ShippingZoneUpdateManyWithWhereWithoutStoreInput = {
    where: ShippingZoneScalarWhereInput
    data: XOR<ShippingZoneUpdateManyMutationInput, ShippingZoneUncheckedUpdateManyWithoutStoreInput>
  }

  export type ShippingZoneScalarWhereInput = {
    AND?: ShippingZoneScalarWhereInput | ShippingZoneScalarWhereInput[]
    OR?: ShippingZoneScalarWhereInput[]
    NOT?: ShippingZoneScalarWhereInput | ShippingZoneScalarWhereInput[]
    id?: StringFilter<"ShippingZone"> | string
    name?: StringFilter<"ShippingZone"> | string
    storeId?: StringFilter<"ShippingZone"> | string
    countries?: StringNullableListFilter<"ShippingZone">
    regions?: StringNullableListFilter<"ShippingZone">
    postalCodes?: StringNullableListFilter<"ShippingZone">
    createdAt?: DateTimeFilter<"ShippingZone"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingZone"> | Date | string
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutStoreInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutStoreInput, ProductCategoryUncheckedUpdateWithoutStoreInput>
    create: XOR<ProductCategoryCreateWithoutStoreInput, ProductCategoryUncheckedCreateWithoutStoreInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutStoreInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutStoreInput, ProductCategoryUncheckedUpdateWithoutStoreInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutStoreInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutStoreInput>
  }

  export type OrganizationCreateWithoutMembersInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutMembersInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutMembersInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitations?: InvitationCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    PointOfSale?: PointOfSaleCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseCreateNestedOneWithoutStaffAssignedInput
    POS?: POSCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutMembersInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    PointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseUncheckedCreateNestedOneWithoutStaffAssignedInput
    POS?: POSUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
  }

  export type OrganizationUpsertWithoutMembersInput = {
    update: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMembersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserUpsertWithoutMembersInput = {
    update: XOR<UserUpdateWithoutMembersInput, UserUncheckedUpdateWithoutMembersInput>
    create: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembersInput, UserUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    PointOfSale?: PointOfSaleUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    PointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUncheckedUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type OrganizationCreateWithoutInvitationsInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutInvitationsInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutInvitationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutInvitationsInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    PointOfSale?: PointOfSaleCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseCreateNestedOneWithoutStaffAssignedInput
    POS?: POSCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    PointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStaffAssignedInput
    warehouse?: WarehouseUncheckedCreateNestedOneWithoutStaffAssignedInput
    POS?: POSUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
  }

  export type OrganizationUpsertWithoutInvitationsInput = {
    update: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type OrganizationUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserUpsertWithoutInvitationsInput = {
    update: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    PointOfSale?: PointOfSaleUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    PointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUncheckedUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type OrganizationCreateWithoutSettlementsInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutSettlementsInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutSettlementsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSettlementsInput, OrganizationUncheckedCreateWithoutSettlementsInput>
  }

  export type OrganizationUpsertWithoutSettlementsInput = {
    update: XOR<OrganizationUpdateWithoutSettlementsInput, OrganizationUncheckedUpdateWithoutSettlementsInput>
    create: XOR<OrganizationCreateWithoutSettlementsInput, OrganizationUncheckedCreateWithoutSettlementsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSettlementsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSettlementsInput, OrganizationUncheckedUpdateWithoutSettlementsInput>
  }

  export type OrganizationUpdateWithoutSettlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSettlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ShippingMethodCreateWithoutShippingInput = {
    id?: string
    name: string
    description?: string | null
    carrier?: string | null
    deliveryTime: string
    baseCost: number
    costCalculation?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutShippingMethodInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutShippingMethodsInput
  }

  export type ShippingMethodUncheckedCreateWithoutShippingInput = {
    id?: string
    name: string
    storeId: string
    description?: string | null
    carrier?: string | null
    deliveryTime: string
    baseCost: number
    costCalculation?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    shippingZones?: ShippingZoneUncheckedCreateNestedManyWithoutShippingMethodsInput
  }

  export type ShippingMethodCreateOrConnectWithoutShippingInput = {
    where: ShippingMethodWhereUniqueInput
    create: XOR<ShippingMethodCreateWithoutShippingInput, ShippingMethodUncheckedCreateWithoutShippingInput>
  }

  export type ShippingAuditCreateWithoutShippingInput = {
    id?: string
    action: string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShippingAuditUncheckedCreateWithoutShippingInput = {
    id?: string
    action: string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShippingAuditCreateOrConnectWithoutShippingInput = {
    where: ShippingAuditWhereUniqueInput
    create: XOR<ShippingAuditCreateWithoutShippingInput, ShippingAuditUncheckedCreateWithoutShippingInput>
  }

  export type ShippingAuditCreateManyShippingInputEnvelope = {
    data: ShippingAuditCreateManyShippingInput | ShippingAuditCreateManyShippingInput[]
    skipDuplicates?: boolean
  }

  export type ShippingMethodUpsertWithoutShippingInput = {
    update: XOR<ShippingMethodUpdateWithoutShippingInput, ShippingMethodUncheckedUpdateWithoutShippingInput>
    create: XOR<ShippingMethodCreateWithoutShippingInput, ShippingMethodUncheckedCreateWithoutShippingInput>
    where?: ShippingMethodWhereInput
  }

  export type ShippingMethodUpdateToOneWithWhereWithoutShippingInput = {
    where?: ShippingMethodWhereInput
    data: XOR<ShippingMethodUpdateWithoutShippingInput, ShippingMethodUncheckedUpdateWithoutShippingInput>
  }

  export type ShippingMethodUpdateWithoutShippingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    costCalculation?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutShippingMethodNestedInput
    shippingZones?: ShippingZoneUpdateManyWithoutShippingMethodsNestedInput
  }

  export type ShippingMethodUncheckedUpdateWithoutShippingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    costCalculation?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippingZones?: ShippingZoneUncheckedUpdateManyWithoutShippingMethodsNestedInput
  }

  export type ShippingAuditUpsertWithWhereUniqueWithoutShippingInput = {
    where: ShippingAuditWhereUniqueInput
    update: XOR<ShippingAuditUpdateWithoutShippingInput, ShippingAuditUncheckedUpdateWithoutShippingInput>
    create: XOR<ShippingAuditCreateWithoutShippingInput, ShippingAuditUncheckedCreateWithoutShippingInput>
  }

  export type ShippingAuditUpdateWithWhereUniqueWithoutShippingInput = {
    where: ShippingAuditWhereUniqueInput
    data: XOR<ShippingAuditUpdateWithoutShippingInput, ShippingAuditUncheckedUpdateWithoutShippingInput>
  }

  export type ShippingAuditUpdateManyWithWhereWithoutShippingInput = {
    where: ShippingAuditScalarWhereInput
    data: XOR<ShippingAuditUpdateManyMutationInput, ShippingAuditUncheckedUpdateManyWithoutShippingInput>
  }

  export type ShippingAuditScalarWhereInput = {
    AND?: ShippingAuditScalarWhereInput | ShippingAuditScalarWhereInput[]
    OR?: ShippingAuditScalarWhereInput[]
    NOT?: ShippingAuditScalarWhereInput | ShippingAuditScalarWhereInput[]
    id?: StringFilter<"ShippingAudit"> | string
    shippingId?: StringFilter<"ShippingAudit"> | string
    action?: StringFilter<"ShippingAudit"> | string
    details?: StringNullableFilter<"ShippingAudit"> | string | null
    createdAt?: DateTimeFilter<"ShippingAudit"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingAudit"> | Date | string
    userId?: StringNullableFilter<"ShippingAudit"> | string | null
    metadata?: JsonNullableFilter<"ShippingAudit">
  }

  export type OrganizationCreateWithoutShippingMethodInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutShippingMethodInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutShippingMethodInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutShippingMethodInput, OrganizationUncheckedCreateWithoutShippingMethodInput>
  }

  export type ShippingZoneCreateWithoutShippingMethodsInput = {
    id?: string
    name: string
    countries?: ShippingZoneCreatecountriesInput | string[]
    regions?: ShippingZoneCreateregionsInput | string[]
    postalCodes?: ShippingZoneCreatepostalCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutShippingZoneInput
  }

  export type ShippingZoneUncheckedCreateWithoutShippingMethodsInput = {
    id?: string
    name: string
    storeId: string
    countries?: ShippingZoneCreatecountriesInput | string[]
    regions?: ShippingZoneCreateregionsInput | string[]
    postalCodes?: ShippingZoneCreatepostalCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingZoneCreateOrConnectWithoutShippingMethodsInput = {
    where: ShippingZoneWhereUniqueInput
    create: XOR<ShippingZoneCreateWithoutShippingMethodsInput, ShippingZoneUncheckedCreateWithoutShippingMethodsInput>
  }

  export type ShippingCreateWithoutShippingMethodInput = {
    id?: string
    orderId: string
    trackingNumber?: string | null
    carrier?: string | null
    status?: $Enums.ShippingStatus
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    shippingAddress: string
    shippingZoneName?: string | null
    shippingFee?: Decimal | DecimalJsLike | number | string
    weight?: number | null
    dimensions?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: ShippingAuditCreateNestedManyWithoutShippingInput
  }

  export type ShippingUncheckedCreateWithoutShippingMethodInput = {
    id?: string
    orderId: string
    trackingNumber?: string | null
    carrier?: string | null
    status?: $Enums.ShippingStatus
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    shippingAddress: string
    shippingZoneName?: string | null
    shippingFee?: Decimal | DecimalJsLike | number | string
    weight?: number | null
    dimensions?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: ShippingAuditUncheckedCreateNestedManyWithoutShippingInput
  }

  export type ShippingCreateOrConnectWithoutShippingMethodInput = {
    where: ShippingWhereUniqueInput
    create: XOR<ShippingCreateWithoutShippingMethodInput, ShippingUncheckedCreateWithoutShippingMethodInput>
  }

  export type ShippingCreateManyShippingMethodInputEnvelope = {
    data: ShippingCreateManyShippingMethodInput | ShippingCreateManyShippingMethodInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutShippingMethodInput = {
    update: XOR<OrganizationUpdateWithoutShippingMethodInput, OrganizationUncheckedUpdateWithoutShippingMethodInput>
    create: XOR<OrganizationCreateWithoutShippingMethodInput, OrganizationUncheckedCreateWithoutShippingMethodInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutShippingMethodInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutShippingMethodInput, OrganizationUncheckedUpdateWithoutShippingMethodInput>
  }

  export type OrganizationUpdateWithoutShippingMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutShippingMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ShippingZoneUpsertWithWhereUniqueWithoutShippingMethodsInput = {
    where: ShippingZoneWhereUniqueInput
    update: XOR<ShippingZoneUpdateWithoutShippingMethodsInput, ShippingZoneUncheckedUpdateWithoutShippingMethodsInput>
    create: XOR<ShippingZoneCreateWithoutShippingMethodsInput, ShippingZoneUncheckedCreateWithoutShippingMethodsInput>
  }

  export type ShippingZoneUpdateWithWhereUniqueWithoutShippingMethodsInput = {
    where: ShippingZoneWhereUniqueInput
    data: XOR<ShippingZoneUpdateWithoutShippingMethodsInput, ShippingZoneUncheckedUpdateWithoutShippingMethodsInput>
  }

  export type ShippingZoneUpdateManyWithWhereWithoutShippingMethodsInput = {
    where: ShippingZoneScalarWhereInput
    data: XOR<ShippingZoneUpdateManyMutationInput, ShippingZoneUncheckedUpdateManyWithoutShippingMethodsInput>
  }

  export type ShippingUpsertWithWhereUniqueWithoutShippingMethodInput = {
    where: ShippingWhereUniqueInput
    update: XOR<ShippingUpdateWithoutShippingMethodInput, ShippingUncheckedUpdateWithoutShippingMethodInput>
    create: XOR<ShippingCreateWithoutShippingMethodInput, ShippingUncheckedCreateWithoutShippingMethodInput>
  }

  export type ShippingUpdateWithWhereUniqueWithoutShippingMethodInput = {
    where: ShippingWhereUniqueInput
    data: XOR<ShippingUpdateWithoutShippingMethodInput, ShippingUncheckedUpdateWithoutShippingMethodInput>
  }

  export type ShippingUpdateManyWithWhereWithoutShippingMethodInput = {
    where: ShippingScalarWhereInput
    data: XOR<ShippingUpdateManyMutationInput, ShippingUncheckedUpdateManyWithoutShippingMethodInput>
  }

  export type ShippingScalarWhereInput = {
    AND?: ShippingScalarWhereInput | ShippingScalarWhereInput[]
    OR?: ShippingScalarWhereInput[]
    NOT?: ShippingScalarWhereInput | ShippingScalarWhereInput[]
    id?: StringFilter<"Shipping"> | string
    orderId?: StringFilter<"Shipping"> | string
    shippingMethodId?: StringFilter<"Shipping"> | string
    trackingNumber?: StringNullableFilter<"Shipping"> | string | null
    carrier?: StringNullableFilter<"Shipping"> | string | null
    status?: EnumShippingStatusFilter<"Shipping"> | $Enums.ShippingStatus
    estimatedDelivery?: DateTimeNullableFilter<"Shipping"> | Date | string | null
    actualDelivery?: DateTimeNullableFilter<"Shipping"> | Date | string | null
    shippingAddress?: StringFilter<"Shipping"> | string
    shippingZoneName?: StringNullableFilter<"Shipping"> | string | null
    shippingFee?: DecimalFilter<"Shipping"> | Decimal | DecimalJsLike | number | string
    weight?: FloatNullableFilter<"Shipping"> | number | null
    dimensions?: StringNullableFilter<"Shipping"> | string | null
    notes?: StringNullableFilter<"Shipping"> | string | null
    createdAt?: DateTimeFilter<"Shipping"> | Date | string
    updatedAt?: DateTimeFilter<"Shipping"> | Date | string
  }

  export type OrganizationCreateWithoutShippingZoneInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutShippingZoneInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutShippingZoneInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutShippingZoneInput, OrganizationUncheckedCreateWithoutShippingZoneInput>
  }

  export type ShippingMethodCreateWithoutShippingZonesInput = {
    id?: string
    name: string
    description?: string | null
    carrier?: string | null
    deliveryTime: string
    baseCost: number
    costCalculation?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: OrganizationCreateNestedOneWithoutShippingMethodInput
    Shipping?: ShippingCreateNestedManyWithoutShippingMethodInput
  }

  export type ShippingMethodUncheckedCreateWithoutShippingZonesInput = {
    id?: string
    name: string
    storeId: string
    description?: string | null
    carrier?: string | null
    deliveryTime: string
    baseCost: number
    costCalculation?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Shipping?: ShippingUncheckedCreateNestedManyWithoutShippingMethodInput
  }

  export type ShippingMethodCreateOrConnectWithoutShippingZonesInput = {
    where: ShippingMethodWhereUniqueInput
    create: XOR<ShippingMethodCreateWithoutShippingZonesInput, ShippingMethodUncheckedCreateWithoutShippingZonesInput>
  }

  export type OrganizationUpsertWithoutShippingZoneInput = {
    update: XOR<OrganizationUpdateWithoutShippingZoneInput, OrganizationUncheckedUpdateWithoutShippingZoneInput>
    create: XOR<OrganizationCreateWithoutShippingZoneInput, OrganizationUncheckedCreateWithoutShippingZoneInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutShippingZoneInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutShippingZoneInput, OrganizationUncheckedUpdateWithoutShippingZoneInput>
  }

  export type OrganizationUpdateWithoutShippingZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutShippingZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ShippingMethodUpsertWithWhereUniqueWithoutShippingZonesInput = {
    where: ShippingMethodWhereUniqueInput
    update: XOR<ShippingMethodUpdateWithoutShippingZonesInput, ShippingMethodUncheckedUpdateWithoutShippingZonesInput>
    create: XOR<ShippingMethodCreateWithoutShippingZonesInput, ShippingMethodUncheckedCreateWithoutShippingZonesInput>
  }

  export type ShippingMethodUpdateWithWhereUniqueWithoutShippingZonesInput = {
    where: ShippingMethodWhereUniqueInput
    data: XOR<ShippingMethodUpdateWithoutShippingZonesInput, ShippingMethodUncheckedUpdateWithoutShippingZonesInput>
  }

  export type ShippingMethodUpdateManyWithWhereWithoutShippingZonesInput = {
    where: ShippingMethodScalarWhereInput
    data: XOR<ShippingMethodUpdateManyMutationInput, ShippingMethodUncheckedUpdateManyWithoutShippingZonesInput>
  }

  export type ShippingCreateWithoutAuditLogsInput = {
    id?: string
    orderId: string
    trackingNumber?: string | null
    carrier?: string | null
    status?: $Enums.ShippingStatus
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    shippingAddress: string
    shippingZoneName?: string | null
    shippingFee?: Decimal | DecimalJsLike | number | string
    weight?: number | null
    dimensions?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shippingMethod: ShippingMethodCreateNestedOneWithoutShippingInput
  }

  export type ShippingUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    orderId: string
    shippingMethodId: string
    trackingNumber?: string | null
    carrier?: string | null
    status?: $Enums.ShippingStatus
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    shippingAddress: string
    shippingZoneName?: string | null
    shippingFee?: Decimal | DecimalJsLike | number | string
    weight?: number | null
    dimensions?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingCreateOrConnectWithoutAuditLogsInput = {
    where: ShippingWhereUniqueInput
    create: XOR<ShippingCreateWithoutAuditLogsInput, ShippingUncheckedCreateWithoutAuditLogsInput>
  }

  export type ShippingUpsertWithoutAuditLogsInput = {
    update: XOR<ShippingUpdateWithoutAuditLogsInput, ShippingUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ShippingCreateWithoutAuditLogsInput, ShippingUncheckedCreateWithoutAuditLogsInput>
    where?: ShippingWhereInput
  }

  export type ShippingUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ShippingWhereInput
    data: XOR<ShippingUpdateWithoutAuditLogsInput, ShippingUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ShippingUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShippingStatusFieldUpdateOperationsInput | $Enums.ShippingStatus
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: StringFieldUpdateOperationsInput | string
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippingMethod?: ShippingMethodUpdateOneRequiredWithoutShippingNestedInput
  }

  export type ShippingUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    shippingMethodId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShippingStatusFieldUpdateOperationsInput | $Enums.ShippingStatus
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: StringFieldUpdateOperationsInput | string
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutSubscriptionInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutSubscriptionInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutSubscriptionInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSubscriptionInput, OrganizationUncheckedCreateWithoutSubscriptionInput>
  }

  export type OrganizationUpsertWithoutSubscriptionInput = {
    update: XOR<OrganizationUpdateWithoutSubscriptionInput, OrganizationUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<OrganizationCreateWithoutSubscriptionInput, OrganizationUncheckedCreateWithoutSubscriptionInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSubscriptionInput, OrganizationUncheckedUpdateWithoutSubscriptionInput>
  }

  export type OrganizationUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationCreateWithoutTransactionInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    warehouse?: WarehouseCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutTransactionInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    warehouse?: WarehouseUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutTransactionInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTransactionInput, OrganizationUncheckedCreateWithoutTransactionInput>
  }

  export type OrganizationUpsertWithoutTransactionInput = {
    update: XOR<OrganizationUpdateWithoutTransactionInput, OrganizationUncheckedUpdateWithoutTransactionInput>
    create: XOR<OrganizationCreateWithoutTransactionInput, OrganizationUncheckedCreateWithoutTransactionInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTransactionInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTransactionInput, OrganizationUncheckedUpdateWithoutTransactionInput>
  }

  export type OrganizationUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    warehouse?: WarehouseUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    warehouse?: WarehouseUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ProductCreateWithoutWarehouseInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredBrands?: FeaturedBrandsCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryCreateNestedManyWithoutProductInput
    collection?: ProductCollectionCreateNestedOneWithoutProductsInput
    purchase?: PurchaseCreateNestedOneWithoutProductsInput
    store: OrganizationCreateNestedOneWithoutProductInput
    location?: LocationCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutWarehouseInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredBrands?: FeaturedBrandsUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutWarehouseInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWarehouseInput, ProductUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductCreateManyWarehouseInputEnvelope = {
    data: ProductCreateManyWarehouseInput | ProductCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutWarehouseInput = {
    id?: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryUncheckedCreateWithoutWarehouseInput = {
    id?: string
    quantity?: number
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateOrConnectWithoutWarehouseInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutWarehouseInput, InventoryUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryCreateManyWarehouseInputEnvelope = {
    data: InventoryCreateManyWarehouseInput | InventoryCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutWarehouseInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    PointOfSale?: PointOfSaleCreateNestedOneWithoutStaffAssignedInput
    POS?: POSCreateNestedManyWithoutStaffInput
  }

  export type UserUncheckedCreateWithoutWarehouseInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    PointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStaffAssignedInput
    POS?: POSUncheckedCreateNestedManyWithoutStaffInput
  }

  export type UserCreateOrConnectWithoutWarehouseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWarehouseInput, UserUncheckedCreateWithoutWarehouseInput>
  }

  export type OrganizationCreateWithoutWarehouseInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsCreateNestedOneWithoutStoreInput
    wallet?: WalletCreateNestedOneWithoutStoreInput
    location?: LocationCreateNestedManyWithoutStoreInput
    order?: OrderCreateNestedManyWithoutStoreInput
    customer?: CustomerCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsCreateNestedManyWithoutStoreInput
    expense?: ExpenseCreateNestedManyWithoutStoreInput
    invoice?: InvoiceCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleCreateNestedOneWithoutStoreInput
    product?: ProductCreateNestedManyWithoutStoreInput
    supplier?: SupplierCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    settlements?: SettlementCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionCreateNestedOneWithoutStoreInput
    transaction?: TransactionCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryCreateNestedManyWithoutStoreInput
  }

  export type OrganizationUncheckedCreateWithoutWarehouseInput = {
    id: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: string | null
    businessName?: string | null
    businessType?: string | null
    storeBaseCurrency?: string | null
    banner?: string | null
    phoneNumber?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    country?: string | null
    address?: string | null
    state?: string | null
    region?: string | null
    zipCode?: string | null
    city?: string | null
    status?: string | null
    storeTag?: string | null
    whitelabel?: string | null
    facebook?: string | null
    instagram?: string | null
    tiktok?: string | null
    twitter?: string | null
    linkedin?: string | null
    currency?: string | null
    storeUrl?: string | null
    storeApproval?: boolean | null
    modifyProductState?: boolean | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    bankDetails?: BankDetailsUncheckedCreateNestedOneWithoutStoreInput
    wallet?: WalletUncheckedCreateNestedOneWithoutStoreInput
    location?: LocationUncheckedCreateNestedManyWithoutStoreInput
    order?: OrderUncheckedCreateNestedManyWithoutStoreInput
    customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    customerGroups?: CustomerGroupsUncheckedCreateNestedManyWithoutStoreInput
    expense?: ExpenseUncheckedCreateNestedManyWithoutStoreInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutStoreInput
    pointOfSale?: PointOfSaleUncheckedCreateNestedOneWithoutStoreInput
    product?: ProductUncheckedCreateNestedManyWithoutStoreInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutStoreInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutStoreInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutStoreInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutStoreInput
    ShippingZone?: ShippingZoneUncheckedCreateNestedManyWithoutStoreInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type OrganizationCreateOrConnectWithoutWarehouseInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutWarehouseInput, OrganizationUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutWarehouseInput, ProductUncheckedUpdateWithoutWarehouseInput>
    create: XOR<ProductCreateWithoutWarehouseInput, ProductUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutWarehouseInput, ProductUncheckedUpdateWithoutWarehouseInput>
  }

  export type ProductUpdateManyWithWhereWithoutWarehouseInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type InventoryUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutWarehouseInput, InventoryUncheckedUpdateWithoutWarehouseInput>
    create: XOR<InventoryCreateWithoutWarehouseInput, InventoryUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutWarehouseInput, InventoryUncheckedUpdateWithoutWarehouseInput>
  }

  export type InventoryUpdateManyWithWhereWithoutWarehouseInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type UserUpsertWithoutWarehouseInput = {
    update: XOR<UserUpdateWithoutWarehouseInput, UserUncheckedUpdateWithoutWarehouseInput>
    create: XOR<UserCreateWithoutWarehouseInput, UserUncheckedCreateWithoutWarehouseInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWarehouseInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWarehouseInput, UserUncheckedUpdateWithoutWarehouseInput>
  }

  export type UserUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    PointOfSale?: PointOfSaleUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    PointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type OrganizationUpsertWithoutWarehouseInput = {
    update: XOR<OrganizationUpdateWithoutWarehouseInput, OrganizationUncheckedUpdateWithoutWarehouseInput>
    create: XOR<OrganizationCreateWithoutWarehouseInput, OrganizationUncheckedCreateWithoutWarehouseInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutWarehouseInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutWarehouseInput, OrganizationUncheckedUpdateWithoutWarehouseInput>
  }

  export type OrganizationUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUpdateOneWithoutStoreNestedInput
    wallet?: WalletUpdateOneWithoutStoreNestedInput
    location?: LocationUpdateManyWithoutStoreNestedInput
    order?: OrderUpdateManyWithoutStoreNestedInput
    customer?: CustomerUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUpdateOneWithoutStoreNestedInput
    product?: ProductUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutStoreNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    storeBaseCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    storeTag?: NullableStringFieldUpdateOperationsInput | string | null
    whitelabel?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    storeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    storeApproval?: NullableBoolFieldUpdateOperationsInput | boolean | null
    modifyProductState?: NullableBoolFieldUpdateOperationsInput | boolean | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    bankDetails?: BankDetailsUncheckedUpdateOneWithoutStoreNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutStoreNestedInput
    location?: LocationUncheckedUpdateManyWithoutStoreNestedInput
    order?: OrderUncheckedUpdateManyWithoutStoreNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    customerGroups?: CustomerGroupsUncheckedUpdateManyWithoutStoreNestedInput
    expense?: ExpenseUncheckedUpdateManyWithoutStoreNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutStoreNestedInput
    pointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStoreNestedInput
    product?: ProductUncheckedUpdateManyWithoutStoreNestedInput
    supplier?: SupplierUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutStoreNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutStoreNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutStoreNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutStoreNestedInput
    ShippingZone?: ShippingZoneUncheckedUpdateManyWithoutStoreNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ProductCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featuredBrands?: FeaturedBrandsCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    collection?: ProductCollectionCreateNestedOneWithoutProductsInput
    purchase?: PurchaseCreateNestedOneWithoutProductsInput
    store: OrganizationCreateNestedOneWithoutProductInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryInput
    location?: LocationCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
    featuredBrands?: FeaturedBrandsUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    productVariation?: ProductVariationUncheckedCreateNestedManyWithoutProductInput
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
  }

  export type WarehouseCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    isDefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductCreateNestedManyWithoutWarehouseInput
    staffAssigned: UserCreateNestedOneWithoutWarehouseInput
    store: OrganizationCreateNestedOneWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    isDefaultLocation?: boolean | null
    staffId: string
    storeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: ProductUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutInventoryItemsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
  }

  export type ProductUpsertWithoutInventoryItemsInput = {
    update: XOR<ProductUpdateWithoutInventoryItemsInput, ProductUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryItemsInput, ProductUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ProductUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredBrands?: FeaturedBrandsUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    collection?: ProductCollectionUpdateOneWithoutProductsNestedInput
    purchase?: PurchaseUpdateOneWithoutProductsNestedInput
    store?: OrganizationUpdateOneRequiredWithoutProductNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryNestedInput
    location?: LocationUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredBrands?: FeaturedBrandsUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseUpsertWithoutInventoryItemsInput = {
    update: XOR<WarehouseUpdateWithoutInventoryItemsInput, WarehouseUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutInventoryItemsInput, WarehouseUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type WarehouseUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductUpdateManyWithoutWarehouseNestedInput
    staffAssigned?: UserUpdateOneRequiredWithoutWarehouseNestedInput
    store?: OrganizationUpdateOneRequiredWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    staffId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type CartItemCreateManyCartInput = {
    id?: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    locationId: string
    createdBy?: string | null
    storeId?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartCreateManyCustomerInput = {
    id?: string
    storeId: string
    orderId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseHistoryCreateManyCustomerInput = {
    id?: string
    orderId: string
    totalAmount: number
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSCreateManyCustomerInput = {
    id?: string
    staffId: string
    orderId: string
    terminalId: string
    confirmed?: boolean
    confirmedAt?: Date | string | null
  }

  export type CustomerGroupMemberCreateManyCustomerInput = {
    customerGroupId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    pos?: POSUpdateOneWithoutOrderNestedInput
    cart?: CartUpdateOneWithoutOrderNestedInput
    location?: LocationUpdateOneWithoutOrderNestedInput
    store?: OrganizationUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    pos?: POSUncheckedUpdateOneWithoutOrderNestedInput
    cart?: CartUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutCartNestedInput
    order?: OrderUpdateOneRequiredWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staff?: UserUpdateOneRequiredWithoutPOSNestedInput
    order?: OrderUpdateOneRequiredWithoutPosNestedInput
  }

  export type POSUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type POSUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerGroupMemberUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerGroup?: CustomerGroupsUpdateOneRequiredWithoutCustomerGroupMemberNestedInput
  }

  export type CustomerGroupMemberUncheckedUpdateWithoutCustomerInput = {
    customerGroupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupMemberUncheckedUpdateManyWithoutCustomerInput = {
    customerGroupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupMemberCreateManyCustomerGroupInput = {
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerGroupMemberUpdateWithoutCustomerGroupInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCustomerGroupMemberNestedInput
  }

  export type CustomerGroupMemberUncheckedUpdateWithoutCustomerGroupInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupMemberUncheckedUpdateManyWithoutCustomerGroupInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryCreateManyExpenseInput = {
    id?: string
    name: string
    description: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCategoryUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryUncheckedUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryUncheckedUpdateManyWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyLocationInput = {
    id?: string
    name?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phoneNumber?: string | null
    emailVerified?: boolean | null
    image?: string | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyLocationInput = {
    id?: string
    customerId: string
    createdBy?: string | null
    storeId?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyLocationInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
  }

  export type UserUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    PointOfSale?: PointOfSaleUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    PointOfSale?: PointOfSaleUncheckedUpdateOneWithoutStaffAssignedNestedInput
    warehouse?: WarehouseUncheckedUpdateOneWithoutStaffAssignedNestedInput
    POS?: POSUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type UserUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    pos?: POSUpdateOneWithoutOrderNestedInput
    cart?: CartUpdateOneWithoutOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    store?: OrganizationUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    pos?: POSUncheckedUpdateOneWithoutOrderNestedInput
    cart?: CartUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredBrands?: FeaturedBrandsUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    collection?: ProductCollectionUpdateOneWithoutProductsNestedInput
    purchase?: PurchaseUpdateOneWithoutProductsNestedInput
    store?: OrganizationUpdateOneRequiredWithoutProductNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryNestedInput
  }

  export type ProductUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredBrands?: FeaturedBrandsUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    quantity: number
    price: number
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type FeaturedBrandsCreateManyProductInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateManyProductInput = {
    id?: string
    cartId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationCreateManyProductInput = {
    id?: string
    sku: string
    price: number
    cost?: number | null
    discountPrice?: number | null
    stock?: number
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateManyProductInput = {
    id?: string
    quantity?: number
    warehouseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedBrandsUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedBrandsUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedBrandsUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ProductVariationOptionUpdateManyWithoutVariationNestedInput
  }

  export type ProductVariationUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ProductVariationOptionUncheckedUpdateManyWithoutVariationNestedInput
  }

  export type ProductVariationUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    warehouseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    warehouseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredBrands?: FeaturedBrandsUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    collection?: ProductCollectionUpdateOneWithoutProductsNestedInput
    purchase?: PurchaseUpdateOneWithoutProductsNestedInput
    store?: OrganizationUpdateOneRequiredWithoutProductNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryNestedInput
    location?: LocationUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredBrands?: FeaturedBrandsUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateManyCollectionInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    purchaseOrderId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
  }

  export type ProductUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredBrands?: FeaturedBrandsUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    purchase?: PurchaseUpdateOneWithoutProductsNestedInput
    store?: OrganizationUpdateOneRequiredWithoutProductNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryNestedInput
    location?: LocationUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredBrands?: FeaturedBrandsUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductVariationOptionCreateManyVariationInput = {
    id?: string
    valueId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationOptionUpdateWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: ProductVariantValueUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type ProductVariationOptionUncheckedUpdateWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationOptionUncheckedUpdateManyWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    valueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantValueCreateManyVariantInput = {
    id?: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantValueUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ProductVariationOptionUpdateManyWithoutValueNestedInput
  }

  export type ProductVariantValueUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ProductVariationOptionUncheckedUpdateManyWithoutValueNestedInput
  }

  export type ProductVariantValueUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationOptionCreateManyValueInput = {
    id?: string
    variationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariationOptionUpdateWithoutValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: ProductVariationUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type ProductVariationOptionUncheckedUpdateWithoutValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariationOptionUncheckedUpdateManyWithoutValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManyStoreSupplierInput = {
    id?: string
    status: string
    downloadUrl: string
    toalCost: Decimal | DecimalJsLike | number | string
    storeId: string
    deliveryDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateWithoutStoreSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    toalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutPurchaseNestedInput
    products?: ProductUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutStoreSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    toalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    storeId?: StringFieldUpdateOperationsInput | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutStoreSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    toalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    storeId?: StringFieldUpdateOperationsInput | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyPurchaseInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
  }

  export type ProductUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredBrands?: FeaturedBrandsUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    collection?: ProductCollectionUpdateOneWithoutProductsNestedInput
    store?: OrganizationUpdateOneRequiredWithoutProductNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryNestedInput
    location?: LocationUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredBrands?: FeaturedBrandsUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberCreateManyUserInput = {
    id: string
    organizationId: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationCreateManyUserInput = {
    id: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
    activeOrganizationId?: string | null
  }

  export type AccountCreateManyUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type POSCreateManyStaffInput = {
    id?: string
    orderId: string
    customerId: string
    terminalId: string
    confirmed?: boolean
    confirmedAt?: Date | string | null
  }

  export type MemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    activeOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutPosNestedInput
    order?: OrderUpdateOneRequiredWithoutPosNestedInput
  }

  export type POSUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type POSUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCreateManyOrganizationInput = {
    id: string
    userId: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationCreateManyOrganizationInput = {
    id: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationCreateManyStoreInput = {
    id?: string
    name: string
    address?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    description?: string | null
    isdefaultLocation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyStoreInput = {
    id?: string
    customerId: string
    locationId: string
    createdBy?: string | null
    shippingMethodId?: string | null
    grandTotal: number
    iscustomerAssigned?: boolean
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    deliveryTrackingNumber: number
    totalAmount: number
    subtotalAmount: number
    discountAmount?: number | null
    taxAmount: number
    shippingFee: number
    shippingZoneName?: string | null
    shippingAddress?: string | null
    shippingStatus?: string | null
    channel?: string | null
    isposConfirmed?: boolean | null
    customerName: string
    customerEmail: string
    customerPhoneNumber: string
    posConfirmedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateManyStoreInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: string | null
    avatar?: string | null
    isGuest?: boolean
    customerType?: $Enums.CustomerType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerGroupsCreateManyStoreInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateManyStoreInput = {
    id?: string
    name?: string | null
    amount?: number | null
    description?: string | null
    paymentMethod?: string | null
    paymentStatus?: string | null
    date?: Date | string | null
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyStoreInput = {
    id?: string
    invoiceNumber: string
    title: string
    customerEmail: string
    description?: string | null
    status?: string | null
    downloadUrl: string
    paymentLink?: string | null
    qrCode?: string | null
    amount: string
    total?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyStoreInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    locationId?: string | null
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouseId?: string | null
  }

  export type SupplierCreateManyStoreInput = {
    id?: string
    supplierName: string
    email: string
    phoneNumber: string
    personOfSupplier: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateManyStoreInput = {
    id?: string
    status: string
    downloadUrl: string
    toalCost: Decimal | DecimalJsLike | number | string
    storeSupplierId: string
    deliveryDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementCreateManyStoreInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyStoreInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseCreateManyStoreInput = {
    id?: string
    name: string
    isDefaultLocation?: boolean | null
    staffId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingMethodCreateManyStoreInput = {
    id?: string
    name: string
    description?: string | null
    carrier?: string | null
    deliveryTime: string
    baseCost: number
    costCalculation?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingZoneCreateManyStoreInput = {
    id?: string
    name: string
    countries?: ShippingZoneCreatecountriesInput | string[]
    regions?: ShippingZoneCreateregionsInput | string[]
    postalCodes?: ShippingZoneCreatepostalCodesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateManyStoreInput = {
    id?: string
    name?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateManyWithoutLocationNestedInput
    order?: OrderUpdateManyWithoutLocationNestedInput
    product?: ProductUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateManyWithoutLocationNestedInput
    order?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    product?: ProductUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isdefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    pos?: POSUpdateOneWithoutOrderNestedInput
    cart?: CartUpdateOneWithoutOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    location?: LocationUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    pos?: POSUncheckedUpdateOneWithoutOrderNestedInput
    cart?: CartUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    shippingMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    grandTotal?: FloatFieldUpdateOperationsInput | number
    iscustomerAssigned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    deliveryTrackingNumber?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    subtotalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxAmount?: FloatFieldUpdateOperationsInput | number
    shippingFee?: FloatFieldUpdateOperationsInput | number
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    isposConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhoneNumber?: StringFieldUpdateOperationsInput | string
    posConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    carts?: CartUpdateManyWithoutCustomerNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutCustomerNestedInput
    pos?: POSUpdateManyWithoutCustomerNestedInput
    customerGroupMember?: CustomerGroupMemberUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    carts?: CartUncheckedUpdateManyWithoutCustomerNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    pos?: POSUncheckedUpdateManyWithoutCustomerNestedInput
    customerGroupMember?: CustomerGroupMemberUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isGuest?: BoolFieldUpdateOperationsInput | boolean
    customerType?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupsUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerGroupMember?: CustomerGroupMemberUpdateManyWithoutCustomerGroupNestedInput
  }

  export type CustomerGroupsUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerGroupMember?: CustomerGroupMemberUncheckedUpdateManyWithoutCustomerGroupNestedInput
  }

  export type CustomerGroupsUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenseCategory?: ExpenseCategoryUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenseCategory?: ExpenseCategoryUncheckedUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: StringFieldUpdateOperationsInput | string
    paymentLink?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: StringFieldUpdateOperationsInput | string
    paymentLink?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: StringFieldUpdateOperationsInput | string
    paymentLink?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredBrands?: FeaturedBrandsUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    collection?: ProductCollectionUpdateOneWithoutProductsNestedInput
    purchase?: PurchaseUpdateOneWithoutProductsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryNestedInput
    location?: LocationUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    featuredBrands?: FeaturedBrandsUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personOfSupplier?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateManyWithoutStoreSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personOfSupplier?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    personOfSupplier?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    toalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeSupplier?: SupplierUpdateOneRequiredWithoutPurchaseNestedInput
    products?: ProductUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    toalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    storeSupplierId?: StringFieldUpdateOperationsInput | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    toalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    storeSupplierId?: StringFieldUpdateOperationsInput | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryUpdateManyWithoutWarehouseNestedInput
    staffAssigned?: UserUpdateOneRequiredWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    staffId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: ProductUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefaultLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    staffId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingMethodUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    costCalculation?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippingZones?: ShippingZoneUpdateManyWithoutShippingMethodsNestedInput
    Shipping?: ShippingUpdateManyWithoutShippingMethodNestedInput
  }

  export type ShippingMethodUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    costCalculation?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippingZones?: ShippingZoneUncheckedUpdateManyWithoutShippingMethodsNestedInput
    Shipping?: ShippingUncheckedUpdateManyWithoutShippingMethodNestedInput
  }

  export type ShippingMethodUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    costCalculation?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingZoneUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countries?: ShippingZoneUpdatecountriesInput | string[]
    regions?: ShippingZoneUpdateregionsInput | string[]
    postalCodes?: ShippingZoneUpdatepostalCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippingMethods?: ShippingMethodUpdateManyWithoutShippingZonesNestedInput
  }

  export type ShippingZoneUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countries?: ShippingZoneUpdatecountriesInput | string[]
    regions?: ShippingZoneUpdateregionsInput | string[]
    postalCodes?: ShippingZoneUpdatepostalCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippingMethods?: ShippingMethodUncheckedUpdateManyWithoutShippingZonesNestedInput
  }

  export type ShippingZoneUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countries?: ShippingZoneUpdatecountriesInput | string[]
    regions?: ShippingZoneUpdateregionsInput | string[]
    postalCodes?: ShippingZoneUpdatepostalCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingAuditCreateManyShippingInput = {
    id?: string
    action: string
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShippingAuditUpdateWithoutShippingInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShippingAuditUncheckedUpdateWithoutShippingInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShippingAuditUncheckedUpdateManyWithoutShippingInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ShippingCreateManyShippingMethodInput = {
    id?: string
    orderId: string
    trackingNumber?: string | null
    carrier?: string | null
    status?: $Enums.ShippingStatus
    estimatedDelivery?: Date | string | null
    actualDelivery?: Date | string | null
    shippingAddress: string
    shippingZoneName?: string | null
    shippingFee?: Decimal | DecimalJsLike | number | string
    weight?: number | null
    dimensions?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingZoneUpdateWithoutShippingMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countries?: ShippingZoneUpdatecountriesInput | string[]
    regions?: ShippingZoneUpdateregionsInput | string[]
    postalCodes?: ShippingZoneUpdatepostalCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutShippingZoneNestedInput
  }

  export type ShippingZoneUncheckedUpdateWithoutShippingMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    countries?: ShippingZoneUpdatecountriesInput | string[]
    regions?: ShippingZoneUpdateregionsInput | string[]
    postalCodes?: ShippingZoneUpdatepostalCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingZoneUncheckedUpdateManyWithoutShippingMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    countries?: ShippingZoneUpdatecountriesInput | string[]
    regions?: ShippingZoneUpdateregionsInput | string[]
    postalCodes?: ShippingZoneUpdatepostalCodesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingUpdateWithoutShippingMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShippingStatusFieldUpdateOperationsInput | $Enums.ShippingStatus
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: StringFieldUpdateOperationsInput | string
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: ShippingAuditUpdateManyWithoutShippingNestedInput
  }

  export type ShippingUncheckedUpdateWithoutShippingMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShippingStatusFieldUpdateOperationsInput | $Enums.ShippingStatus
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: StringFieldUpdateOperationsInput | string
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: ShippingAuditUncheckedUpdateManyWithoutShippingNestedInput
  }

  export type ShippingUncheckedUpdateManyWithoutShippingMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShippingStatusFieldUpdateOperationsInput | $Enums.ShippingStatus
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: StringFieldUpdateOperationsInput | string
    shippingZoneName?: NullableStringFieldUpdateOperationsInput | string | null
    shippingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingMethodUpdateWithoutShippingZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    costCalculation?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: OrganizationUpdateOneRequiredWithoutShippingMethodNestedInput
    Shipping?: ShippingUpdateManyWithoutShippingMethodNestedInput
  }

  export type ShippingMethodUncheckedUpdateWithoutShippingZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    costCalculation?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shipping?: ShippingUncheckedUpdateManyWithoutShippingMethodNestedInput
  }

  export type ShippingMethodUncheckedUpdateManyWithoutShippingZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: StringFieldUpdateOperationsInput | string
    baseCost?: FloatFieldUpdateOperationsInput | number
    costCalculation?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyWarehouseInput = {
    id?: string
    name: string
    shortDescription?: string | null
    description?: string | null
    sku?: string | null
    stock?: number | null
    price: Decimal | DecimalJsLike | number | string
    shippingWeight?: string | null
    handleTime?: string | null
    freeShipping?: boolean | null
    packaging?: string | null
    discountPrice?: string | null
    unitSold?: string | null
    length?: number | null
    width?: number | null
    height?: number | null
    productSize?: string | null
    productStatus?: $Enums.ProductStatus | null
    imageUrl?: ProductCreateimageUrlInput | string[]
    storeId: string
    locationId?: string | null
    purchaseOrderId?: string | null
    collectionId?: string | null
    hasVariation?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateManyWarehouseInput = {
    id?: string
    quantity?: number
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredBrands?: FeaturedBrandsUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUpdateManyWithoutProductNestedInput
    collection?: ProductCollectionUpdateOneWithoutProductsNestedInput
    purchase?: PurchaseUpdateOneWithoutProductsNestedInput
    store?: OrganizationUpdateOneRequiredWithoutProductNestedInput
    location?: LocationUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredBrands?: FeaturedBrandsUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    productVariation?: ProductVariationUncheckedUpdateManyWithoutProductNestedInput
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingWeight?: NullableStringFieldUpdateOperationsInput | string | null
    handleTime?: NullableStringFieldUpdateOperationsInput | string | null
    freeShipping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    packaging?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    unitSold?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    productSize?: NullableStringFieldUpdateOperationsInput | string | null
    productStatus?: NullableEnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus | null
    imageUrl?: ProductUpdateimageUrlInput | string[]
    storeId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    hasVariation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}